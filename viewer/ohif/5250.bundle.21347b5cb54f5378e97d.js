"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[5250],{8455:(e,n,t)=>{t.d(n,{ZP:()=>g});var o=t(68470),r=t(59474),i=t(91382),a=t(14418),s=t(57036),l=t(35368),d=t(72076);const{vtkErrorMacro:c}=o.m;const u={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:l._.EMPTY};function m(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(n,u,t),a.default.extend(e,n,t),n.direction?Array.isArray(n.direction)&&(n.direction=new Float64Array(n.direction.slice(0,9))):n.direction=d.wO.identity(new Float64Array(9)),n.indexToWorld=new Float64Array(16),n.worldToIndex=new Float64Array(16),o.m.get(e,n,["indexToWorld","worldToIndex"]),o.m.setGetArray(e,n,["origin","spacing"],3),o.m.setGetArray(e,n,["direction"],9),o.m.getArray(e,n,["extent"],6),function(e,n){n.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(n.deleted)return c("instance deleted - cannot call any method"),!1;for(var t=arguments.length,o=new Array(t),r=0;r<t;r++)o[r]=arguments[r];const i=1===o.length?o[0]:o;if(6!==i.length)return!1;const a=n.extent.some(((e,n)=>e!==i[n]));return a&&(n.extent=i.slice(),n.dataDescription=s.Z.getDataDescriptionFromExtent(n.extent),e.modified()),a},e.setDimensions=function(){let t,o,r;if(n.deleted)c("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];t=e[0],o=e[1],r=e[2]}else{if(3!==arguments.length)return void c("Bad dimension specification");t=arguments.length<=0?void 0:arguments[0],o=arguments.length<=1?void 0:arguments[1],r=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,t-1,0,o-1,0,r-1)}},e.getDimensions=()=>[n.extent[1]-n.extent[0]+1,n.extent[3]-n.extent[2]+1,n.extent[5]-n.extent[4]+1],e.getNumberOfCells=()=>{const n=e.getDimensions();let t=1;for(let e=0;e<3;e++){if(0===n[e])return 0;n[e]>1&&(t*=n[e]-1)}return t},e.getNumberOfPoints=()=>{const n=e.getDimensions();return n[0]*n[1]*n[2]},e.getPoint=t=>{const o=e.getDimensions();if(0===o[0]||0===o[1]||0===o[2])return c("Requesting a point from an empty image."),null;const r=new Float64Array(3);switch(n.dataDescription){case l._.EMPTY:return null;case l._.SINGLE_POINT:break;case l._.X_LINE:r[0]=t;break;case l._.Y_LINE:r[1]=t;break;case l._.Z_LINE:r[2]=t;break;case l._.XY_PLANE:r[0]=t%o[0],r[1]=t/o[0];break;case l._.YZ_PLANE:r[1]=t%o[1],r[2]=t/o[1];break;case l._.XZ_PLANE:r[0]=t%o[0],r[2]=t/o[0];break;case l._.XYZ_GRID:r[0]=t%o[0],r[1]=t/o[0]%o[1],r[2]=t/(o[0]*o[1]);break;default:c("Invalid dataDescription")}const i=[0,0,0];return e.indexToWorld(r,i),i},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>i.ZP.transformBounds(e,n.indexToWorld),e.getSpatialExtent=()=>i.ZP.inflate([...n.extent],.5),e.computeTransforms=()=>{d._E.fromTranslation(n.indexToWorld,n.origin),n.indexToWorld[0]=n.direction[0],n.indexToWorld[1]=n.direction[1],n.indexToWorld[2]=n.direction[2],n.indexToWorld[4]=n.direction[3],n.indexToWorld[5]=n.direction[4],n.indexToWorld[6]=n.direction[5],n.indexToWorld[8]=n.direction[6],n.indexToWorld[9]=n.direction[7],n.indexToWorld[10]=n.direction[8],d._E.scale(n.indexToWorld,n.indexToWorld,n.spacing),d._E.invert(n.worldToIndex,n.indexToWorld)},e.indexToWorld=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return d.R3.transformMat4(t,e,n.indexToWorld),t},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return d.R3.transformMat4(t,e,n.worldToIndex),t},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return i.ZP.transformBounds(e,n.indexToWorld,t)},e.worldToIndexBounds=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return i.ZP.transformBounds(e,n.worldToIndex,t)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>i.ZP.getCenter(e.getBounds()),e.computeHistogram=function(n){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const o=[0,0,0,0,0,0];e.worldToIndexBounds(n,o);const a=[0,0,0],s=[0,0,0];i.ZP.computeCornerPoints(o,a,s),(0,r.b)(a,a),(0,r.b)(s,s);const l=e.getDimensions();(0,r.c)(a,[0,0,0],[l[0]-1,l[1]-1,l[2]-1],a),(0,r.c)(s,[0,0,0],[l[0]-1,l[1]-1,l[2]-1],s);const d=l[0],c=l[0]*l[1],u=e.getPointData().getScalars().getData();let m=-1/0,g=1/0,x=0,f=0,T=0;for(let e=a[2];e<=s[2];e++)for(let n=a[1];n<=s[1];n++){let r=a[0]+n*d+e*c;for(let i=a[0];i<=s[0];i++){if(!t||t([i,n,e],o)){const e=u[r];e>m&&(m=e),e<g&&(g=e),x+=e*e,f+=e,T+=1}++r}}const h=T>0?f/T:0,p=T?Math.abs(x/T-h*h):0;return{minimum:g,maximum:m,average:h,variance:p,sigma:Math.sqrt(p),count:T}},e.computeIncrements=function(e){const n=[];let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let o=0;o<3;++o)n[o]=t,t*=e[2*o+1]-e[2*o]+1;return n},e.computeOffsetIndex=n=>{let[t,o,r]=n;const i=e.getExtent(),a=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(i,a);return Math.floor((Math.round(t)-i[0])*s[0]+(Math.round(o)-i[2])*s[1]+(Math.round(r)-i[4])*s[2])},e.getOffsetIndexFromWorld=n=>{const t=e.getExtent(),o=e.worldToIndex(n);for(let e=0;e<3;++e)if(o[e]<t[2*e]||o[e]>t[2*e+1])return c(`GetScalarPointer: Pixel ${o} is not in memory. Current extent = ${t}`),NaN;return e.computeOffsetIndex(o)},e.getScalarValueFromWorld=function(n){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getPointData().getScalars().getNumberOfComponents();if(t<0||t>=o)return c(`GetScalarPointer: Scalar Component ${t} is not within bounds. Current Scalar numberOfComponents: ${o}`),NaN;const r=e.getOffsetIndexFromWorld(n);return Number.isNaN(r)?r:e.getPointData().getScalars().getComponent(r,t)}}(e,n)}var g={newInstance:o.m.newInstance(m,"vtkImageData"),extend:m}},3969:(e,n,t)=>{t.d(n,{ZP:()=>h});var o=t(59474),r=t(68470);const i=1e-6,a="coincide",s="disjoint";function l(e,n,t){const o=t[0]*(e[0]-n[0])+t[1]*(e[1]-n[1])+t[2]*(e[2]-n[2]);return Math.abs(o)}function d(e,n,t,r){const i=[];(0,o.s)(e,n,i);const a=(0,o.d)(t,i);r[0]=e[0]-a*t[0],r[1]=e[1]-a*t[1],r[2]=e[2]-a*t[2]}function c(e,n,t){const r=(0,o.d)(e,n);let i=(0,o.d)(n,n);return 0===i&&(i=1),t[0]=e[0]-r*n[0]/i,t[1]=e[1]-r*n[1]/i,t[2]=e[2]-r*n[2]/i,t}function u(e,n,t,r){const i=[];(0,o.s)(e,n,i);const a=(0,o.d)(t,i),s=(0,o.d)(t,t);0!==s?(r[0]=e[0]-a*t[0]/s,r[1]=e[1]-a*t[1]/s,r[2]=e[2]-a*t[2]/s):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function m(e,n,t,r){const a={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},s=[],l=[];(0,o.s)(n,e,s),(0,o.s)(t,e,l);const d=(0,o.d)(r,l),c=(0,o.d)(r,s);let u,m;return u=c<0?-c:c,m=d<0?-d*i:d*i,u<=m||(a.t=d/c,a.x[0]=e[0]+a.t*s[0],a.x[1]=e[1]+a.t*s[1],a.x[2]=e[2]+a.t*s[2],a.intersection=!0,a.betweenPoints=a.t>=0&&a.t<=1),a}function g(e,n,t,r){const l={intersection:!1,l0:[],l1:[],error:null},d=[];(0,o.j)(n,r,d);const c=d.map((e=>Math.abs(e)));if(c[0]+c[1]+c[2]<i){const r=[];return(0,o.s)(e,t,r),0===(0,o.d)(n,r)?l.error=a:l.error=s,l}let u;u=c[0]>c[1]&&c[0]>c[2]?"x":c[1]>c[2]?"y":"z";const m=[],g=-(0,o.d)(n,e),x=-(0,o.d)(r,t);switch(u){case"x":m[0]=0,m[1]=(x*n[2]-g*r[2])/d[0],m[2]=(g*r[1]-x*n[1])/d[0];break;case"y":m[0]=(g*r[2]-x*n[2])/d[1],m[1]=0,m[2]=(x*n[0]-g*r[0])/d[1];break;case"z":m[0]=(x*n[1]-g*r[1])/d[2],m[1]=(g*r[0]-x*n[0])/d[2],m[2]=0}return l.l0=m,(0,o.k)(m,d,l.l1),l.intersection=!0,l}const x={evaluate:function(e,n,t){return e[0]*(t[0]-n[0])+e[1]*(t[1]-n[1])+e[2]*(t[2]-n[2])},distanceToPlane:l,projectPoint:d,projectVector:c,generalizedProjectPoint:u,intersectWithLine:m,intersectWithPlane:g,DISJOINT:s,COINCIDE:a};const f={normal:[0,0,1],origin:[0,0,0]};function T(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(n,f,t),r.m.obj(e,n),r.m.setGetArray(e,n,["normal","origin"],3),function(e,n){n.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>l(e,n.origin,n.normal),e.projectPoint=(e,t)=>{d(e,n.origin,n.normal,t)},e.projectVector=(e,t)=>c(e,n.normal,t),e.push=e=>{if(0!==e)for(let t=0;t<3;t++)n.origin[t]+=e*n.normal[t]},e.generalizedProjectPoint=(e,t)=>{u(e,n.origin,n.normal,t)},e.evaluateFunction=(e,t,o)=>Array.isArray(e)?n.normal[0]*(e[0]-n.origin[0])+n.normal[1]*(e[1]-n.origin[1])+n.normal[2]*(e[2]-n.origin[2]):n.normal[0]*(e-n.origin[0])+n.normal[1]*(t-n.origin[1])+n.normal[2]*(o-n.origin[2]),e.evaluateGradient=e=>[n.normal[0],n.normal[1],n.normal[2]],e.intersectWithLine=(e,t)=>m(e,t,n.origin,n.normal),e.intersectWithPlane=(e,t)=>g(e,t,n.origin,n.normal)}(e,n)}var h={newInstance:r.m.newInstance(T,"vtkPlane"),extend:T,...x}}}]);
//# sourceMappingURL=5250.bundle.21347b5cb54f5378e97d.js.map