{"version":3,"file":"5250.bundle.21347b5cb54f5378e97d.js","mappings":"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","sources":["webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/Plane.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","import { s as subtract, d as dot, j as cross, k as add } from '../Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\n\nconst PLANE_TOLERANCE = 1.0e-6;\nconst COINCIDE = 'coincide';\nconst DISJOINT = 'disjoint';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction evaluate(normal, origin, x) {\n  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n}\nfunction distanceToPlane(x, origin, normal) {\n  const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);\n  return Math.abs(distance);\n}\nfunction projectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  xproj[0] = x[0] - t * normal[0];\n  xproj[1] = x[1] - t * normal[1];\n  xproj[2] = x[2] - t * normal[2];\n}\nfunction projectVector(v, normal, vproj) {\n  const t = dot(v, normal);\n  let n2 = dot(normal, normal);\n  if (n2 === 0) {\n    n2 = 1.0;\n  }\n  vproj[0] = v[0] - t * normal[0] / n2;\n  vproj[1] = v[1] - t * normal[1] / n2;\n  vproj[2] = v[2] - t * normal[2] / n2;\n  return vproj;\n}\nfunction generalizedProjectPoint(x, origin, normal, xproj) {\n  const xo = [];\n  subtract(x, origin, xo);\n  const t = dot(normal, xo);\n  const n2 = dot(normal, normal);\n  if (n2 !== 0) {\n    xproj[0] = x[0] - t * normal[0] / n2;\n    xproj[1] = x[1] - t * normal[1] / n2;\n    xproj[2] = x[2] - t * normal[2] / n2;\n  } else {\n    xproj[0] = x[0];\n    xproj[1] = x[1];\n    xproj[2] = x[2];\n  }\n}\nfunction intersectWithLine(p1, p2, origin, normal) {\n  const outObj = {\n    intersection: false,\n    betweenPoints: false,\n    t: Number.MAX_VALUE,\n    x: []\n  };\n  const p21 = [];\n  const p1Origin = [];\n  // Compute line vector\n  subtract(p2, p1, p21);\n  subtract(origin, p1, p1Origin);\n\n  // Compute denominator.  If ~0, line and plane are parallel.\n  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);\n  const num = dot(normal, p1Origin);\n  const den = dot(normal, p21);\n\n  // If denominator with respect to numerator is \"zero\", then the line and\n  // plane are considered parallel.\n  let fabsden;\n  let fabstolerance;\n\n  // Trying to avoid an expensive call to fabs()\n  if (den < 0.0) {\n    fabsden = -den;\n  } else {\n    fabsden = den;\n  }\n  if (num < 0.0) {\n    fabstolerance = -num * PLANE_TOLERANCE;\n  } else {\n    fabstolerance = num * PLANE_TOLERANCE;\n  }\n  if (fabsden <= fabstolerance) {\n    return outObj;\n  }\n\n  // Where on the line between p1 and p2 is the intersection\n  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2\n  outObj.t = num / den;\n  outObj.x[0] = p1[0] + outObj.t * p21[0];\n  outObj.x[1] = p1[1] + outObj.t * p21[1];\n  outObj.x[2] = p1[2] + outObj.t * p21[2];\n  outObj.intersection = true;\n  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;\n  return outObj;\n}\nfunction intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {\n  const outObj = {\n    intersection: false,\n    l0: [],\n    l1: [],\n    error: null\n  };\n  const cross$1 = [];\n  cross(plane1Normal, plane2Normal, cross$1);\n  const absCross = cross$1.map(n => Math.abs(n));\n\n  // test if the two planes are parallel\n  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {\n    // test if disjoint or coincide\n    const v = [];\n    subtract(plane1Origin, plane2Origin, v);\n    if (dot(plane1Normal, v) === 0) {\n      outObj.error = COINCIDE;\n    } else {\n      outObj.error = DISJOINT;\n    }\n    return outObj;\n  }\n\n  // Plane1 and Plane2 intersect in a line\n  // first determine max abs coordinate of the cross product\n  let maxc;\n  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {\n    maxc = 'x';\n  } else if (absCross[1] > absCross[2]) {\n    maxc = 'y';\n  } else {\n    maxc = 'z';\n  }\n\n  // To get a point on the intersect line, zero the max coord, and solve for the other two\n  const iP = []; // intersectionPoint\n  // the constants in the 2 plane equations\n  const d1 = -dot(plane1Normal, plane1Origin);\n  const d2 = -dot(plane2Normal, plane2Origin);\n\n  // eslint-disable-next-line default-case\n  switch (maxc) {\n    case 'x':\n      // intersect with x=0\n      iP[0] = 0;\n      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];\n      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];\n      break;\n    case 'y':\n      // intersect with y=0\n      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];\n      iP[1] = 0;\n      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];\n      break;\n    case 'z':\n      // intersect with z=0\n      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];\n      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];\n      iP[2] = 0;\n      break;\n  }\n  outObj.l0 = iP;\n  add(iP, cross$1, outObj.l1);\n  outObj.intersection = true;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  evaluate,\n  distanceToPlane,\n  projectPoint,\n  projectVector,\n  generalizedProjectPoint,\n  intersectWithLine,\n  intersectWithPlane,\n  DISJOINT,\n  COINCIDE\n};\n\n// ----------------------------------------------------------------------------\n// vtkPlane methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPlane(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPlane');\n  publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);\n  publicAPI.projectPoint = (x, xproj) => {\n    projectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);\n  publicAPI.push = distance => {\n    if (distance === 0.0) {\n      return;\n    }\n    for (let i = 0; i < 3; i++) {\n      model.origin[i] += distance * model.normal[i];\n    }\n  };\n  publicAPI.generalizedProjectPoint = (x, xproj) => {\n    generalizedProjectPoint(x, model.origin, model.normal, xproj);\n  };\n  publicAPI.evaluateFunction = (x, y, z) => {\n    if (!Array.isArray(x)) {\n      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);\n    }\n    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);\n  };\n  publicAPI.evaluateGradient = xyz => {\n    const retVal = [model.normal[0], model.normal[1], model.normal[2]];\n    return retVal;\n  };\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);\n  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  normal: [0.0, 0.0, 1.0],\n  origin: [0.0, 0.0, 0.0]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);\n  vtkPlane(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPlane');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPlane$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkPlane$1 as default, extend, newInstance, vtkPlane };\n"],"names":["vtkErrorMacro","m","DEFAULT_VALUES","direction","indexToWorld","worldToIndex","spacing","origin","extent","dataDescription","EMPTY","extend","publicAPI","model","initialValues","arguments","length","undefined","Object","assign","Array","isArray","Float64Array","slice","get","setGetArray","getArray","classHierarchy","push","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","some","item","index","modified","setDimensions","i","j","k","array","getDimensions","getNumberOfCells","dims","nCells","getNumberOfPoints","getPoint","ijk","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","extentToBounds","getSpatialExtent","ex","computeTransforms","ain","aout","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunc","bounds","point1","point2","dimensions","c","yStride","zStride","pixels","getPointData","getScalars","getData","maximum","minimum","Infinity","sumOfSquares","isum","inum","z","y","x","pixel","average","variance","Math","abs","sigma","sqrt","count","computeIncrements","increments","incr","idx","computeOffsetIndex","_ref","getExtent","numberOfComponents","getNumberOfComponents","floor","round","getOffsetIndexFromWorld","xyz","NaN","getScalarValueFromWorld","comp","offsetIndex","Number","isNaN","getComponent","vtkImageData","vtkImageData$1","newInstance","PLANE_TOLERANCE","COINCIDE","DISJOINT","distanceToPlane","normal","distance","projectPoint","xproj","xo","s","t","d","projectVector","v","vproj","n2","generalizedProjectPoint","intersectWithLine","p1","p2","outObj","intersection","betweenPoints","MAX_VALUE","p21","p1Origin","num","den","fabsden","fabstolerance","intersectWithPlane","plane1Origin","plane1Normal","plane2Origin","plane2Normal","l0","l1","error","cross$1","absCross","map","n","maxc","iP","d1","d2","STATIC","evaluate","obj","evaluateFunction","evaluateGradient","planeOrigin","planeNormal","vtkPlane","vtkPlane$1"],"sourceRoot":""}