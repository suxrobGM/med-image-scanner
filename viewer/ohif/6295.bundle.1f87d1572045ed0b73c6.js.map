{"version":3,"file":"6295.bundle.1f87d1572045ed0b73c6.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationFrameRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/annotationHydration.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/calibrateImageSpacing.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/cine/playClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/addContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/areSameSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/isContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contourSegmentation/removeContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/calculatePerimeter.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/findHandlePolylineIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/areCoplanarContours.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/contourFinder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getDeduplicatedVTKPolyDataPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/detectContourHoles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/generateContourSetsFromLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/AnnotationToPointData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/getContourHolesDataCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/interpolation/acceptAutogeneratedInterpolations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/contours/updateContourPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/getDataInTime.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getAnnotationNearPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getCalibratedUnits.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getSphereBoundsInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/intersectAABB.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/aabb/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/Calculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/basic/BasicStatsCalculator.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/pointInEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquaredInfo.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/intersectLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/line/isPointOnLineSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/distanceToPointSquared.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/point/mirror.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isClosed.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/containsPoints.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSignedArea.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getWindingDirection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getNormal2.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/areLineSegmentsIntersecting.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLinesIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/combinePolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/intersectPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/decimate.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getClosestLineSegmentIntersection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/projectTo2D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/polyline/isPointInsidePolyline3D.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/rectangle/distanceToPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/sphere/pointInSphere.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/liangBarksyClip.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/getOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/orientation/invertOrientationStringLPS.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planarFreehandROITool/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/planar/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInShapeCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointInSurroundingSphereCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/pointToString.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/polyData/utils.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/rectangleROITool/isAxisAlignedRectangle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/scroll.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/InterpolationManager/InterpolationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushSizeForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isLineInSegment.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/findLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/contourAndFindLargestBidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createBidirectionalToolData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createImageIdReferenceMap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/floodFill.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getHoveredContourSegmentationAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtLabelmapBorder.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getSegmentAtWorldPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/invalidateBrushCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/isValidRepresentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/segmentContourAction.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/thresholdVolumeByRange.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/utilities.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForToolGroupIds.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/isViewportPreScaled.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToSlice.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/viewport/jumpToWorld.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec3/interpolateVec3.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ColorbarTicks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/widgets/Widget.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/Colorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/ViewportColorbar.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getVOIMultipliers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/getLuminanceFromRegion.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/calculateMinMaxMean.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/voi/windowlevel/extractWindowLevelRegionToolData.ts","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js"],"sourcesContent":["import {\n  BaseVolumeViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { addAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  /**\n   * Creates a base annotation object, adding in any annotation base data provided\n   */\n  public static createAnnotation(...annotationBaseData): Annotation {\n    let annotation: Annotation = {\n      annotationUID: null as string,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.toolName,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: new Array<Types.Point3>(),\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    } as unknown as Annotation;\n    for (const baseData of annotationBaseData) {\n      annotation = csUtils.deepMerge(annotation, baseData);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates a new annotation for the given viewport.  This just adds the\n   * viewport reference data to the metadata, and otherwise returns the\n   * static class createAnnotation data.\n   */\n  public static createAnnotationForViewport(viewport, ...annotationBaseData) {\n    return this.createAnnotation(\n      { metadata: viewport.getViewReference() },\n      ...annotationBaseData\n    );\n  }\n\n  /**\n   * Creates and adds an annotation of the given type, firing the annotation\n   * modified event on the new annotation.\n   * This implicitly uses the static class when you call it on the correct\n   * base class.  For example, you can call the KeyImageTool.createAnnotation\n   * method on KeyImageTool.toolName by calling KeyImageTool.createAndAddAnnotation\n   *\n   */\n  public static createAndAddAnnotation(viewport, ...annotationBaseData) {\n    const annotation = this.createAnnotationForViewport(\n      viewport,\n      ...annotationBaseData\n    );\n    addAnnotation(annotation, viewport.element);\n    triggerAnnotationModified(annotation, viewport.element);\n  }\n\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { isCanvasAnnotation } = data;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points?.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = isCanvasAnnotation\n        ? point.slice(0, 2)\n        : viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(\n          canvasCoords,\n          annotationCanvasCoordinate as Types.Point2\n        ) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = csUtils.getVolumeId(targetId);\n      const volume = cache.getVolume(volumeId);\n      return volume?.scaling?.PT !== undefined;\n    }\n    const scalingModule: Types.ScalingParameters | undefined =\n      imageId && metaData.get('scalingModule', imageId);\n    return typeof scalingModule?.suvbw === 'number';\n  }\n\n  /**\n   * Get the style that will be applied to all annotations such as length, cobb\n   * angle, arrow annotate, etc. when rendered on a canvas or svg layer\n   */\n  protected getAnnotationStyle(context: {\n    annotation: Annotation;\n    styleSpecifier: StyleSpecifier;\n  }) {\n    const { annotation, styleSpecifier } = context;\n    const getStyle = (property) =>\n      this.getStyle(property, styleSpecifier, annotation);\n    const { annotationUID } = annotation;\n    const visibility = isAnnotationVisible(annotationUID);\n    const locked = isAnnotationLocked(annotation);\n\n    const lineWidth = getStyle('lineWidth') as number;\n    const lineDash = getStyle('lineDash') as string;\n    const color = getStyle('color') as string;\n    const shadow = getStyle('shadow') as boolean;\n    const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    return {\n      visibility,\n      locked,\n      color,\n      lineWidth,\n      lineDash,\n      lineOpacity: 1,\n      fillColor: color,\n      fillOpacity: 0,\n      shadow,\n      textbox: textboxStyle,\n    };\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  activeSegmentOutlineWidthDelta: 0,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.activeSegmentOutlineWidthDelta === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { Annotation } from '../types';\n\nexport type FramesRange = [number, number] | number;\n\n/**\n * This class handles the annotation frame range values for multiframes.\n * Mostly used for the Video viewport, it allows references to\n * a range of frame values.\n */\nexport default class AnnotationFrameRange {\n  protected static frameRangeExtractor =\n    /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  protected static imageIdToFrames(imageId: string): FramesRange {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    if (range.length === 1) {\n      return range[0];\n    }\n    return range as FramesRange;\n  }\n\n  public static framesToString(range) {\n    if (Array.isArray(range)) {\n      return `${range[0]}-${range[1]}`;\n    }\n    return String(range);\n  }\n\n  protected static framesToImageId(\n    imageId: string,\n    range: FramesRange | string\n  ): string {\n    const match = imageId.match(this.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return null;\n    }\n    const newRangeString = this.framesToString(range);\n    return imageId.replace(\n      this.frameRangeExtractor,\n      `${match[1]}${newRangeString}`\n    );\n  }\n\n  /**\n   * Sets the range of frames to associate with the given annotation.\n   * The range can be a single frame number (1 based according to DICOM),\n   * or a range of values in the format `min-max` where min, max are inclusive\n   * Modifies the referencedImageID to specify the updated URL.\n   */\n  public static setFrameRange(\n    annotation: Annotation,\n    range: FramesRange | string,\n    eventBase?: { viewportId; renderingEngineId }\n  ) {\n    const { referencedImageId } = annotation.metadata;\n    annotation.metadata.referencedImageId = this.framesToImageId(\n      referencedImageId,\n      range\n    );\n    const eventDetail = {\n      ...eventBase,\n      annotation,\n    };\n    triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n  }\n\n  public static getFrameRange(\n    annotation: Annotation\n  ): number | [number, number] {\n    return this.imageIdToFrames(annotation.metadata.referencedImageId);\n  }\n}\n","import {\n  Types,\n  utilities,\n  BaseVolumeViewport,\n  StackViewport,\n  cache,\n  metaData,\n} from '@cornerstonejs/core';\nimport { Annotation } from '../types';\nimport { addAnnotation } from '../stateManagement';\nimport { vec3 } from 'gl-matrix';\n\nfunction annotationHydration(\n  viewport: Types.IViewport,\n  toolName: string,\n  worldPoints: Types.Point3[],\n  options?: {\n    FrameOfReferenceUID?: string;\n    annotationUID?: string;\n  }\n): Annotation {\n  const viewReference = viewport.getViewReference();\n  const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n  const annotation = {\n    annotationUID: options?.annotationUID || utilities.uuidv4(),\n    data: {\n      handles: {\n        points: worldPoints,\n      },\n    },\n    highlighted: false,\n    autoGenerated: false,\n    invalidated: false,\n    isLocked: false,\n    isVisible: true,\n    metadata: {\n      toolName,\n      viewPlaneNormal,\n      FrameOfReferenceUID,\n      referencedImageId: getReferencedImageId(\n        viewport,\n        worldPoints[0],\n        viewPlaneNormal\n      ),\n      ...options,\n    },\n  };\n  addAnnotation(annotation, viewport.element);\n  return annotation;\n}\n\nfunction getReferencedImageId(\n  viewport: Types.IViewport,\n  worldPos: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): string {\n  let referencedImageId;\n\n  if (viewport instanceof StackViewport) {\n    referencedImageId = getClosestImageIdForStackViewport(\n      viewport,\n      worldPos,\n      viewPlaneNormal\n    );\n  } else if (viewport instanceof BaseVolumeViewport) {\n    const targetId = getTargetId(viewport);\n    const volumeId = utilities.getVolumeId(targetId);\n    const imageVolume = cache.getVolume(volumeId);\n\n    referencedImageId = utilities.getClosestImageId(\n      imageVolume,\n      worldPos,\n      viewPlaneNormal\n    );\n  } else {\n    throw new Error(\n      'getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport'\n    );\n  }\n\n  return referencedImageId;\n}\n\nfunction getTargetId(viewport: Types.IViewport): string | undefined {\n  const targetId = viewport.getReferenceId?.();\n  if (targetId) {\n    return targetId;\n  }\n  if (viewport instanceof BaseVolumeViewport) {\n    return `volumeId:${getTargetVolumeId(viewport)}`;\n  }\n  throw new Error('getTargetId: viewport must have a getTargetId method');\n}\n\nfunction getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n  const actorEntries = viewport.getActors();\n\n  if (!actorEntries) {\n    return;\n  }\n  return actorEntries.find(\n    (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n  )?.uid;\n}\n\nfunction getClosestImageIdForStackViewport(\n  viewport: StackViewport,\n  worldPos: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): string {\n  const imageIds = viewport.getImageIds();\n  if (!imageIds || !imageIds.length) {\n    return;\n  }\n\n  const distanceImagePairs = imageIds.map((imageId) => {\n    const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n    const distance = calculateDistanceToImage(\n      worldPos,\n      imagePositionPatient,\n      viewPlaneNormal\n    );\n    return { imageId, distance };\n  });\n\n  distanceImagePairs.sort((a, b) => a.distance - b.distance);\n\n  return distanceImagePairs[0].imageId;\n}\n\nfunction calculateDistanceToImage(\n  worldPos: Types.Point3,\n  ImagePositionPatient: Types.Point3,\n  viewPlaneNormal: Types.Point3\n): number {\n  const dir = vec3.create();\n  vec3.sub(dir, worldPos, ImagePositionPatient);\n\n  const dot = vec3.dot(dir, viewPlaneNormal);\n\n  return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nfunction getToolStateByViewportId(\n  viewportId: string\n): CINETypes.ToolData | undefined {\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VideoViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  if (!playClipOptions) {\n    playClipOptions = {};\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, {\n      stopDynamicCine: !isDynamicCinePlaying,\n      viewportId: viewport.id,\n    });\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!playClipData.loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, {\n        stopDynamicCine: !isDynamicCinePlaying,\n        viewportId: viewport.id,\n      });\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      try {\n        playClipContext.scroll(delta);\n      } catch (e) {\n        console.warn('Play clip not scrolling', e);\n        _stopClipWithData(playClipData);\n        triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n        return;\n      }\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  if (playClipContext.play) {\n    playClipData.framesPerSecond = playClipContext.play(\n      playClipOptions.framesPerSecond\n    );\n\n    // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n    // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  } else if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement, options = {} as any): void {\n  _stopClip(element, {\n    stopDynamicCine: true,\n    ...options,\n  });\n}\n\nfunction _stopClip(\n  element: HTMLDivElement,\n  options = { stopDynamicCine: true, viewportId: undefined }\n) {\n  const { stopDynamicCine, viewportId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  let toolState;\n  const viewport = enabledElement?.viewport;\n  if (!enabledElement) {\n    if (viewportId) {\n      toolState = getToolStateByViewportId(viewportId);\n    } else {\n      return;\n    }\n  } else {\n    const { viewport } = enabledElement;\n    toolState = getToolState(viewport.element);\n  }\n\n  if (toolState) {\n    _stopClipWithData(toolState);\n  }\n\n  if (viewport instanceof VideoViewport) {\n    viewport.pause();\n  } else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVideoViewportCinePlayContext(\n  viewport: VideoViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return viewport.getNumberOfSlices();\n    },\n    get currentStepIndex(): number {\n      return viewport.getSliceIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n    play(fps?: number): number {\n      if (fps) {\n        // This is a bit of a kludge to correspond to playback rates\n        // for other viewports\n        viewport.setPlaybackRate(fps / 24);\n      }\n      viewport.play();\n      return viewport.getFrameRate();\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  if (viewport instanceof VideoViewport) {\n    return _createVideoViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Adds a contour segmentation annotation to the specified segmentation.\n * @param annotation - The contour segmentation annotation to add.\n */\nexport function addContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (annotation.parentAnnotationUID) {\n    // Don't add it for parent annotations - this happens during interpolation\n    return;\n  }\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'addContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation.representationData.CONTOUR) {\n    segmentation.representationData.CONTOUR = { annotationUIDsMap: new Map() };\n  }\n\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  let annotationsUIDsSet = annotationUIDsMap.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    annotationsUIDsSet = new Set();\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n  }\n\n  annotationUIDsMap.set(\n    segmentIndex,\n    annotationsUIDsSet.add(annotation.annotationUID)\n  );\n}\n","import { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\n/**\n * Check if two contour segmentations are from same segmentId,\n * segmentationRepresentationUID and segmentIndex.\n * @param firstAnnotation - First annotation\n * @param secondAnnotation - Second annotation\n * @returns True if they are from same segmentId, segmentationRepresentationUID\n * and segmentIndex or false otherwise.\n */\nexport default function areSameSegment(\n  firstAnnotation: ContourSegmentationAnnotation,\n  secondAnnotation: ContourSegmentationAnnotation\n) {\n  const { segmentation: firstSegmentation } = firstAnnotation.data;\n  const { segmentation: secondSegmentation } = secondAnnotation.data;\n\n  return (\n    firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n    firstSegmentation.segmentIndex === secondSegmentation.segmentIndex\n  );\n}\n","import { Annotation } from '../../types';\nimport { ContourSegmentationAnnotation } from '../../types/ContourSegmentationAnnotation';\n\nexport default function isContourSegmentationAnnotation(\n  annotation: Annotation\n): annotation is ContourSegmentationAnnotation {\n  return !!(<ContourSegmentationAnnotation>annotation).data?.segmentation;\n}\n","import { state } from '../../stateManagement/segmentation';\nimport { ContourSegmentationAnnotation } from '../../types';\n\n/**\n * Removes a contour segmentation annotation from the given annotation.\n * If the annotation does not have a segmentation data, this method returns\n * quietly.  This can occur for interpolated segmentations that have not yet\n * been converted to real segmentations or other in-process segmentations.\n * @param annotation - The contour segmentation annotation to remove.\n */\nexport function removeContourSegmentationAnnotation(\n  annotation: ContourSegmentationAnnotation\n) {\n  if (!annotation.data.segmentation) {\n    throw new Error(\n      'removeContourSegmentationAnnotation: annotation does not have a segmentation data'\n    );\n  }\n\n  const { segmentationId, segmentIndex } = annotation.data.segmentation;\n  const segmentation = state.getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation?.representationData.CONTOUR || {};\n  const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n\n  if (!annotationsUIDsSet) {\n    return;\n  }\n\n  annotationsUIDsSet.delete(annotation.annotationUID);\n\n  // Delete segmentIndex Set if there is no more annotations\n  if (!annotationsUIDsSet.size) {\n    annotationUIDsMap.delete(segmentIndex);\n  }\n}\n","/**\n * Calculates the perimeter of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param closed - Indicates whether the polyline is closed or not.\n * @returns The perimeter of the polyline.\n */\nfunction calculatePerimeter(polyline: number[][], closed: boolean): number {\n  let perimeter = 0;\n\n  for (let i = 0; i < polyline.length - 1; i++) {\n    const point1 = polyline[i];\n    const point2 = polyline[i + 1];\n    perimeter += Math.sqrt(\n      Math.pow(point2[0] - point1[0], 2) + Math.pow(point2[1] - point1[1], 2)\n    );\n  }\n\n  if (closed) {\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    perimeter += Math.sqrt(\n      Math.pow(lastPoint[0] - firstPoint[0], 2) +\n        Math.pow(lastPoint[1] - firstPoint[1], 2)\n    );\n  }\n\n  return perimeter;\n}\n\nexport default calculatePerimeter;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { ContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds the index in the polyline of the specified handle.  If the handle\n * doesn't match a polyline point, then finds the closest polyline point.\n *\n * Assumes polyline is in the same orientation as the handles.\n *\n * @param annotation - to find the polyline and handles in\n * @param handleIndex - the index of hte handle to look for.\n *     Negative values are treated relative to the end of the handle index.\n * @returns Index in polyline of the closest handle\n *     * 0 for handleIndex 0\n *     * length for `handleIndex===handles length`\n */\nexport default function findHandlePolylineIndex(\n  annotation: ContourAnnotation,\n  handleIndex: number\n): number {\n  const { polyline } = annotation.data.contour;\n  const { points } = annotation.data.handles;\n  const { length } = points;\n  if (handleIndex === length) {\n    return polyline.length;\n  }\n  if (handleIndex < 0) {\n    handleIndex = (handleIndex + length) % length;\n  }\n  if (handleIndex === 0) {\n    return 0;\n  }\n  const handle = points[handleIndex];\n  const index = polyline.findIndex((point) => isEqual(handle, point));\n  if (index !== -1) {\n    return index;\n  }\n  // Need to find nearest\n  let closestDistance = Infinity;\n  return polyline.reduce((closestIndex, point, testIndex) => {\n    const distance = vec3.squaredDistance(point, handle);\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      return testIndex;\n    }\n    return closestIndex;\n  }, -1);\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { ContourAnnotation } from '../../types/ContourAnnotation';\n\n/**\n * Check if two contour segmentation annotations are coplanar.\n *\n * A plane may be represented by a normal and a distance then to know if they\n * are coplanar we need to:\n *   - check if the normals of the two annotations are pointing to the same\n *   direction or to opposite directions (dot product equal to 1 or -1\n *   respectively)\n *   - Get one point from each polyline and project it onto the normal to get\n *   the distance from the origin (0, 0, 0).\n */\nexport default function areCoplanarContours(\n  firstAnnotation: ContourAnnotation,\n  secondAnnotation: ContourAnnotation\n) {\n  const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n  const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n  const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n  const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n\n  if (!parallelPlanes) {\n    return false;\n  }\n\n  const { polyline: firstPolyline } = firstAnnotation.data.contour;\n  const { polyline: secondPolyline } = secondAnnotation.data.contour;\n\n  // Choose one of the normals and calculate the distance of a point from each\n  // polyline along that normal. Both normal cannot be used with absolute dot\n  // product values because one of the view planes may be flipped or one of the\n  // points may be at the same distance but in the opposite direction\n  const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n  const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n\n  return glMatrix.equals(firstDistance, secondDistance);\n}\n","function findNextLink(line, lines, contourPoints) {\n  let index = -1;\n  lines.forEach((cell, i) => {\n    if (index >= 0) {\n      return;\n    }\n\n    if (cell.a == line.b) {\n      index = i;\n    }\n  });\n\n  if (index >= 0) {\n    const nextLine = lines[index];\n    lines.splice(index, 1);\n\n    contourPoints.push(nextLine.b);\n\n    if (contourPoints[0] == nextLine.b) {\n      return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'CLOSED_PLANAR',\n        //type: 'CLOSEDPLANAR_XOR',\n      };\n    }\n\n    return findNextLink(nextLine, lines, contourPoints);\n  }\n\n  return {\n    remainingLines: lines,\n    contourPoints,\n    type: 'OPEN_PLANAR',\n  };\n}\n\n/**\n *\n * @param {*} lines\n */\nexport function findContours(lines) {\n  if (lines.length == 0) {\n    return [];\n  }\n\n  const contourPoints = [];\n\n  const firstCell = lines.shift();\n  contourPoints.push(firstCell.a);\n  contourPoints.push(firstCell.b);\n  const result = findNextLink(firstCell, lines, contourPoints);\n\n  if (result.remainingLines.length == 0) {\n    return [\n      {\n        type: result.type,\n        contourPoints: result.contourPoints,\n      },\n    ];\n  } else {\n    const extraContours = findContours(result.remainingLines);\n    extraContours.push({\n      type: result.type,\n      contourPoints: result.contourPoints,\n    });\n    return extraContours;\n  }\n}\n\nexport function findContoursFromReducedSet(lines) {\n  return findContours(lines);\n}\n\nexport default {\n  findContours,\n  findContoursFromReducedSet,\n};\n","/**\n * Iterate through polyData from vtkjs and merge any points that are the same\n * then update merged point references within lines array\n * @param polyData - vtkPolyData\n * @param bypass - bypass the duplicate point removal\n * @returns the updated polyData\n */\nexport function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n  const points = polyData.getPoints();\n  const lines = polyData.getLines();\n\n  // Todo: This is cloning which is not ideal, we should move to use the PointsArrayManager\n  // that will get merged soon\n  const pointsArray = new Array(points.getNumberOfPoints())\n    .fill(0)\n    .map((_, i) => points.getPoint(i).slice());\n\n  const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n    const cell = lines.getCell(i * 3).slice();\n    return { a: cell[0], b: cell[1] };\n  });\n\n  if (bypass) {\n    return { points: pointsArray, lines: linesArray };\n  }\n\n  const newPoints = [];\n  for (const [i, pt] of pointsArray.entries()) {\n    // Todo: This is an n^2 algorithm - consider using a Map<string,Point3>.\n    // Generates a reasonable amount of garbage, but I think the performance\n    //  of that is better than doing repeated compares across the entire array.\n    const index = newPoints.findIndex(\n      (point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]\n    );\n\n    if (index >= 0) {\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = index;\n        }\n        if (line.b === i) {\n          line.b = index;\n        }\n        return line;\n      });\n    } else {\n      const newIndex = newPoints.length;\n      newPoints.push(pt);\n      linesArray.map((line) => {\n        if (line.a === i) {\n          line.a = newIndex;\n        }\n        if (line.b === i) {\n          line.b = newIndex;\n        }\n        return line;\n      });\n    }\n  }\n\n  const newLines = linesArray.filter((line) => line.a !== line.b);\n\n  return { points: newPoints, lines: newLines };\n}\n\nexport default { getDeduplicatedVTKPolyDataPoints };\n","/**\n * Functions for detecting and dealing with holes within contours.\n * Expected Contour format:\n * {\n *   type,\n *   contourPoints\n * }\n */\n\n/**\n * Checks if point is inside polygon defined by vertices array\n * Code from\n * https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\n * most original version based on:\n * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n * @param {*} point\n * @param {*} vertices\n * @returns\n */\nconst getIsPointInsidePolygon = (point, vertices) => {\n  // Todo: this is a duplicated logic we should merge it with the other one\n  // which is containsPoint in the utilities\n  const x = point[0];\n  const y = point[1];\n\n  let inside = false;\n  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n    const xi = vertices[i][0],\n      yi = vertices[i][1];\n    const xj = vertices[j][0],\n      yj = vertices[j][1];\n\n    const intersect =\n      yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Check if inner contour is completely surrounded by outer contour.\n * @param {*} outerContour\n * @param {*} innerContour\n * @returns\n */\nfunction checkEnclosed(outerContour, innerContour, points) {\n  const vertices = [];\n  outerContour.contourPoints.forEach((point) => {\n    vertices.push([points[point][0], points[point][1]]);\n  });\n\n  let pointsNotEnclosed = 0;\n  innerContour.contourPoints.forEach((point) => {\n    const result = getIsPointInsidePolygon(\n      [points[point][0], points[point][1]],\n      vertices\n    );\n    //console.log(result);\n\n    if (!result) {\n      pointsNotEnclosed++;\n    }\n  });\n\n  return pointsNotEnclosed === 0;\n}\n\n/**\n * Check if contours have holes, if so update contour accordingly\n * @param {*} polyData\n * @param {*} bypass\n */\nexport function processContourHoles(contours, points, useXOR = true) {\n  //console.log(points);\n\n  // Add non-closed planars to contour list\n  const retContours = contours.filter(\n    (contour) => contour.type !== 'CLOSED_PLANAR'\n  );\n\n  // Find closed planar contours\n  const closedContours = contours.filter(\n    (contour) => contour.type === 'CLOSED_PLANAR'\n  );\n\n  // Iterate through each contour in list check for contours that have holes\n  const contourWithHoles = [];\n  let contourWithoutHoles = [];\n  closedContours.forEach((contour, index) => {\n    const holes = [];\n\n    // Check if any other contour is a hole surrounded by current contour\n    closedContours.forEach((hContour, hIndex) => {\n      if (index != hIndex) {\n        // Check if inner loop contour is a hole of outer loop contour\n        if (checkEnclosed(contour, hContour, points)) {\n          holes.push(hIndex);\n        }\n      }\n    });\n\n    // Check if holes were found\n    if (holes.length > 0) {\n      // Note current contour and reference of its holes\n      contourWithHoles.push({\n        contour,\n        holes,\n      });\n    } else {\n      // Note contour index without holes\n      contourWithoutHoles.push(index);\n    }\n  });\n\n  if (useXOR) {\n    // XOR method\n    contourWithHoles.forEach((contourHoleSet) => {\n      // Modify contour with hole to type CLOSEDPLANAR_XOR\n      contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n      retContours.push(contourHoleSet.contour);\n\n      contourHoleSet.holes.forEach((holeIndex) => {\n        // Modify hole type to CLOSEDPLANAR_XOR\n        // and add to contour list to be returned\n        closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n        retContours.push(closedContours[holeIndex]);\n\n        // Remove hole from list of contours without holes\n        contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n          return contourIndex !== holeIndex;\n        });\n      });\n    });\n\n    // Add remaining contours to list (neither hole nor have holes)\n    contourWithoutHoles.forEach((contourIndex) => {\n      retContours.push(closedContours[contourIndex]);\n    });\n  } else {\n    // Keyhole method, not implemented\n  }\n\n  return retContours;\n}\n\nexport default { processContourHoles };\n","import { cache as cornerstoneCache } from '@cornerstonejs/core';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\n\nimport { getDeduplicatedVTKPolyDataPoints } from '../contours';\nimport { findContoursFromReducedSet } from './contourFinder';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\nconst { Labelmap } = SegmentationRepresentations;\n\nfunction generateContourSetsFromLabelmap({ segmentations }) {\n  const { representationData, segments = [0, 1] } = segmentations;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  // Get segmentation volume\n  const vol = cornerstoneCache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const numSlices = vol.dimensions[2];\n\n  // NOTE: Workaround for marching squares not finding closed contours at\n  // boundary of image volume, clear pixels along x-y border of volume\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const pixelsPerSlice = vol.dimensions[0] * vol.dimensions[1];\n\n  for (let z = 0; z < numSlices; z++) {\n    for (let y = 0; y < vol.dimensions[1]; y++) {\n      const index = y * vol.dimensions[0] + z * pixelsPerSlice;\n      segData[index] = 0;\n      segData[index + vol.dimensions[0] - 1] = 0;\n    }\n  }\n\n  // end workaround\n  //\n  //\n  const ContourSets = [];\n\n  const { FrameOfReferenceUID } = vol.metadata;\n  // Iterate through all segments in current segmentation set\n  const numSegments = segments.length;\n  for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n    const segment = segments[segIndex];\n\n    // Skip empty segments\n    if (!segment) {\n      continue;\n    }\n\n    const sliceContours = [];\n    const scalars = vtkDataArray.newInstance({\n      name: 'Scalars',\n      numberOfComponents: 1,\n      size: pixelsPerSlice * numSlices,\n      dataType: 'Uint8Array',\n    });\n    const { containedSegmentIndices } = segment;\n    for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n      // Check if the slice is empty before running marching cube\n      if (\n        isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex)\n      ) {\n        continue;\n      }\n      const frameStart = sliceIndex * pixelsPerSlice;\n\n      try {\n        // Modify segData for this specific segment directly\n        for (let i = 0; i < pixelsPerSlice; i++) {\n          const value = segData[i + frameStart];\n          if (value === segIndex || containedSegmentIndices?.has(value)) {\n            (scalars as any).setValue(i + frameStart, 1);\n          } else {\n            (scalars as any).setValue(i, 0);\n          }\n        }\n\n        const mSquares = vtkImageMarchingSquares.newInstance({\n          slice: sliceIndex,\n        });\n\n        // filter out the scalar data so that only it has background and\n        // the current segment index\n        const imageDataCopy = vtkImageData.newInstance();\n\n        imageDataCopy.shallowCopy(vol.imageData);\n        imageDataCopy.getPointData().setScalars(scalars);\n\n        // Connect pipeline\n        mSquares.setInputData(imageDataCopy);\n        const cValues = [1];\n        mSquares.setContourValues(cValues);\n        mSquares.setMergePoints(false);\n\n        // Perform marching squares\n        const msOutput = mSquares.getOutputData();\n\n        // Clean up output from marching squares\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n          const contours = findContoursFromReducedSet(reducedSet.lines);\n\n          sliceContours.push({\n            contours,\n            polyData: reducedSet,\n            FrameNumber: sliceIndex + 1,\n            sliceIndex,\n            FrameOfReferenceUID,\n          });\n        }\n      } catch (e) {\n        console.warn(sliceIndex);\n        console.warn(e);\n      }\n    }\n\n    const metadata = {\n      FrameOfReferenceUID,\n    };\n\n    const ContourSet = {\n      label: segment.label,\n      color: segment.color,\n      metadata,\n      sliceContours,\n    };\n\n    ContourSets.push(ContourSet);\n  }\n\n  return ContourSets;\n}\n\nfunction isSliceEmptyForSegment(sliceIndex, segData, pixelsPerSlice, segIndex) {\n  const startIdx = sliceIndex * pixelsPerSlice;\n  const endIdx = startIdx + pixelsPerSlice;\n\n  for (let i = startIdx; i < endIdx; i++) {\n    if (segData[i] === segIndex) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { generateContourSetsFromLabelmap };\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\n\nfunction validateAnnotation(annotation) {\n  if (!annotation?.data) {\n    throw new Error('Tool data is empty');\n  }\n\n  if (!annotation.metadata || annotation.metadata.referenceImageId) {\n    throw new Error('Tool data is not associated with any imageId');\n  }\n}\n\nclass AnnotationToPointData {\n  static TOOL_NAMES: Record<string, any> = {};\n\n  constructor() {\n    // empty\n  }\n\n  static convert(annotation, index, metadataProvider) {\n    validateAnnotation(annotation);\n\n    const { toolName } = annotation.metadata;\n    const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n\n    if (!toolClass) {\n      throw new Error(\n        `Unknown tool type: ${toolName}, cannot convert to RTSSReport`\n      );\n    }\n\n    // Each toolData should become a list of contours, ContourSequence\n    // contains a list of contours with their pointData, their geometry\n    // type and their length.\n    const ContourSequence = toolClass.getContourSequence(\n      annotation,\n      metadataProvider\n    );\n\n    // Todo: random rgb color for now, options should be passed in\n    const color = [\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n      Math.floor(Math.random() * 255),\n    ];\n\n    return {\n      ReferencedROINumber: index + 1,\n      ROIDisplayColor: color,\n      ContourSequence,\n    };\n  }\n\n  static register(toolClass) {\n    AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n  }\n}\n\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\n\nexport default AnnotationToPointData;\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation, ContourAnnotation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\n\n/**\n * Get child polylines data in world space for contour annotations that represent the holes\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines (holes) in world space\n */\nexport default function getContourHolesDataWorld(\n  annotation: Annotation\n): Types.Point3[][] {\n  const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n\n  return childAnnotationUIDs.map(\n    (uid) => (getAnnotation(uid) as ContourAnnotation).data.contour.polyline\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types';\nimport getContourHolesDataWorld from './getContourHolesDataWorld';\n\n/**\n * Get the polylines for the child annotations (holes)\n * @param annotation - Annotation\n * @param viewport - Viewport used to convert the points from world to canvas space\n * @returns An array that contains all child polylines\n */\nexport default function getContourHolesDataCanvas(\n  annotation: Annotation,\n  viewport: Types.IViewport\n): Types.Point2[][] {\n  const worldHoleContours = getContourHolesDataWorld(annotation);\n  const canvasHoleContours = [];\n\n  worldHoleContours.forEach((worldHoleContour) => {\n    const numPoints = worldHoleContour.length;\n\n    // Pre-allocated arrays are 3-4x faster than multiple \"push()\" calls\n    const canvasHoleContour: Types.Point2[] = new Array(numPoints);\n\n    // Using FOR loop instead of map() for better performance when processing large arrays\n    for (let i = 0; i < numPoints; i++) {\n      canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n    }\n\n    canvasHoleContours.push(canvasHoleContour);\n  });\n\n  return canvasHoleContours;\n}\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nimport type { AcceptInterpolationSelector } from '../../../types/InterpolationTypes';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\n\n/**\n * Accepts interpolated annotations, marking them as autoGenerated false.\n *\n * @param annotationGroupSelector - viewport or FOR to select annotations on\n * @param selector - nested selection criteria\n */\nexport default function acceptAutogeneratedInterpolations(\n  annotationGroupSelector: AnnotationGroupSelector,\n  selector: AcceptInterpolationSelector\n) {\n  InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport type { ContourAnnotation } from '../../types';\nimport type { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport {\n  getParentAnnotation,\n  invalidateAnnotation,\n} from '../../stateManagement';\n\n/**\n * Update the contour polyline data\n * @param annotation - Contour annotation\n * @param viewport - Viewport\n * @param polylineData - Polyline data (points, winding direction and closed)\n * @param transforms - Methods to convert points to/from canvas and world spaces\n * @param options - Options\n *   - decimate: allow to set some parameters to decimate the polyline reducing\n *   the amount of points stored which also affects how fast it will draw the\n *   annotation in a viewport, compute the winding direction, append/remove\n *   contours and create holes. A higher `epsilon` value results in a polyline\n *   with less points.\n */\nexport default function updateContourPolyline(\n  annotation: ContourAnnotation,\n  polylineData: {\n    points: Types.Point2[];\n    closed?: boolean;\n    targetWindingDirection?: ContourWindingDirection;\n  },\n  transforms: {\n    canvasToWorld: (point: Types.Point2) => Types.Point3;\n    worldToCanvas: (point: Types.Point3) => Types.Point2;\n  },\n  options?: {\n    decimate?: {\n      enabled?: boolean;\n      epsilon?: number;\n    };\n  }\n) {\n  const { canvasToWorld, worldToCanvas } = transforms;\n  const { data } = annotation;\n  const { targetWindingDirection } = polylineData;\n  let { points: polyline } = polylineData;\n\n  // Decimate the polyline to reduce tha amount of points\n  if (options?.decimate?.enabled) {\n    polyline = math.polyline.decimate(\n      polylineData.points,\n      options?.decimate?.epsilon\n    );\n  }\n\n  let { closed } = polylineData;\n  const numPoints = polyline.length;\n  const polylineWorldPoints = new Array(numPoints);\n  const currentPolylineWindingDirection =\n    math.polyline.getWindingDirection(polyline);\n  const parentAnnotation = getParentAnnotation(annotation) as ContourAnnotation;\n\n  if (closed === undefined) {\n    let currentClosedState = false;\n\n    // With two points it is just a line and do not make sense to consider it closed\n    if (polyline.length > 3) {\n      const lastToFirstDist = math.point.distanceToPointSquared(\n        polyline[0],\n        polyline[numPoints - 1]\n      );\n\n      currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n    }\n\n    closed = currentClosedState;\n  }\n\n  // It must be in the opposite direction if it is a child annotation (hole)\n  let windingDirection = parentAnnotation\n    ? parentAnnotation.data.contour.windingDirection * -1\n    : targetWindingDirection;\n\n  if (windingDirection === undefined) {\n    windingDirection = currentPolylineWindingDirection;\n  }\n\n  if (windingDirection !== currentPolylineWindingDirection) {\n    polyline.reverse();\n  }\n\n  const handlePoints = data.handles.points.map((p) => worldToCanvas(p));\n\n  if (handlePoints.length > 2) {\n    const currentHandlesWindingDirection =\n      math.polyline.getWindingDirection(handlePoints);\n\n    if (currentHandlesWindingDirection !== windingDirection) {\n      data.handles.points.reverse();\n    }\n  }\n\n  for (let i = 0; i < numPoints; i++) {\n    polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n  }\n\n  data.contour.polyline = polylineWorldPoints;\n  data.contour.closed = closed;\n  data.contour.windingDirection = windingDirection;\n\n  invalidateAnnotation(annotation);\n}\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const [dataInTime, ijkCoords] = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return [dataInTime, ijkCoords];\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n  const ijkCoords = [];\n\n  const dimensions = segmentationVolume.dimensions;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      ijkCoords.push([\n        i % dimensions[0],\n        Math.floor((i / dimensions[0]) % dimensions[1]),\n        Math.floor(i / (dimensions[0] * dimensions[1])),\n      ]);\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return [values, ijkCoords];\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({\n    pointLPS: segPointLPS,\n    value: segValue,\n    pointIJK: segPointIJK,\n  }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    ijkCoords.push(segPointIJK);\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return [values, ijkCoords];\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { Enums, utilities } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\nconst SUPPORTED_REGION_DATA_TYPES = [\n  1, // Tissue\n];\n\nconst SUPPORTED_LENGTH_VARIANT = [\n  '3,3', // x: cm  &  y:cm\n];\n\nconst SUPPORTED_PROBE_VARIANT = [\n  '4,3', // x: seconds  &  y : cm\n];\n\nconst UNIT_MAPPING = {\n  0: 'px',\n  1: 'percent',\n  2: 'dB',\n  3: 'cm',\n  4: 'seconds',\n  5: 'hertz',\n  6: 'dB/seconds',\n  7: 'cm/sec',\n  8: 'cm\\xb2',\n  9: 'cm\\xb2/s',\n  0xc: 'degrees',\n};\n\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\n/**\n * Extracts the calibrated length units, area units, and the scale\n * for converting from internal spacing to image spacing.\n *\n * @param handles - to detect if spacing information is different between points\n * @param image - to extract the calibration from\n * @returns Object containing the units, area units, and scale\n */\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n  const { calibration, hasPixelSpacing } = image;\n  let units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  let areaUnits = units + SQUARE;\n  let scale = 1;\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, areaUnits, scale };\n  }\n\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    let imageIndex1, imageIndex2;\n    if (Array.isArray(handles) && handles.length === 2) {\n      [imageIndex1, imageIndex2] = handles;\n    } else if (typeof handles === 'function') {\n      const points = handles();\n      imageIndex1 = points[0];\n      imageIndex2 = points[1];\n    }\n\n    let regions = calibration.sequenceOfUltrasoundRegions.filter(\n      (region) =>\n        imageIndex1[0] >= region.regionLocationMinX0 &&\n        imageIndex1[0] <= region.regionLocationMaxX1 &&\n        imageIndex1[1] >= region.regionLocationMinY0 &&\n        imageIndex1[1] <= region.regionLocationMaxY1 &&\n        imageIndex2[0] >= region.regionLocationMinX0 &&\n        imageIndex2[0] <= region.regionLocationMaxX1 &&\n        imageIndex2[1] >= region.regionLocationMinY0 &&\n        imageIndex2[1] <= region.regionLocationMaxY1\n    );\n\n    // If we are not in a region at all we should show the underlying calibration\n    // which might be the mm spacing for the image\n    if (!regions?.length) {\n      return { units, areaUnits, scale };\n    }\n\n    // if we are in a region then it is the question of whether we support it\n    // or not. If we do not support it we should show px\n\n    regions = regions.filter(\n      (region) =>\n        SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n        SUPPORTED_LENGTH_VARIANT.includes(\n          `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n        )\n    );\n\n    if (!regions.length) {\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n\n    // Todo: expand on this logic\n    const region = regions[0];\n\n    const physicalDeltaX = Math.abs(region.physicalDeltaX);\n    const physicalDeltaY = Math.abs(region.physicalDeltaY);\n\n    // if we are in a supported region then we should check if the\n    // physicalDeltaX and physicalDeltaY are the same. If they are not\n    // then we should show px again, but if they are the same then we should\n    // show the units\n    const isSamePhysicalDelta = utilities.isEqual(\n      physicalDeltaX,\n      physicalDeltaY,\n      EPS\n    );\n\n    if (isSamePhysicalDelta) {\n      // 1 to 1 aspect ratio, we use just one of them\n      scale = 1 / physicalDeltaX;\n      calibrationType = 'US Region';\n      units = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n      areaUnits = units + SQUARE;\n    } else {\n      // here we are showing at the aspect ratio of the physical delta\n      // if they are not the same, then we should show px, but the correct solution\n      // is to grab each point separately and scale them individually\n      // Todo: implement this\n      return { units: PIXEL_UNITS, areaUnits: PIXEL_UNITS + SQUARE, scale };\n    }\n  } else if (calibration.scale) {\n    scale = calibration.scale;\n  }\n\n  // everything except REGION/Uncalibrated\n  const types = [\n    CalibrationTypes.ERMF,\n    CalibrationTypes.USER,\n    CalibrationTypes.ERROR,\n    CalibrationTypes.PROJECTION,\n  ];\n\n  if (types.includes(calibration?.type)) {\n    calibrationType = calibration.type;\n  }\n\n  return {\n    units: units + (calibrationType ? ` ${calibrationType}` : ''),\n    areaUnits: areaUnits + (calibrationType ? ` ${calibrationType}` : ''),\n    scale,\n  };\n};\n\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n  const [imageIndex] = handles;\n  const { calibration } = image;\n  let units = ['raw'];\n  let values = [null];\n  let calibrationType = '';\n\n  if (\n    !calibration ||\n    (!calibration.type && !calibration.sequenceOfUltrasoundRegions)\n  ) {\n    return { units, values };\n    // Todo: add support for other scenarios\n  }\n\n  if (calibration.sequenceOfUltrasoundRegions) {\n    // for Probe tool\n    const supportedRegionsMetadata =\n      calibration.sequenceOfUltrasoundRegions.filter(\n        (region) =>\n          SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n          SUPPORTED_PROBE_VARIANT.includes(\n            `${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`\n          )\n      );\n\n    if (!supportedRegionsMetadata?.length) {\n      return { units, values };\n    }\n\n    const region = supportedRegionsMetadata.find(\n      (region) =>\n        imageIndex[0] >= region.regionLocationMinX0 &&\n        imageIndex[0] <= region.regionLocationMaxX1 &&\n        imageIndex[1] >= region.regionLocationMinY0 &&\n        imageIndex[1] <= region.regionLocationMaxY1\n    );\n\n    if (!region) {\n      return { units, values };\n    }\n\n    // Todo: I think this is a ok assumption for now that if the referencePixelX0 and referencePixelY0\n    // are not defined, then we can assume 0 for them\n    const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n    const { physicalDeltaX, physicalDeltaY } = region;\n\n    const yValue =\n      (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n      physicalDeltaY;\n\n    const xValue =\n      (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n      physicalDeltaX;\n\n    calibrationType = 'US Region';\n    values = [xValue, yValue];\n    units = [\n      UNIT_MAPPING[region.physicalUnitsXDirection],\n      UNIT_MAPPING[region.physicalUnitsYDirection],\n    ];\n  }\n\n  return {\n    units,\n    values,\n    calibrationType,\n  };\n};\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n  getCalibratedProbeUnitsAndValue,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nfunction getSphereBoundsInfo(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n  topLeftWorld: Types.Point3;\n  bottomRightWorld: Types.Point3;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  if (!viewport) {\n    throw new Error(\n      'viewport is required in order to calculate the sphere bounds'\n    );\n  }\n\n  const { boundsIJK, topLeftWorld, bottomRightWorld } =\n    _computeBoundsIJKWithCamera(\n      imageData,\n      viewport,\n      circlePoints,\n      centerWorld,\n      radiusWorld\n    );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n    topLeftWorld: topLeftWorld as Types.Point3,\n    bottomRightWorld: bottomRightWorld as Types.Point3,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // In order to correctly come up with the boundsIJK, we need to consider\n  // all the points IJK to get the bounds, since the viewport might have\n  // rotate views and we cannot guarantee that the topLeft and bottomRight in the\n  // world, are the ones that will define the bounds in IJK\n  const topLeftIJK = transformWorldToIndex(\n    imageData,\n    topLeftWorld as Types.Point3\n  );\n  const bottomRightIJK = transformWorldToIndex(\n    imageData,\n    bottomRightWorld as Types.Point3\n  );\n\n  const pointsIJK = circlePoints.map((p) =>\n    transformWorldToIndex(imageData, p)\n  );\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShapeIJK(\n    [topLeftIJK, bottomRightIJK, ...pointsIJK],\n    dimensions\n  );\n\n  return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\n\nexport { getSphereBoundsInfo };\n","import type { Annotation } from '../types';\nimport type { Types } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from './getViewportsForAnnotation';\n\n/**\n * Finds a matching viewport in terms of the orientation of the annotation data\n * and the frame of reference.  This doesn't mean the annotation IS being displayed\n * in the viewport, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - to find a viewport that it could display in\n * @returns The viewport to display in\n */\nexport default function getViewportForAnnotation(\n  annotation: Annotation\n): Types.IStackViewport | Types.IVolumeViewport | undefined {\n  const viewports = getViewportsForAnnotation(annotation);\n\n  return viewports.length ? viewports[0] : undefined;\n}\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Check if two axis-aligned bounding boxes intersect\n * @param aabb1 - First AABB\n * @param aabb2 - Second AABB\n * @returns True if they intersect or false otherwise\n */\nexport default function intersectAABB(\n  aabb1: Types.AABB2,\n  aabb2: Types.AABB2\n): boolean {\n  return (\n    aabb1.minX <= aabb2.maxX &&\n    aabb1.maxX >= aabb2.minX &&\n    aabb1.minY <= aabb2.maxY &&\n    aabb1.maxY >= aabb2.minY\n  );\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to an AABB using 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box\n * @param point - 2D point\n * @returns The closest distance between the 2D point and the AABB\n */\nexport default function distanceToPointSquared(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  const aabbWidth = aabb.maxX - aabb.minX;\n  const aabbHeight = aabb.maxY - aabb.minY;\n  const aabbSize = [aabbWidth, aabbHeight];\n  const aabbCenter: Types.Point2 = [\n    aabb.minX + aabbWidth / 2,\n    aabb.minY + aabbHeight / 2,\n  ];\n\n  // Translates the point as the center of the AABB is the new origin.\n  // THe point is also mirroed to the first quadrant to simplify the math.\n  const translatedPoint = [\n    Math.abs(point[0] - aabbCenter[0]),\n    Math.abs(point[1] - aabbCenter[1]),\n  ];\n\n  // Calculate the distance from the point to the vertical and horizontal AABB borders\n  const dx = translatedPoint[0] - aabbSize[0] * 0.5;\n  const dy = translatedPoint[1] - aabbSize[1] * 0.5;\n\n  // dx >  0 && dy >  0: diagonal line connecting the point to AABB's corner\n  // dx >  0 && dy <= 0: a line parallel to x-axis connecting the point to AABB's right side\n  // dx <= 0 && dy >  0: a line parallel to y-axis connecting the point to AABB's top side\n  // dx <= 0 && dy <= 0: the point is inside the AABB\n  if (dx > 0 && dy > 0) {\n    return dx * dx + dy * dy;\n  }\n\n  const dist = Math.max(dx, 0) + Math.max(dy, 0);\n\n  return dist * dist;\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\n/**\n * Calculates the squared distance of a point to an AABB using\n * 2D Box SDF (Signed Distance Field)\n *\n * The SDF of a Box\n * https://www.youtube.com/watch?v=62-pRVZuS5c\n *\n * @param aabb - Axis-aligned bound box (minX, minY, maxX and maxY)\n * @param point - 2D point\n * @returns The squared distance between the 2D point and the AABB\n */\nexport default function distanceToPoint(\n  aabb: Types.AABB2,\n  point: Types.Point2\n): number {\n  return Math.sqrt(distanceToPointSquared(aabb, point));\n}\n","import { NamedStatistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  /**\n   * Gets the statistics as both an array of values, as well as the named values.\n   */\n  static getStatistics: () => NamedStatistics;\n}\n\nexport default Calculator;\n","import { utilities } from '@cornerstonejs/core';\nimport { NamedStatistics } from '../../../types';\nimport Calculator from './Calculator';\n\nconst { PointsManager } = utilities;\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = [-Infinity];\n  private static min = [Infinity];\n  private static sum = [0];\n  private static count = 0;\n\n  // private static sumSquares = [0];\n  // Values for Welford's algorithm\n  private static runMean = [0];\n  private static m2 = [0];\n\n  // Collect the points to be returned\n  private static pointsInShape = PointsManager.create3(1024);\n\n  public static statsInit(options: { noPointsCollection: boolean }) {\n    if (options.noPointsCollection) {\n      BasicStatsCalculator.pointsInShape = null;\n    }\n  }\n\n  /**\n   * This callback is used when we verify if the point is in the annotation drawn\n   * so we can get every point in the shape to calculate the statistics\n   */\n  static statsCallback = ({ value: newValue, pointLPS = null }): void => {\n    if (\n      Array.isArray(newValue) &&\n      newValue.length > 1 &&\n      this.max.length === 1\n    ) {\n      this.max.push(this.max[0], this.max[0]);\n      this.min.push(this.min[0], this.min[0]);\n      this.sum.push(this.sum[0], this.sum[0]);\n      this.runMean.push(0, 0);\n      // this.sumSquares.push(this.sumSquares[0], this.sumSquares[0]);\n      this.m2.push(this.m2[0], this.m2[0]);\n    }\n\n    this.pointsInShape?.push(pointLPS);\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n\n    this.count += 1;\n    this.max.map((it, idx) => {\n      const value = newArray[idx];\n\n      const delta = value - this.runMean[idx];\n      this.sum[idx] += value;\n      this.runMean[idx] += delta / this.count;\n      const delta2 = value - this.runMean[idx];\n      this.m2[idx] += delta * delta2;\n      // this.sumSquares[idx] += value * value;\n\n      this.min[idx] = Math.min(this.min[idx], value);\n      this.max[idx] = Math.max(it, value);\n    });\n  };\n\n  /**\n   * Basic function that calculates statistics for a given array of points.\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * array : An array of hte above values, in order.\n   */\n\n  static getStatistics = (options?: { unit: string }): NamedStatistics => {\n    const mean = this.sum.map((sum) => sum / this.count);\n    const stdDev = this.m2.map((squaredDiffSum) =>\n      Math.sqrt(squaredDiffSum / this.count)\n    );\n    // const stdDevWithSumSquare = this.sumSquares.map((it, idx) =>\n    //   Math.sqrt(this.sumSquares[idx] / this.count - mean[idx] ** 2)\n    // );\n\n    const unit = options?.unit || null;\n\n    const named: NamedStatistics = {\n      max: {\n        name: 'max',\n        label: 'Max Pixel',\n        value: singleArrayAsNumber(this.max),\n        unit,\n      },\n      min: {\n        name: 'min',\n        label: 'Min Pixel',\n        value: singleArrayAsNumber(this.min),\n        unit,\n      },\n      mean: {\n        name: 'mean',\n        label: 'Mean Pixel',\n        value: singleArrayAsNumber(mean),\n        unit,\n      },\n      stdDev: {\n        name: 'stdDev',\n        label: 'Standard Deviation',\n        value: singleArrayAsNumber(stdDev),\n        unit,\n      },\n      // stdDevWithSumSquare: {\n      //   name: 'stdDevWithSumSquare',\n      //   value: singleArrayAsNumber(stdDevWithSumSquare),\n      //   unit,\n      // },\n      count: {\n        name: 'count',\n        label: 'Pixel Count',\n        value: this.count,\n        unit: null,\n      },\n      pointsInShape: this.pointsInShape,\n      array: [],\n    };\n    named.array.push(\n      named.max,\n      named.mean,\n      named.stdDev,\n      // Use the stdDev twice to preserve old ordering - this is updated to be\n      // correct value with Welford's algorithm now.\n      named.stdDev,\n      named.count\n    );\n\n    this.max = [-Infinity];\n    this.min = [Infinity];\n    this.sum = [0];\n    // this.sumSquares = [0];\n    this.m2 = [0];\n    this.runMean = [0];\n    this.count = 0;\n    this.pointsInShape = PointsManager.create3(1024);\n\n    return named;\n  };\n}\n\nfunction singleArrayAsNumber(val: number[]) {\n  return val.length === 1 ? val[0] : val;\n}\n","import type { Types } from '@cornerstonejs/core';\ninterface Inverts {\n  invXRadiusSq?: number;\n  invYRadiusSq?: number;\n  invZRadiusSq?: number;\n  fast?: boolean;\n  /**\n   * If you call the pointInEllipse.precalculateInverts first, then you\n   * can call precalculated directly instead of having the extra time for\n   * the if conditions.\n   */\n  precalculated?: (pointLPS: Types.Point3) => boolean;\n}\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @param inverts - An object to cache the inverted radius squared values, if you\n * are testing multiple points against the same ellipse then it is recommended to\n * pass in the same object to cache the values. However, there is a simpler way\n * to do this by passing in the fast flag as true, then on the first iteration\n * the values will be cached and on subsequent iterations the cached values will\n * be used.\n *\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse,\n  pointLPS,\n  inverts: Inverts = {}\n) {\n  if (!inverts.precalculated) {\n    precalculatePointInEllipse(ellipse, inverts);\n  }\n  return inverts.precalculated(pointLPS);\n}\n\n/**\n * This will perform some precalculations to make things faster.\n * Ideally, use the 'precalculated' function inside inverts to call the\n * test function.  This minimizes re-reading of variables and only needs the\n * LPS passed each time.\n * That is:\n *\n * ```\n *    const inverts = precalculatePointInEllipse(ellipse);\n *    if( inverts.precalculated(pointLPS) ) ...\n * ```\n */\nconst precalculatePointInEllipse = (ellipse, inverts: Inverts = {}) => {\n  const { xRadius, yRadius, zRadius } = ellipse;\n\n  // This will run only once since we are caching the values in the same\n  // object that is passed in.\n  if (\n    inverts.invXRadiusSq === undefined ||\n    inverts.invYRadiusSq === undefined ||\n    inverts.invZRadiusSq === undefined\n  ) {\n    inverts.invXRadiusSq = xRadius !== 0 ? 1 / xRadius ** 2 : 0;\n    inverts.invYRadiusSq = yRadius !== 0 ? 1 / yRadius ** 2 : 0;\n    inverts.invZRadiusSq = zRadius !== 0 ? 1 / zRadius ** 2 : 0;\n  }\n\n  const { invXRadiusSq, invYRadiusSq, invZRadiusSq } = inverts;\n  const { center } = ellipse;\n  const [centerL, centerP, centerS] = center;\n\n  inverts.precalculated = (pointLPS) => {\n    // Calculate the sum of normalized squared distances\n    const dx = pointLPS[0] - centerL;\n    let inside = dx * dx * invXRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dy = pointLPS[1] - centerP;\n    inside += dy * dy * invYRadiusSq;\n    if (inside > 1) {\n      return false;\n    }\n\n    const dz = pointLPS[2] - centerS;\n    inside += dz * dz * invZRadiusSq;\n\n    // Check if the point is inside the ellipse\n    return inside <= 1;\n  };\n\n  return inverts;\n};\n\nexport { precalculatePointInEllipse };\n","import type { Types } from '@cornerstonejs/core';\n\nexport type CanvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: CanvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as math from '../';\n\n/**\n * Calculate the closest point and the squared distance between a reference point and a line segment.\n *\n * It projects the reference point onto the line segment but it shall be bounded by the\n * start/end points since this is a line segment and not a line which could be extended.\n *\n * @param lineStart - Start point of the line segment\n * @param lineEnd - End point of the line segment\n * @param point - Reference point\n * @returns Closest point and the squared distance between a `point` and a line\n *   segment defined by `lineStart` and `lineEnd` points\n */\nexport default function distanceToPointSquaredInfo(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): {\n  point: Types.Point2;\n  distanceSquared: number;\n} {\n  let closestPoint: Types.Point2;\n  const distanceSquared = math.point.distanceToPointSquared(lineStart, lineEnd);\n\n  // Check if lineStart equal to the lineEnd which means the closest point\n  // is any of these two points\n  if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n    closestPoint = lineStart;\n  }\n\n  if (!closestPoint) {\n    const dotProduct =\n      ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n      distanceSquared;\n\n    if (dotProduct < 0) {\n      closestPoint = lineStart;\n    } else if (dotProduct > 1) {\n      closestPoint = lineEnd;\n    } else {\n      closestPoint = [\n        lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n      ];\n    }\n  }\n\n  return {\n    point: [...closestPoint],\n    distanceSquared: math.point.distanceToPointSquared(point, closestPoint),\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\n\n/**\n * Calculates the distance-squared of a point to a line segment\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nconst ORIENTATION_TOLERANCE = 1e-2;\n\n/**\n * Test if a point is on a line segment\n * @param lineStart - Line segment start point\n * @param lineEnd - Line segment end point\n * @param point - Point to test\n * @returns True if the point lies on the line segment or false otherwise\n */\nexport default function isPointOnLineSegment(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): boolean {\n  // The code below runs ~4x faster than calling `line.distanceToPointSquared()` (155 vs 598 ms)\n\n  // No Math.min/max call for better performance when testing thousands of points\n  const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n  const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n  const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n\n  // Checks if the point lies inside the AABB\n  const aabbContainsPoint =\n    point[0] >= minX - ORIENTATION_TOLERANCE &&\n    point[0] <= maxX + ORIENTATION_TOLERANCE &&\n    point[1] >= minY - ORIENTATION_TOLERANCE &&\n    point[1] <= maxY + ORIENTATION_TOLERANCE;\n\n  if (!aabbContainsPoint) {\n    return false;\n  }\n\n  // Now that we know the point is inside the AABB we check if it lies on the line segment\n  const orientation =\n    (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n    (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n  const absOrientation = orientation >= 0 ? orientation : -orientation;\n\n  // The orientation must be zero for points that lies on the same line\n  return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport distanceToPointSquared from './distanceToPointSquared';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Get a mirrored point along the line created by two points where one of them\n * is the static (\"anchor\") point and the other one is the point to be mirroed.\n * @param mirrorPoint - 2D Point to be mirroed\n * @param staticPoint - Static 2D point\n * @returns Mirroed 2D point\n */\nexport default function mirror(\n  mirrorPoint: Types.Point2,\n  staticPoint: Types.Point2\n): Types.Point2 {\n  const [x1, y1] = mirrorPoint;\n  const [x2, y2] = staticPoint;\n\n  const newX = 2 * x2 - x1;\n  const newY = 2 * y2 - y1;\n\n  return [newX, newY];\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\n\n/**\n * Checks if a polyline contains a set of points.\n *\n * @param polyline - Polyline points (2D)\n * @param points - 2D points to verify\n * @returns True if all points are inside the polyline or false otherwise\n */\nexport default function containsPoints(\n  polyline: Types.Point2[],\n  points: Types.Point2[]\n): boolean {\n  for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n    if (!containsPoint(polyline, points[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function getArea(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the area with signal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1900s\n *\n * This functions has a runtime very close to `getArea` and it is recommended to\n * be called only if you need the area signal (eg: calculate polygon normal or\n * winding direction). If you do not need the area signal you should always call\n * `getArea`.\n *\n * @param polyline - Polyline points (2D)\n * @returns Area of the polyline (with signal)\n */\nexport default function getSignedArea(polyline: Types.Point2[]): number {\n  if (polyline.length < 3) {\n    return 0;\n  }\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n  let area = 0;\n\n  // Takes three points (reference point and two other points from each line\n  // segment) and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n\n    // Cross product between vectors \"a\" and \"b\" which returns (0, 0, crossProd)\n    // for 2D vectors.\n    area += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  area *= 0.5;\n\n  return area;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the winding direction (CW or CCW) of a polyline\n * @param polyline - Polyline (2D)\n * @returns 1 for CW or -1 for CCW polylines\n */\nexport default function getWindingDirection(polyline: Types.Point2[]): number {\n  const signedArea = getSignedArea(polyline);\n\n  // Return 1 or -1 which is also possible to convert into ContourOrientation\n  return signedArea >= 0 ? 1 : -1;\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nfunction _getAreaVector(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = vec3.create();\n\n  // Reference point can be any point on the same plane\n  const refPoint = polyline[0];\n\n  // Takes three points, reference point and two other points from each line\n  // segment, and calculate the area with cross product. The magnitude of the\n  // vector returned by a cross product is equal to the area of the parallelogram\n  // that the vectors span which is two times the area of the triangle.\n  //\n  // Not calling vec3 mathods makes the function run much faster since polylines\n  // may have thousands of points when using freehand ROI tool and that would\n  // increase considerably the number of function calls.\n  for (let i = 0, len = polyline.length; i < len; i++) {\n    const p1 = polyline[i];\n    // Using ternary instead of % (mod) operator to make it faster\n    const p2Index = i === len - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    const aX = p1[0] - refPoint[0];\n    const aY = p1[1] - refPoint[1];\n    const aZ = p1[2] - refPoint[2];\n    const bX = p2[0] - refPoint[0];\n    const bY = p2[1] - refPoint[1];\n    const bZ = p2[2] - refPoint[2];\n\n    // Cross product without calling vec3.cross() for better performance\n    vecArea[0] += aY * bZ - aZ * bY;\n    vecArea[1] += aZ * bX - aX * bZ;\n    vecArea[2] += aX * bY - aY * bX;\n  }\n\n  // Divide by two because cross product returns two times the area for each triangle\n  vec3.scale(vecArea, vecArea, 0.5);\n\n  // The magnitude of the vector is the area of the polyline\n  return <Types.Point3>vecArea;\n}\n\n/**\n * Calculate the normal of a 3D planar polyline\n * @param polyline - Planar polyline in 3D space\n * @returns Normal of the 3D planar polyline\n */\nexport default function getNormal3(polyline: Types.Point3[]): Types.Point3 {\n  const vecArea = _getAreaVector(polyline);\n\n  return vec3.normalize(vecArea, vecArea) as Types.Point3;\n}\n","import { Types } from '@cornerstonejs/core';\nimport getSignedArea from './getSignedArea';\n\n/**\n * Calculate the normal of a 2D polyline\n * https://www.youtube.com/watch?v=GpsKrAipXm8&t=1982s\n *\n * @param polyline - Planar polyline in 2D space\n * @returns Normal of the 2D planar polyline\n */\nexport default function getNormal2(polyline: Types.Point2[]): Types.Point3 {\n  const area = getSignedArea(polyline);\n\n  // The normal of a 2D polyline is (0, 0, 1) or (0, 0, -1) depending if it\n  // is CW or CCW polyline\n  return [0, 0, area / Math.abs(area)] as Types.Point3;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\"\n// namespace.\n//\n// TODO: there is a similar function in math.lineSegment.intersectLine but we\n// need to investigate why it is 6x slower than this one when thousands of\n// intersections are calculated. Also that one may return [NaN, NaN] for\n// collinear points.\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an\n * orientation algorithm.\n *\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n *\n * @param p1 - Start point of line segment 1\n * @param q1 - End point of line segment 1\n * @param p2 - Start point of line segment 2\n * @param q2 - End point of line segment 2\n * @returns True if the line segments intersect or false otherwise\n */\nexport default function areLineSegmentsIntersecting(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  // Line 1 AABB\n  const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n  const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n  const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n  const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n\n  // Line 2 AABB\n  const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n  const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n  const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n  const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n\n  // If AABBs do not intersect it is impossible for the lines to intersect.\n  // Checking AABB before doing any math makes it run ~12% faster.\n  if (\n    line1MinX > line2MaxX ||\n    line1MaxX < line2MinX ||\n    line1MinY > line2MaxY ||\n    line1MaxY < line2MinY\n  ) {\n    return false;\n  }\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  // Take the cross product between vectors PQ and QR\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Get all intersections between a polyline and a line segment.\n * @param polyline - Polyline points\n * @param p1 - Start point of line segment\n * @param q1 - End point of line segment\n * @param closed - Test the intersection against the line segment that connects\n * the last to the first point when set to true\n * @returns Start/end point indexes of all line segments that intersect (p1, q1)\n */\nexport default function getLineSegmentIntersectionsIndexes(\n  polyline: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const intersections: Types.Point2[] = [];\n  const numPoints = polyline.length;\n  const maxI = numPoints - (closed ? 1 : 2);\n\n  for (let i = 0; i <= maxI; i++) {\n    const p2 = polyline[i];\n    // Do not use % operator for better performance\n    const j = i === numPoints - 1 ? 0 : i + 1;\n    const q2 = polyline[j];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([i, j]);\n    }\n  }\n\n  return intersections;\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\n// ATTENTION: this is an internal function and it should not be added to \"polyline\" namespace\n\n// Tested with +1M random overlapping line segments and any tolerance below this\n// one may return invalid results.\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\n\n/**\n * It returns the intersection between two lines (not line segments) or a midpoint\n * when the line segments overlap. This function calculates the intersection between\n * lines because it considers that getFirstLineSegmentIntersectionIndexes,\n * getLineSegmentIntersectionsCoordinates or getLineSegmentIntersectionsIndexes\n * has already been called first which guarantees.\n *\n * @param p1 - Line segment 1 start\n * @param q1 - Line segment 1 end\n * @param p2 - Line segment 2 start\n * @param q2 - Line segment 21 end\n * @returns The intersection between two lines or a midpoint when they overlap\n */\nexport default function getLinesIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n) {\n  const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n  const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n  const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n  const absDenominator = denominator >= 0 ? denominator : -denominator;\n\n  if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n    // No Math.min/max calls for better performance.\n    const line1AABB = [\n      p1[0] < q1[0] ? p1[0] : q1[0], // 0: minX\n      p1[0] > q1[0] ? p1[0] : q1[0], // 1: maxX\n      p1[1] < q1[1] ? p1[1] : q1[1], // 2: minY\n      p1[1] > q1[1] ? p1[1] : q1[1], // 3: maxY\n    ];\n\n    // No Math.min/max calls for better performance.\n    const line2AABB = [\n      p2[0] < q2[0] ? p2[0] : q2[0], // 0: minX\n      p2[0] > q2[0] ? p2[0] : q2[0], // 1: maxX\n      p2[1] < q2[1] ? p2[1] : q2[1], // 2: minY\n      p2[1] > q2[1] ? p2[1] : q2[1], // 3: maxY\n    ];\n\n    const aabbIntersects =\n      line1AABB[0] <= line2AABB[1] && // minX1 <= maxX2\n      line1AABB[1] >= line2AABB[0] && // maxX1 >= minX2\n      line1AABB[2] <= line2AABB[3] && // minY1 <= maxY2\n      line1AABB[3] >= line2AABB[2]; // maxY1 >= minY2\n\n    if (!aabbIntersects) {\n      return;\n    }\n\n    // Three tests are enough to know if the lines overlap\n    const overlap =\n      mathLine.isPointOnLineSegment(p1, q1, p2) ||\n      mathLine.isPointOnLineSegment(p1, q1, q2) ||\n      mathLine.isPointOnLineSegment(p2, q2, p1);\n\n    if (!overlap) {\n      return;\n    }\n\n    // min/max seems to be inverted but that is correct because it is looking\n    // for the intersection range. No Math.min/max calls for better performance.\n    const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n    const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n    const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n    const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n    const midX = (minX + maxX) * 0.5;\n    const midY = (minY + maxY) * 0.5;\n\n    return [midX, midY];\n  }\n\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n  const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * diffQ1P1[0];\n  const resultY = p1[1] + a * diffQ1P1[1];\n\n  return [resultX, resultY];\n}\n","import { Types } from '@cornerstonejs/core';\nimport * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\n\nenum PolylinePointType {\n  Vertex,\n  Intersection,\n}\n\n// Position of the point related to the intersection region\nenum PolylinePointPosition {\n  Outside = -1,\n  Edge = 0,\n  Inside = 1,\n}\n\n// Direction from last point to the intersection point to know if it is entering\n// or exiting the intersection region\nenum PolylinePointDirection {\n  Exiting = -1,\n  Unknown = 0,\n  Entering = 1,\n}\n\ntype PolylinePoint = {\n  type: PolylinePointType;\n  coordinates: Types.Point2;\n  position?: PolylinePointPosition;\n  visited: boolean;\n  next: PolylinePoint;\n};\n\ntype PolylineIntersectionPoint = PolylinePoint & {\n  direction: PolylinePointDirection;\n  cloned?: boolean;\n};\n\n/**\n * Ensure all polyline point objects are pointing to the next object in case\n * it is still not point to anyone.\n * @param polylinePoints - Array that contains all polyline points (vertices and intersections)\n */\nfunction ensuresNextPointers(polylinePoints: PolylinePoint[]) {\n  // Make sure all nodes point to a valid node\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const currentPoint = polylinePoints[i];\n\n    if (!currentPoint.next) {\n      currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n    }\n  }\n}\n\n/**\n * Creates one linked list per polyline that contains all vertices and intersections\n * found while walking along the edges.\n *\n * @param targetPolyline - Target polyline\n * @param sourcePolyline - Source polyline\n * @returns Two linked lists with all vertices and intersections.\n */\nfunction getSourceAndTargetPointsList(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetPolylinePoints: PolylinePoint[] = [];\n  const sourcePolylinePoints: PolylinePoint[] = [];\n  const sourceIntersectionsCache = new Map<\n    number,\n    PolylineIntersectionPoint[]\n  >();\n\n  const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n\n  let intersectionPointDirection = isFirstPointInside\n    ? PolylinePointDirection.Exiting\n    : PolylinePointDirection.Entering;\n\n  // Store all vertices and intersection for target contour\n  for (let i = 0, len = targetPolyline.length; i < len; i++) {\n    const p1 = targetPolyline[i];\n    const pointInside = containsPoint(sourcePolyline, p1);\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      position: pointInside\n        ? PolylinePointPosition.Inside\n        : PolylinePointPosition.Outside,\n      visited: false,\n      next: null,\n    };\n\n    targetPolylinePoints.push(vertexPoint);\n\n    const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n    const intersectionsInfo = getLineSegmentIntersectionsIndexes(\n      sourcePolyline,\n      p1,\n      q1\n    ).map((intersectedLineSegment) => {\n      const sourceLineSegmentId: number = intersectedLineSegment[0];\n      const p2 = sourcePolyline[intersectedLineSegment[0]];\n      const q2 = sourcePolyline[intersectedLineSegment[1]];\n\n      // lineSegment.intersectLine returns the midpoint of the four points\n      // when the lines are parallel or co-incident.  Otherwise it will return\n      // an extension of the line.\n      const intersectionCoordinate = getLinesIntersection(\n        p1,\n        q1,\n        p2,\n        q2\n      ) as Types.Point2;\n\n      const targetStartPointDistSquared = mathPoint.distanceToPointSquared(\n        p1,\n        intersectionCoordinate\n      );\n\n      return {\n        sourceLineSegmentId,\n        coordinate: intersectionCoordinate,\n        targetStartPointDistSquared,\n      };\n    });\n\n    intersectionsInfo.sort(\n      (left, right) =>\n        left.targetStartPointDistSquared - right.targetStartPointDistSquared\n    );\n\n    intersectionsInfo.forEach((intersectionInfo) => {\n      const { sourceLineSegmentId, coordinate: intersectionCoordinate } =\n        intersectionInfo;\n\n      // Intersection point to be added to the target polyline list\n      const targetEdgePoint: PolylineIntersectionPoint = {\n        type: PolylinePointType.Intersection,\n        coordinates: intersectionCoordinate,\n        position: PolylinePointPosition.Edge,\n        direction: intersectionPointDirection,\n        visited: false,\n        next: null,\n      };\n\n      // Intersection point to be added to the source polyline list.\n      // At this point there is no way to know if the point is entering or\n      // exiting the intersection region but that is not going to be used\n      // hence it is set to \"unknown\".\n      const sourceEdgePoint: PolylineIntersectionPoint = {\n        ...targetEdgePoint,\n        direction: PolylinePointDirection.Unknown,\n        cloned: true,\n      };\n\n      if (intersectionPointDirection === PolylinePointDirection.Entering) {\n        targetEdgePoint.next = sourceEdgePoint;\n      } else {\n        sourceEdgePoint.next = targetEdgePoint;\n      }\n\n      let sourceIntersectionPoints =\n        sourceIntersectionsCache.get(sourceLineSegmentId);\n\n      if (!sourceIntersectionPoints) {\n        sourceIntersectionPoints = [];\n        sourceIntersectionsCache.set(\n          sourceLineSegmentId,\n          sourceIntersectionPoints\n        );\n      }\n\n      targetPolylinePoints.push(targetEdgePoint);\n      sourceIntersectionPoints.push(sourceEdgePoint);\n\n      // Switches from \"exiting\" to \"entering\" and vice-versa\n      intersectionPointDirection *= -1;\n    });\n  }\n\n  // Store all vertices and intersections for source contour\n  for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n    const lineSegmentId: number = i;\n    const p1 = sourcePolyline[i];\n    const vertexPoint: PolylinePoint = {\n      type: PolylinePointType.Vertex,\n      coordinates: p1,\n      visited: false,\n      next: null,\n    };\n\n    sourcePolylinePoints.push(vertexPoint);\n\n    const sourceIntersectionPoints =\n      sourceIntersectionsCache.get(lineSegmentId);\n\n    if (!sourceIntersectionPoints?.length) {\n      continue;\n    }\n\n    // Calculate the distance between each intersection point to the start point\n    // of the line segment, sort them by distance and return a sorted array that\n    // contains all intersection points.\n    sourceIntersectionPoints\n      .map((intersectionPoint) => ({\n        intersectionPoint,\n        lineSegStartDistSquared: mathPoint.distanceToPointSquared(\n          p1,\n          intersectionPoint.coordinates\n        ),\n      }))\n      .sort(\n        (left, right) =>\n          left.lineSegStartDistSquared - right.lineSegStartDistSquared\n      )\n      .map(({ intersectionPoint }) => intersectionPoint)\n      .forEach((intersectionPoint) =>\n        sourcePolylinePoints.push(intersectionPoint)\n      );\n  }\n\n  ensuresNextPointers(targetPolylinePoints);\n  ensuresNextPointers(sourcePolylinePoints);\n\n  return { targetPolylinePoints, sourcePolylinePoints };\n}\n\n/**\n * Get the next unvisited polyline points that is outside the intersection region.\n * @param polylinePoints - All polyline points (vertices and intersections)\n * @returns Any unvisited point that is outside the intersection region if it\n * exists or `undefined` otherwise\n */\nfunction getUnvisitedOutsidePoint(polylinePoints: PolylinePoint[]) {\n  for (let i = 0, len = polylinePoints.length; i < len; i++) {\n    const point = polylinePoints[i];\n\n    if (!point.visited && point.position === PolylinePointPosition.Outside) {\n      return point;\n    }\n  }\n}\n\n/**\n * Merge two planar polylines (2D)\n */\nfunction mergePolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n) {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // Both polylines need to be CW or CCW to be merged and one of them needs to\n  // be reversed if theirs orientation are not the same\n  if (!glMatrix.equals(1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  const startPoint: PolylinePoint =\n    getUnvisitedOutsidePoint(targetPolylinePoints);\n\n  // Source polyline contains target polyline\n  if (!startPoint) {\n    return targetPolyline.slice();\n  }\n\n  const mergedPolyline = [startPoint.coordinates];\n  let currentPoint = startPoint.next;\n\n  while (currentPoint !== startPoint) {\n    if (\n      currentPoint.type === PolylinePointType.Intersection &&\n      (<PolylineIntersectionPoint>currentPoint).cloned\n    ) {\n      currentPoint = currentPoint.next;\n      continue;\n    }\n\n    mergedPolyline.push(currentPoint.coordinates);\n    currentPoint = currentPoint.next;\n  }\n\n  return mergedPolyline;\n}\n\n/**\n * Subtract two planar polylines (2D)\n */\nfunction subtractPolylines(\n  targetPolyline: Types.Point2[],\n  sourcePolyline: Types.Point2[]\n): Types.Point2[][] {\n  const targetNormal = getNormal2(targetPolyline);\n  const sourceNormal = getNormal2(sourcePolyline);\n  const dotNormals = vec3.dot(sourceNormal, targetNormal);\n\n  // The polylines need to have different orientation (CW+CCW or CCW+CW) to be\n  // subtracted and one of them needs to be reversed if theirs orientation are\n  // the same\n  if (!glMatrix.equals(-1, dotNormals)) {\n    sourcePolyline = sourcePolyline.slice().reverse();\n  }\n\n  const { targetPolylinePoints } = getSourceAndTargetPointsList(\n    targetPolyline,\n    sourcePolyline\n  );\n  let startPoint: PolylinePoint = null;\n  const subtractedPolylines = [];\n\n  while ((startPoint = getUnvisitedOutsidePoint(targetPolylinePoints))) {\n    const subtractedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n\n    startPoint.visited = true;\n\n    while (currentPoint !== startPoint) {\n      currentPoint.visited = true;\n\n      if (\n        currentPoint.type === PolylinePointType.Intersection &&\n        (<PolylineIntersectionPoint>currentPoint).cloned\n      ) {\n        currentPoint = currentPoint.next;\n        continue;\n      }\n\n      subtractedPolyline.push(currentPoint.coordinates);\n      currentPoint = currentPoint.next;\n    }\n\n    subtractedPolylines.push(subtractedPolyline);\n  }\n\n  return subtractedPolylines;\n}\n\nexport { mergePolylines, subtractPolylines };\n","import type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n *\n * @param points - Polyline points\n * @param p1 - First point of the line segment that is being tested\n * @param q1 - Second point of the line segment that is being tested\n * @param closed - Test the intersection with the line segment that connects\n *   the last and first points of the polyline\n * @returns Indexes of the line segment points from the polyline that intersects [p1, q1]\n */\nexport default function getFirstLineSegmentIntersectionIndexes(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\n\n/**\n * Check if two polylines intersect comparing line segment by line segment.\n * @param sourcePolyline - Source polyline\n * @param targetPolyline - Target polyline\n * @returns True if the polylines intersect or false otherwise\n */\nexport default function intersectPolyline(\n  sourcePolyline: Types.Point2[],\n  targetPolyline: Types.Point2[]\n): boolean {\n  // Naive way to detect intersection between polylines in O(n^2).\n  // TODO: Implement Bentley Ottmann sweep line algorithm or maybe some\n  // algorithm that uses r-tree may make it run faster\n  for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n    const sourceP1 = sourcePolyline[i];\n    const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n    const sourceP2 = sourcePolyline[sourceP2Index];\n\n    const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(\n      targetPolyline,\n      sourceP1,\n      sourceP2\n    );\n\n    if (intersectionPointIndexes?.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as mathLine from '../line';\n\nconst DEFAULT_EPSILON = 0.1;\n\n/**\n * Ramer–Douglas–Peucker algorithm implementation to decimate a polyline\n * to a similar polyline with fewer points\n *\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n * https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification\n * https://karthaus.nl/rdp/\n *\n * @param polyline - Polyline to decimate\n * @param epsilon - A maximum given distance 'epsilon' to decide if a point\n * should or shouldn't be added the decimated polyline version. In each\n * iteration the polyline is split into two polylines and the distance of each\n * point from those new polylines are checked against the line that connects\n * the first and last points.\n * @returns Decimated polyline\n */\nexport default function decimate(\n  polyline: Types.Point2[],\n  epsilon = DEFAULT_EPSILON\n) {\n  const numPoints = polyline.length;\n\n  // The polyline must have at least a start and end points\n  if (numPoints < 3) {\n    return polyline;\n  }\n\n  const epsilonSquared = epsilon * epsilon;\n  const partitionQueue = [[0, numPoints - 1]];\n\n  // Used a boolean array to set each point that will be in the decimated polyline\n  // because pre-allocated arrays are 3-4x faster than thousands of push() calls\n  // to add all points to a new array.\n  const polylinePointFlags = new Array(numPoints).fill(false);\n\n  // Start and end points are always added to the decimated polyline\n  let numDecimatedPoints = 2;\n\n  // Add start and end points to the decimated polyline\n  polylinePointFlags[0] = true;\n  polylinePointFlags[numPoints - 1] = true;\n\n  // Iterative approach using a queue instead of recursion to reduce the number\n  // of function calls (performance)\n  while (partitionQueue.length) {\n    const [startIndex, endIndex] = partitionQueue.pop();\n\n    // Return if there is no point between the start and end points\n    if (endIndex - startIndex === 1) {\n      continue;\n    }\n\n    const startPoint = polyline[startIndex];\n    const endPoint = polyline[endIndex];\n    let maxDistSquared = -Infinity;\n    let maxDistIndex = -1;\n\n    // Search for the furthest point\n    for (let i = startIndex + 1; i < endIndex; i++) {\n      const currentPoint = polyline[i];\n      const distSquared = mathLine.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        currentPoint\n      );\n\n      if (distSquared > maxDistSquared) {\n        maxDistSquared = distSquared;\n        maxDistIndex = i;\n      }\n    }\n\n    // Do not add any of the points because the fursthest one is very close to\n    // the line based on the epsilon value\n    if (maxDistSquared < epsilonSquared) {\n      continue;\n    }\n\n    // Update the flag for the furthest point because it will be added to the\n    // decimated polyline\n    polylinePointFlags[maxDistIndex] = true;\n    numDecimatedPoints++;\n\n    // Partition the points into two parts using maxDistIndex as the pivot point\n    // and process both sides\n    partitionQueue.push([maxDistIndex, endIndex]);\n    partitionQueue.push([startIndex, maxDistIndex]);\n  }\n\n  // A pre-allocated array is 3-4x faster then multiple push() calls\n  const decimatedPolyline: Types.Point2[] = new Array(numDecimatedPoints);\n\n  for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n    if (polylinePointFlags[srcIndex]) {\n      decimatedPolyline[dstIndex++] = polyline[srcIndex];\n    }\n  }\n\n  return decimatedPolyline;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\n\n/**\n * Returns all intersections points between a line segment and a polyline\n */\nexport default function getLineSegmentIntersectionsCoordinates(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getLineSegmentIntersectionsIndexes(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getLinesIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n\n  return result;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n * @param points - Polyline points\n * @param p1 - Start point of the line segment\n * @param q1 - End point of the line segment\n * @param closed - Test the intersection against the line that connects the first to the last when closed\n * @returns The closest line segment from polyline that intersects the line segment [p1, q1]\n */\nexport default function getClosestLineSegmentIntersection(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialQ2Index;\n  let p2Index;\n\n  if (closed) {\n    p2Index = points.length - 1;\n    initialQ2Index = 0;\n  } else {\n    p2Index = 0;\n    initialQ2Index = 1;\n  }\n\n  const intersections = [];\n\n  for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n    const p2 = points[p2Index];\n    const q2 = points[q2Index];\n\n    if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n      intersections.push([p2Index, q2Index]);\n    }\n\n    p2Index = q2Index;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (!canvasPoints.length) {\n    canvasPoints.push(newCanvasPoint);\n    console.log('>>>>> !canvasPoints. :: RETURN');\n    return 1;\n  }\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\n\n/**\n * Determines whether a 3D point is inside a polyline in 3D space.\n *\n * The algorithm works by reducing the polyline and point to 2D space, and then\n * using the 2D algorithm to determine whether the point is inside the polyline.\n *\n * @param point - The 3D point to test.\n * @param polyline - The polyline represented as an array of 3D points.\n * @param options.holesPolyline - An array of polylines representing each hole, so it\n * is an array of arrays of 3D points.\n * @returns A boolean indicating whether the point is inside the polyline.\n * @throws An error if a shared dimension index cannot be found for the polyline points.\n */\nexport function isPointInsidePolyline3D(\n  point: Types.Point3,\n  polyline: Types.Point3[],\n  options: { holes?: Types.Point3[][] } = {}\n) {\n  const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n\n  const { holes } = options;\n  const projectedHoles = [] as Types.Point2[][];\n\n  if (holes) {\n    for (let i = 0; i < holes.length; i++) {\n      const hole = holes[i];\n      const hole2D = [] as Types.Point2[];\n\n      for (let j = 0; j < hole.length; j++) {\n        hole2D.push([\n          hole[j][(sharedDimensionIndex + 1) % 3],\n          hole[j][(sharedDimensionIndex + 2) % 3],\n        ]);\n      }\n\n      projectedHoles.push(hole2D);\n    }\n  }\n\n  const point2D = [\n    point[(sharedDimensionIndex + 1) % 3],\n    point[(sharedDimensionIndex + 2) % 3],\n  ] as Types.Point2;\n\n  return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n  // Square of the radius\n  radius2?: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * This is safe to call for point in circle as long as you don't call it with\n * anything off-plane - that is, a circle is a degenerate sphere that is\n * intersected with the primary plane.\n *\n * @param sphere - Sphere object with center and radius and radius squared\n *     as radius2 if you are calling this a huge number of times.\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(sphere: Sphere, pointLPS: vec3): boolean {\n  const { center, radius } = sphere;\n  const radius2 = sphere.radius2 || radius * radius;\n\n  return (\n    (pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n      (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n      (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n    radius2\n  );\n}\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","import smoothAnnotation from './smoothAnnotation';\n\nexport default {\n  smoothAnnotation,\n};\n\nexport { smoothAnnotation };\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\nimport { filterAnnotationsWithinSamePlane } from './filterAnnotationsWithinPlane';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n  filterAnnotationsWithinSamePlane,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n  isPlaneIntersectingAABB,\n  filterAnnotationsWithinSamePlane,\n};\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  if (!scalarData) {\n    console.warn('No scalar data found for imageData', imageData);\n    return;\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points - array of number, each point defined by three consecutive numbers\n * @param idx - index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx): Types.Point3 {\n  const idx3 = idx * 3;\n  if (idx3 < points.length) {\n    return vec3.fromValues(\n      points[idx3],\n      points[idx3 + 1],\n      points[idx3 + 2]\n    ) as Types.Point3;\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShapeIJK(\n      rectangleCornersIJK,\n      dimensions\n    );\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nconst { isEqual } = csUtils;\n\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\n\nconst axisList = [iAxis, jAxis, kAxis];\n\n/**\n * Determines whether a given rectangle in a 3D space (defined by its corner\n * points in IJK coordinates) is aligned with the IJK axes.\n * @param rectangleCornersIJK - The corner points of the rectangle in IJK coordinates\n * @returns True if the rectangle is aligned with the IJK axes, false otherwise\n */\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n  const rectangleVec1 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[1]\n  );\n\n  const rectangleVec2 = vec3.subtract(\n    vec3.create(),\n    rectangleCornersIJK[0],\n    rectangleCornersIJK[2]\n  );\n\n  // Calculate the angles with IJK axes for both vectors\n  const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n  const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n\n  // Check if all angles are aligned (0, 90, 180, or 270 degrees)\n  // we could do csUtils.isEqual(angle % 90, 0) but this is more explicit for reading\n  const isAligned = [...anglesVec1, ...anglesVec2].every(\n    (angle) =>\n      isEqual(angle, 0) ||\n      isEqual(angle, 90) ||\n      isEqual(angle, 180) ||\n      isEqual(angle, 270)\n  );\n\n  return isAligned;\n}\n\n// Function to calculate angle with IJK axes\nfunction calculateAnglesWithAxes(vec, axes) {\n  return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\n\nexport { isAxisAlignedRectangle };\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { volumeId, delta, scrollSlabs } = options;\n\n  if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta, scrollSlabs);\n  } else {\n    (viewport as Types.IStackViewport).scroll(\n      delta,\n      options.debounceLoading,\n      options.loop\n    );\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number,\n  scrollSlabs = false\n) {\n  const useSlabThickness = scrollSlabs;\n\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  const VolumeScrollEventDetail: EventTypes.VolumeScrollOutOfBoundsEventDetail =\n    {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail\n    );\n  } else {\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_VIEWPORT_SCROLL,\n      VolumeScrollEventDetail\n    );\n  }\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  AnnotationCompletedEventType,\n  AnnotationModifiedEventType,\n  AnnotationRemovedEventType,\n} from '../../../types/EventTypes';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport type AnnotationGroupSelector from '../../../types/AnnotationGroupSelector';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport type {\n  InterpolationViewportData,\n  AcceptInterpolationSelector,\n} from '../../../types/InterpolationTypes';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\n\nconst { uuidv4 } = csUtils;\n\nconst ChangeTypesForInterpolation = [\n  ChangeTypes.HandlesUpdated,\n  ChangeTypes.InterpolationUpdated,\n];\n\nexport default class InterpolationManager {\n  static toolNames = [];\n\n  static addTool(toolName: string) {\n    if (!this.toolNames.includes(toolName)) {\n      this.toolNames.push(toolName);\n    }\n  }\n\n  /**\n   * Accepts the autogenerated interpolations, marking them as non-autogenerated.\n   * Can provide a selector to choose which ones to accept.\n   *\n   * Rules for which items to select:\n   * 1. Only choose annotations having the same segment index and segmentationID\n   * 2. Exclude all contours having the same interpolation UID as any other contours\n   *    on the same slice.\n   * 3. Exclude autogenerated annotations\n   * 4. Exclude any reset interpolationUIDs (this is a manual operation to allow\n   *    creating a new interpolation)\n   * 5. Find the set of interpolationUID's remaining\n   *    a. If the set is of size 0, assign a new interpolationUID\n   *    b. If the set is of size 1, assign that interpolationUID\n   *    c. Otherwise (optional, otherwise do b for size>1 randomly),\n   *       for every remaining annotation, find the one whose center\n   *       point is closest to the center point of the new annotation.\n   *       Choose that interpolationUID\n   *\n   * To allow creating new interpolated groups, the idea is to just use a new\n   * segment index, then have an operation to update the segment index of an\n   * interpolation set.  That way the user can easily draw/see the difference,\n   * and then merge them as required.\n   * However, the base rules allow creating two contours on a single image to\n   * create a separate set.\n   */\n  static acceptAutoGenerated(\n    annotationGroupSelector: AnnotationGroupSelector,\n    selector: AcceptInterpolationSelector = {}\n  ) {\n    const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n    for (const toolName of toolNames || InterpolationManager.toolNames) {\n      const annotations = annotationState.getAnnotations(\n        toolName,\n        annotationGroupSelector\n      ) as InterpolationROIAnnotation[];\n      if (!annotations?.length) {\n        continue;\n      }\n      for (const annotation of annotations) {\n        const { interpolationUID, data, autoGenerated, metadata } = annotation;\n        if (interpolationUID) {\n          annotation.interpolationCompleted = true;\n        }\n        if (!autoGenerated) {\n          continue;\n        }\n        if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n          continue;\n        }\n        if (\n          sliceIndex !== undefined &&\n          metadata &&\n          sliceIndex !== metadata.sliceIndex\n        ) {\n          continue;\n        }\n        if (\n          segmentationId &&\n          segmentationId !== data.segmentation.segmentationId\n        ) {\n          continue;\n        }\n        addContourSegmentationAnnotation(annotation);\n        annotation.autoGenerated = false;\n      }\n    }\n  }\n\n  /**\n   * When an annotation is completed, if the configuration includes interpolation,\n   * then find matching interpolations and interpolation between this segmentation\n   * and the other segmentations of the same type.\n   */\n  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      !this.toolNames.includes(toolName) &&\n      !this.toolNames.includes(originalToolName)\n    ) {\n      return;\n    }\n\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn('Unable to find viewport for', annotation);\n      return;\n    }\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    const hasInterpolationUID = !!annotation.interpolationUID;\n    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.\n    annotation.autoGenerated = false;\n    if (hasInterpolationUID) {\n      // This has already been configured with matching details, so just run\n      //  the interpolation again.\n      deleteRelatedAnnotations(viewportData);\n      interpolate(viewportData);\n      return;\n    }\n    const filterData = [\n      {\n        key: 'segmentIndex',\n        value: annotation.data.segmentation.segmentIndex,\n        parentKey: (annotation) => annotation.data.segmentation,\n      },\n      {\n        key: 'viewPlaneNormal',\n        value: annotation.metadata.viewPlaneNormal,\n        parentKey: (annotation) => annotation.metadata,\n      },\n      {\n        key: 'viewUp',\n        value: annotation.metadata.viewUp,\n        parentKey: (annotation) => annotation.metadata,\n      },\n    ];\n    let interpolationAnnotations = getInterpolationDataCollection(\n      viewportData,\n      filterData\n    );\n    // Skip other type of annotation interpolationUID's that are co-located\n    const { sliceIndex } = annotation.metadata;\n    const skipUIDs = new Set<string>();\n    interpolationAnnotations.forEach((interpolationAnnotation) => {\n      if (\n        interpolationAnnotation.interpolationCompleted ||\n        interpolationAnnotation.metadata.sliceIndex === sliceIndex\n      ) {\n        const { interpolationUID } = interpolationAnnotation;\n        skipUIDs.add(interpolationUID);\n      }\n    });\n    interpolationAnnotations = interpolationAnnotations.filter(\n      (interpolationAnnotation) =>\n        !skipUIDs.has(interpolationAnnotation.interpolationUID)\n    );\n\n    // Assign a new interpolationUID (this is checked above, so will be empty initially)\n    annotation.interpolationUID =\n      interpolationAnnotations[0]?.interpolationUID || uuidv4();\n    viewportData.interpolationUID = annotation.interpolationUID;\n    interpolate(viewportData);\n  };\n\n  /**\n   * This method gets called when an annotation changes.  It will then trigger\n   * related already interpolated annotations to be updated with the modified data.\n   */\n  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName, originalToolName } = annotation.metadata;\n\n    if (\n      (!this.toolNames.includes(toolName) &&\n        !this.toolNames.includes(originalToolName)) ||\n      !ChangeTypesForInterpolation.includes(changeType)\n    ) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n    if (!viewport) {\n      console.warn(\n        'Unable to find matching viewport for annotation interpolation',\n        annotation\n      );\n      return;\n    }\n    if (annotation.autoGenerated) {\n      // Dont fire the annotation changed events here, as that leads to recursion,\n      // although this is in fact completing the event, so trigger the segmentation add\n      addContourSegmentationAnnotation(annotation);\n      annotation.autoGenerated = false;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n      isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n    };\n    interpolate(viewportData);\n  };\n\n  /**\n   * Delete interpolated annotations when their endpoints are deleted.\n   */\n  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {\n    const annotation = evt.detail.annotation as InterpolationROIAnnotation;\n    if (!annotation?.metadata) {\n      return;\n    }\n    const { toolName } = annotation.metadata;\n\n    if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n      return;\n    }\n    const viewport = getViewportForAnnotation(annotation);\n\n    if (!viewport) {\n      console.warn(\n        \"No viewport, can't delete interpolated results\",\n        annotation\n      );\n      return;\n    }\n\n    const sliceData: Types.ImageSliceData = getSliceData(viewport);\n    const viewportData: InterpolationViewportData = {\n      viewport,\n      sliceData,\n      annotation,\n      interpolationUID: annotation.interpolationUID,\n    };\n    // If any update, triggered on an annotation, then it will be treated as non-interpolated.\n    annotation.autoGenerated = false;\n    deleteRelatedAnnotations(viewportData);\n  };\n}\n\nfunction getSliceData(viewport): Types.ImageSliceData {\n  const sliceData: Types.ImageSliceData = {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getCurrentImageIdIndex(),\n  };\n  return sliceData;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2,\n  otherArgs: Record<string, unknown> = { isDynamic: false }\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const configuration = {\n    ...otherArgs,\n    ...(threshold !== undefined && { threshold }),\n  };\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD = {\n      ...tool.configuration.strategySpecificConfiguration.THRESHOLD,\n      ...configuration,\n    };\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration.THRESHOLD\n    .threshold;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\n/**\n * Determines if there is a point between point1 and point2 which is not\n * contained in the segmentation\n */\nexport default function isLineInSegment(\n  point1: Types.Point3,\n  point2: Types.Point3,\n  isInSegment\n) {\n  const ijk1 = isInSegment.toIJK(point1);\n  const ijk2 = isInSegment.toIJK(point2);\n  const testPoint = vec3.create();\n  const { testIJK } = isInSegment;\n  const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n\n  // Test once for index value between the two points, so the max of the\n  // difference in IJK values\n  const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n  if (testSize < 2) {\n    // No need to test when there are only two points\n    return true;\n  }\n  const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n\n  for (let i = 1; i < testSize; i++) {\n    vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n    if (!testIJK(testPoint)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Creates a function that tests to see if the provided line segment, specified\n * in LPS space (as endpoints) is contained in the segment\n */\nfunction createIsInSegment(\n  segVolumeId: string,\n  segmentIndex: number,\n  containedSegmentIndices?: Set<number>\n) {\n  // Get segmentation volume\n  const vol = cache.getVolume(segVolumeId);\n  if (!vol) {\n    console.warn(`No volume found for ${segVolumeId}`);\n    return;\n  }\n\n  const segData = vol.imageData.getPointData().getScalars().getData();\n  const width = vol.dimensions[0];\n  const pixelsPerSlice = width * vol.dimensions[1];\n\n  return {\n    /**\n     * Find the center point between point1 and point2, convert it to IJK space\n     * and test if the value at that location is in the segment\n     */\n    testCenter: (point1, point2) => {\n      const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n      const ijk = vol.imageData.worldToIndex(point as vec3).map(Math.round);\n      const [i, j, k] = ijk;\n      const index = i + j * width + k * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n\n    toIJK: (point) => vol.imageData.worldToIndex(point as vec3),\n\n    testIJK: (ijk) => {\n      const [i, j, k] = ijk;\n      const index =\n        Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n      const value = segData[index];\n      return value === segmentIndex || containedSegmentIndices?.has(value);\n    },\n  };\n}\n\nexport { createIsInSegment, isLineInSegment };\n","import { vec3 } from 'gl-matrix';\n\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nimport type { BidirectionalData } from './createBidirectionalToolData';\n\nconst EPSILON = 1e-2;\n\n/**\n * Search in the contours for the given segment to find the largest bidirectional\n * that will fit entirely within the slice contours inside the contours object.\n * Assumptions/implementation details:\n *\n *   1. The major and minor bidirectional lines must not cross the contour\n *   2. The center point for both major and minor bidirectional lines must be\n *      within the segment, or the contained segment index.\n *   3. The major/minor axis must be orthogonal\n *\n * Note this does NOT test that the major/minor axis intersect.  Normally they will, but\n * it isn't a hard requirement.\n *\n * The way that islands within the contours are handled is to allow the island to be\n * coloured with something that is contained - that way both open and closed islands\n * can be handled correctly for finding the bidirectional  (an open island is a section\n * inside the segment that is open to the outside - this can happen at bone endpoints or when\n * one region flows into another)\n */\nexport default function findLargestBidirectional(\n  contours,\n  segVolumeId: string,\n  segment\n) {\n  const { sliceContours } = contours;\n  const { segmentIndex, containedSegmentIndices } = segment;\n  let maxBidirectional;\n  const isInSegment = createIsInSegment(\n    segVolumeId,\n    segmentIndex,\n    containedSegmentIndices\n  );\n  for (const sliceContour of sliceContours) {\n    const bidirectional = createBidirectionalForSlice(\n      sliceContour,\n      isInSegment,\n      maxBidirectional\n    );\n    if (!bidirectional) {\n      continue;\n    }\n    maxBidirectional = bidirectional;\n  }\n  if (maxBidirectional) {\n    Object.assign(maxBidirectional, segment);\n  }\n  return maxBidirectional;\n}\n\n/**\n * This function creates a bidirectional data object for the given slice and\n * slice contour, only when the major distance is larger than currentMax, or\n * equal to current max and the minor is larger than currentMax's minor.\n * It does this by looking at every pair of distances in sliceCountour to find\n * those larger than the currentMax, and then finds the minor distance for those\n * major distances.\n *\n */\nfunction createBidirectionalForSlice(\n  sliceContour,\n  isInSegment,\n  currentMax = { maxMajor: 0, maxMinor: 0 }\n) {\n  const { points } = sliceContour.polyData;\n  const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n  let maxMajor = currentMaxMajor * currentMaxMajor;\n  let maxMinor = currentMaxMinor * currentMaxMinor;\n  let maxMajorPoints;\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 < maxMajor) {\n        continue;\n      }\n      if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n        // Consider adding to the set of points rather than continuing here\n        // so that all minor axis can be tested\n        continue;\n      }\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        // If the line intersects the segment boundary, then skip it\n        continue;\n      }\n      maxMajor = distance2 - EPSILON;\n      maxMajorPoints = [index1, index2];\n      maxMinor = 0;\n    }\n  }\n  if (!maxMajorPoints) {\n    return;\n  }\n\n  maxMajor = Math.sqrt(maxMajor + EPSILON);\n  const handle0 = points[maxMajorPoints[0]];\n  const handle1 = points[maxMajorPoints[1]];\n  const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n  vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n\n  let maxMinorPoints;\n\n  for (let index1 = 0; index1 < points.length; index1++) {\n    for (let index2 = index1 + 1; index2 < points.length; index2++) {\n      const point1 = points[index1];\n      const point2 = points[index2];\n      const distance2 = vec3.sqrDist(point1, point2);\n      if (distance2 <= maxMinor) {\n        continue;\n      }\n      const delta = vec3.sub(vec3.create(), point1, point2);\n\n      const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n      if (dot > EPSILON) {\n        continue;\n      }\n\n      if (!isInSegment.testCenter(point1, point2)) {\n        // Center between the two points has to be in the segment, otherwise\n        // this is out of bounds.\n        continue;\n      }\n      if (!isLineInSegment(point1, point2, isInSegment)) {\n        continue;\n      }\n      maxMinor = distance2;\n      maxMinorPoints = [index1, index2];\n    }\n  }\n\n  if (!maxMinorPoints) {\n    // Didn't find a larger minor distance\n    return;\n  }\n  maxMinor = Math.sqrt(maxMinor);\n  const handle2 = points[maxMinorPoints[0]];\n  const handle3 = points[maxMinorPoints[1]];\n\n  const bidirectional = {\n    majorAxis: [handle0, handle1],\n    minorAxis: [handle2, handle3],\n    maxMajor,\n    maxMinor,\n    ...sliceContour,\n  } as BidirectionalData;\n  return bidirectional;\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport findLargestBidirectional from './findLargestBidirectional';\n\nconst { Labelmap } = SegmentationRepresentations;\n\n/**\n * Generates a contour object over the segment, and then uses the contouring to\n * find the largest bidirectional object that can be applied within the acquisition\n * plane that is within the segment index, or the contained segment indices.\n *\n * @param segmentation.segments - a list of segments to apply the contour to.\n * @param segmentation.segments.containedSegmentIndices - a set of segment indexes equivalent to the primary segment\n * @param segmentation.segments.label - the label for the segment\n * @param segmentation.segments.color - the color to use for the segment label\n */\nexport default function contourAndFindLargestBidirectional(segmentation) {\n  const contours = generateContourSetsFromLabelmap({\n    segmentations: segmentation,\n  });\n\n  if (!contours?.length || !contours[0].sliceContours.length) {\n    return;\n  }\n\n  const {\n    representationData,\n    segments = [\n      null,\n      { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ],\n  } = segmentation;\n  const { volumeId: segVolumeId } = representationData[Labelmap];\n\n  const segmentIndex = segments.findIndex((it) => !!it);\n  if (segmentIndex === -1) {\n    return;\n  }\n  segments[segmentIndex].segmentIndex = segmentIndex;\n  return findLargestBidirectional(\n    contours[0],\n    segVolumeId,\n    segments[segmentIndex]\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../../types/AnnotationTypes';\n\nexport type BidirectionalData = {\n  majorAxis: [Types.Point3, Types.Point3];\n  minorAxis: [Types.Point3, Types.Point3];\n  maxMajor: number;\n  maxMinor: number;\n  segmentIndex: number;\n  label?: string;\n  color?: string | number[];\n  referencedImageId: string;\n  sliceIndex: number;\n};\n\n/**\n * Creates data suitable for the BidirectionalTool from the basic bidirectional\n * data object.\n */\nexport default function createBidirectionalToolData(\n  bidirectionalData: BidirectionalData,\n  viewport\n): Annotation {\n  const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n  const [major0, major1] = majorAxis;\n  const [minor0, minor1] = minorAxis;\n\n  const points = [major0, major1, minor0, minor1];\n  const bidirectionalToolData = {\n    highlighted: true,\n    invalidated: true,\n    metadata: {\n      toolName: 'Bidirectional',\n      // Get a view reference for the slice this applies to, not the currently\n      // displayed slice.  This will fill in the remaining data for that slice\n      ...viewport.getViewReference({ sliceIndex }),\n    },\n    data: {\n      handles: {\n        points,\n        textBox: {\n          hasMoved: false,\n          worldPosition: [0, 0, 0] as Types.Point3,\n          worldBoundingBox: {\n            topLeft: [0, 0, 0] as Types.Point3,\n            topRight: [0, 0, 0] as Types.Point3,\n            bottomLeft: [0, 0, 0] as Types.Point3,\n            bottomRight: [0, 0, 0] as Types.Point3,\n          },\n        },\n        activeHandleIndex: null,\n      },\n      label,\n      cachedStats: {},\n    },\n    isLocked: false,\n    isVisible: true,\n  };\n  return bidirectionalToolData;\n}\n","/**\n * Creates a map that associates each imageId with a set of segmentation imageIds.\n * Note that this function assumes that the imageIds and segmentationImageIds arrays\n * are the same length and same order.\n *\n * @param imageIdsArray - An array of imageIds.\n * @param segmentationImageIds - An array of segmentation imageIds.\n * @returns A map that maps each imageId to a set of segmentation imageIds.\n */\nfunction createImageIdReferenceMap(\n  imageIdsArray: string[],\n  segmentationImageIds: string[]\n): Map<string, string> {\n  const imageIdReferenceMap = new Map<string, string>(\n    imageIdsArray.map((imageId, index) => {\n      return [imageId, segmentationImageIds[index]];\n    })\n  );\n\n  return imageIdReferenceMap;\n}\n\nexport { createImageIdReferenceMap };\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId: string;\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata: Types.Metadata;\n    dimensions: Types.Point3;\n    spacing: Types.Point3;\n    origin: Types.Point3;\n    direction: Types.Mat3;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.  Fixed the bounds/visits checks to use integer keys, restricting the\n * total search spacing to +/- 32k in each dimension, but resulting in about a hundred time\n * performance gain for larger regions since JavaScript does not have a hash map to allow the\n * map to work on keys.\n *\n * @param getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param options.onFlood - An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param options.onBoundary - An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param options.equals - An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param options.diagonals - Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns Flood fill results\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = new Set();\n  const bounds = new Map();\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  /**\n   * Indicates if the key has been visited.\n   * @param key is a 2 or 3 element vector with values -32768...32767\n   */\n  function visited(key) {\n    const [x, y, z = 0] = key;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    return visits.has(iKey);\n  }\n\n  function markAsVisited(key) {\n    const [x, y, z = 0] = key;\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    visits.add(iKey);\n  }\n\n  function member(getArgs) {\n    const node = get(getArgs);\n\n    return equals ? equals(node, startNode) : node === startNode;\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    const [x, y, z = 0] = prevArgs;\n    // Use an integer key value for checking visited, since JavaScript does not\n    // provide a generic hash key indexed hash map.\n    const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n    bounds.set(iKey, prevArgs);\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  // This is a significant performance hit - should be done as a wrapper\n  // only when needed.\n  // function safely(f, args) {\n  //   try {\n  //     return f(...args);\n  //   } catch (error) {\n  //     return;\n  //   }\n  // }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = Array.from(bounds.values());\n    array.reverse();\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\n\n/**\n * Retrieves the index of the hovered contour segmentation annotation for a given segmentation ID.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns The index of the hovered contour segmentation annotation, or undefined if none is found.\n */\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n  const segmentation = getSegmentation(segmentationId);\n  const { annotationUIDsMap } = segmentation.representationData.CONTOUR;\n\n  for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n    const highlightedAnnotationUID = Array.from(annotationUIDs).find(\n      (annotationUID) => getAnnotation(annotationUID).highlighted\n    );\n\n    if (highlightedAnnotationUID) {\n      return segmentIndex;\n    }\n  }\n\n  return undefined;\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\n\ntype Options = {\n  viewport?: Types.IViewport;\n  searchRadius?: number;\n};\n\n/**\n * Retrieves the segment index at the border of a labelmap in a segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param worldPoint - The world coordinates of the point.\n * @param options - Additional options.\n * @param options.viewport - The viewport to use.\n * @param options.searchRadius - The search radius to use.\n * @returns The segment index at the labelmap border, or undefined if not found.\n */\nexport function getSegmentAtLabelmapBorder(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  { viewport, searchRadius }: Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const imageData = segmentationVolume.imageData;\n\n    const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);\n\n    const canvasPoint = viewport.worldToCanvas(worldPoint);\n\n    const onEdge = isSegmentOnEdgeCanvas(\n      canvasPoint as Types.Point2,\n      segmentIndex,\n      viewport,\n      imageData,\n      searchRadius\n    );\n\n    return onEdge ? segmentIndex : undefined;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  const onEdge = isSegmentOnEdgeIJK(\n    indexIJK as Types.Point3,\n    dimensions,\n    voxelManager,\n    segmentIndex\n  );\n\n  return onEdge ? segmentIndex : undefined;\n}\n\n/**\n * Checks if a segment is on the edge of a labelmap.\n * @param getNeighborIndex - A function that returns the neighbor index given the delta values.\n * @param segmentIndex - The index of the segment to check.\n * @param searchRadius - The radius within which to search for neighboring segments. Default is 1.\n * @returns A boolean indicating whether the segment is on the edge.\n */\nfunction isSegmentOnEdge(\n  getNeighborIndex: (\n    deltaI: number,\n    deltaJ: number,\n    deltaK: number\n  ) => number | undefined,\n  segmentIndex: number,\n  searchRadius = 1 // Default search radius\n): boolean {\n  const neighborRange = Array.from(\n    { length: 2 * searchRadius + 1 },\n    (_, i) => i - searchRadius\n  );\n\n  for (const deltaI of neighborRange) {\n    for (const deltaJ of neighborRange) {\n      for (const deltaK of neighborRange) {\n        if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n          continue; // Skipping the central point\n        }\n\n        const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n\n        if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n          return true; // On the edge\n        }\n      }\n    }\n  }\n\n  return false; // No edge neighbors found\n}\n\nfunction isSegmentOnEdgeIJK(\n  indexIJK: Types.Point3,\n  dimensions: Types.Point3,\n  voxelManager: any,\n  segmentIndex: number,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number, deltaK: number) => {\n    const neighborIJK = [\n      indexIJK[0] + deltaI,\n      indexIJK[1] + deltaJ,\n      indexIJK[2] + deltaK,\n    ];\n\n    return voxelManager.getAtIJK(...neighborIJK);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n\nfunction isSegmentOnEdgeCanvas(\n  canvasPoint: Types.Point2,\n  segmentIndex: number,\n  viewport: Types.IViewport,\n  imageData: any,\n  searchRadius?: number\n): boolean {\n  const getNeighborIndex = (deltaI: number, deltaJ: number) => {\n    const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n\n    const worldPoint = viewport.canvasToWorld(neighborCanvas as Types.Point2);\n    return imageData.getScalarValueFromWorld(worldPoint);\n  };\n\n  return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { cache, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport {\n  getSegmentation,\n  getSegmentationIdRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { ContourSegmentationAnnotation, Segmentation } from '../../types';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\n\ntype Options = {\n  representationType?: SegmentationRepresentations;\n  viewport?: Types.IViewport;\n};\n\n/**\n * Get the segment at the specified world point in the viewport.\n * @param segmentationId - The ID of the segmentation to get the segment for.\n * @param worldPoint - The world point to get the segment for.\n *\n * @returns The index of the segment at the world point, or undefined if not found.\n */\nexport function getSegmentAtWorldPoint(\n  segmentationId: string,\n  worldPoint: Types.Point3,\n  options = {} as Options\n): number {\n  const segmentation = getSegmentation(segmentationId);\n\n  const representationData = segmentation.representationData;\n\n  // if representationType is not provided, we will use the first representation\n  const desiredRepresentation =\n    options?.representationType ?? Object.keys(representationData)[0];\n\n  if (!desiredRepresentation) {\n    throw new Error(\n      `Segmentation ${segmentationId} does not have any representations`\n    );\n  }\n\n  switch (desiredRepresentation) {\n    case SegmentationRepresentations.Labelmap:\n      return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);\n    case SegmentationRepresentations.Contour:\n      return getSegmentAtWorldForContour(segmentation, worldPoint, options);\n    default:\n      return;\n  }\n}\n\n/**\n * Retrieves the segment index at a given world point for a labelmap.\n *\n * @param labelmapData - The labelmap segmentation data.\n * @param worldPoint - The world point to retrieve the segment at.\n *\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForLabelmap(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number | undefined {\n  const labelmapData = segmentation.representationData.LABELMAP;\n\n  if (isVolumeSegmentation(labelmapData)) {\n    const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n    const segmentationVolume = cache.getVolume(volumeId);\n\n    if (!segmentationVolume) {\n      return;\n    }\n\n    const segmentIndex =\n      segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n\n    return segmentIndex;\n  }\n\n  // stack segmentation case\n  const { imageIdReferenceMap } = labelmapData as LabelmapSegmentationDataStack;\n\n  const currentImageId = (viewport as Types.IStackViewport).getCurrentImageId();\n\n  const segmentationImageId = imageIdReferenceMap.get(currentImageId);\n  const image = cache.getImage(segmentationImageId);\n\n  if (!image) {\n    return;\n  }\n\n  // find the first segmentationRepresentationUID for the segmentationId, since\n  // that is what we use as actorUID in the viewport\n\n  const segmentationRepresentations = getSegmentationIdRepresentations(\n    segmentation.segmentationId\n  );\n\n  const { segmentationRepresentationUID } = segmentationRepresentations[0];\n\n  const segmentationActor = viewport.getActor(segmentationRepresentationUID);\n  const imageData = segmentationActor?.actor.getMapper().getInputData();\n  const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n\n  const dimensions = imageData.getDimensions();\n  const voxelManager = (imageData.voxelManager ||\n    utilities.VoxelManager.createVolumeVoxelManager(\n      dimensions,\n      imageData.getPointData().getScalars().getData()\n    )) as utilities.VoxelManager<number>;\n\n  const segmentIndex = voxelManager.getAtIJKPoint(indexIJK as Types.Point3);\n\n  return segmentIndex;\n}\n\n/**\n * Retrieves the segment index at a given world point for contour segmentation.\n *\n * @param segmentation - The segmentation data.\n * @param worldPoint - The world point to check.\n * @param options - The options for segmentation.\n * @returns The segment index at the given world point, or undefined if not found.\n */\nexport function getSegmentAtWorldForContour(\n  segmentation: Segmentation,\n  worldPoint: Types.Point3,\n  { viewport }: Options\n): number {\n  const contourData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n  const { viewPlaneNormal } = viewport.getCamera();\n\n  for (const segmentIndex of segmentIndices) {\n    const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n\n    if (!annotationsSet) {\n      continue;\n    }\n\n    for (const annotationUID of annotationsSet) {\n      const annotation = getAnnotation(\n        annotationUID\n      ) as ContourSegmentationAnnotation;\n\n      if (!annotation) {\n        continue;\n      }\n\n      const { polyline } = annotation.data.contour;\n\n      if (\n        !utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)\n      ) {\n        continue;\n      }\n\n      // This function checks whether we are inside the contour. It does not\n      // check if we are exactly on the contour, which is highly unlikely given\n      // the canvas pixel resolution of 1 decimal place we have by design.\n      if (isPointInsidePolyline3D(worldPoint, polyline)) {\n        return Number(segmentIndex);\n      }\n    }\n  }\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getBrushToolInstances } from './utilities';\n\n/**\n * Invalidates the brush cursor for a specific tool group.\n * This function triggers the update of the brush being rendered.\n * It also triggers an annotation render for any viewports on the tool group.\n *\n * @param toolGroupId - The ID of the tool group.\n */\nexport function invalidateBrushCursor(toolGroupId: string): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n  segmentIndex?: number; // segment index to threshold\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  outputSegmentationVolume.modified();\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { getEnabledElement, type Types } from '@cornerstonejs/core';\n\nimport type { Annotation } from '../../types/AnnotationTypes';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport {\n  state as annotationState,\n  config as annotationConfig,\n} from '../../stateManagement/annotation';\nimport { jumpToSlice } from '../viewport';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\n\nexport type Segment = {\n  segmentationId: string;\n  segmentIndex: number;\n  label: string;\n\n  style?: any;\n  containedSegmentIndices?: (number) => boolean;\n};\n\nexport type SegmentContourActionConfiguration = {\n  getSegment?: (\n    enabledElement: Types.IEnabledElement,\n    configuration: SegmentContourActionConfiguration\n  ) => Segment;\n\n  /**\n   * Optional map for data about each segment\n   */\n  segmentationId?: string;\n  segmentIndex?: number;\n  segmentData?: Map<number, Segment>;\n  toolGroupId?: string;\n};\n\nexport default function segmentContourAction(\n  element: HTMLDivElement,\n  configuration\n) {\n  const { data: configurationData } = configuration;\n  const enabledElement = getEnabledElement(element);\n  const segment = (configurationData.getSegment || defaultGetSegment)(\n    enabledElement,\n    configurationData\n  );\n  if (!segment) {\n    return;\n  }\n  const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n  const segmentationsList = segmentation.state.getSegmentations();\n  const { segmentIndex, segmentationId } = segment;\n  const bidirectionals = annotationState.getAnnotations(\n    this.toolName || BidirectionalTool.toolName,\n    FrameOfReferenceUID\n  );\n  let hasExistingActiveSegment = false;\n  const existingLargestBidirectionals = bidirectionals.filter(\n    (existingBidirectionalItem) => {\n      const { segment } = existingBidirectionalItem.data;\n      if (!segment) {\n        return;\n      }\n      if (\n        segment.segmentationId === segmentationId &&\n        segment.segmentIndex === segmentIndex\n      ) {\n        hasExistingActiveSegment = true;\n        existingBidirectionalItem.data.segment = segment;\n      }\n      return !!segment;\n    }\n  );\n  if (!hasExistingActiveSegment) {\n    // Just create a dummy annotation object containing just enough information\n    // to create a real one.\n    existingLargestBidirectionals.push({\n      data: { segment },\n    } as unknown as Annotation);\n  }\n\n  let newBidirectional;\n  existingLargestBidirectionals.forEach((existingLargestBidirectional) => {\n    const segments = [];\n    const { segment: updateSegment } = existingLargestBidirectional.data;\n    const { segmentIndex, segmentationId } = updateSegment;\n    segments[segmentIndex] = updateSegment;\n    annotationState.removeAnnotation(\n      existingLargestBidirectional.annotationUID\n    );\n    const bidirectionalData = contourAndFindLargestBidirectional({\n      ...segmentationsList.find(\n        (segmentation) => segmentation.segmentationId === segmentationId\n      ),\n      segments,\n    });\n\n    if (!bidirectionalData) {\n      return;\n    }\n    const bidirectionalToolData = createBidirectionalToolData(\n      bidirectionalData,\n      enabledElement.viewport\n    );\n    bidirectionalToolData.annotationUID =\n      existingLargestBidirectional.annotationUID;\n    bidirectionalToolData.data.segment = updateSegment;\n\n    const annotationUID = annotationState.addAnnotation(\n      bidirectionalToolData,\n      FrameOfReferenceUID\n    );\n\n    if (\n      updateSegment.segmentIndex === segment.segmentIndex &&\n      updateSegment.segmentationId === segment.segmentationId\n    ) {\n      newBidirectional = bidirectionalData;\n      const { style } = segment;\n      if (style) {\n        annotationConfig.style.setAnnotationStyles(annotationUID, style);\n      }\n    }\n  });\n\n  if (newBidirectional) {\n    const { sliceIndex } = newBidirectional;\n    const imageIds = enabledElement.viewport.getImageIds();\n\n    // TODO - figure out why this is reversed\n    jumpToSlice(element, {\n      imageIndex: imageIds.length - 1 - sliceIndex,\n    });\n    enabledElement.viewport.render();\n  } else {\n    console.warn('No bidirectional found');\n  }\n\n  return newBidirectional;\n}\n\nexport function defaultGetSegment(\n  enabledElement: Types.IEnabledElement,\n  configuration: SegmentContourActionConfiguration\n): Segment {\n  const segmentationsList = segmentation.state.getSegmentations();\n  if (!segmentationsList.length) {\n    return;\n  }\n  const segmentationId =\n    configuration.segmentationId || segmentationsList[0].segmentationId;\n  const segmentIndex =\n    configuration.segmentIndex ??\n    segmentation.segmentIndex.getActiveSegmentIndex(segmentationId);\n  if (!segmentIndex) {\n    return;\n  }\n  const segmentData = configuration.segmentData?.get(segmentIndex);\n  return {\n    label: `Segment ${segmentIndex}`,\n    segmentIndex,\n    segmentationId,\n    ...segmentData,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.PixelDataTypedArray,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n  segmentIndex?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    if (insert) {\n      scalarData[index] = options.segmentIndex || 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport function getBrushToolInstances(toolGroupId: string, toolName?: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShapeIJK(\n    voxelCornersIJK,\n    dimensions\n  );\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport { roundNumber } from '../../utilities';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack) {\n    return;\n  }\n  if (!stack.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack) {\n    return;\n  }\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId: string) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture, preferSizeOverAccuracy } =\n    getCoreConfiguration().rendering;\n\n  const useNativeDataType = useNorm16Texture || preferSizeOverAccuracy;\n\n  stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNativeDataType ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      useNativeDataType,\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack) {\n    // Other viewport type - no message\n    return;\n  }\n  if (!stack.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getRenderingEngine, type Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * Triggers annotation rendering for the specified tool group IDs.\n *\n * @param toolGroupIds - An array of tool group IDs.\n */\nexport function triggerAnnotationRenderForToolGroupIds(\n  toolGroupIds: string[]\n): void {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`ToolGroup not available for ${toolGroupId}`);\n      return;\n    }\n\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n      if (!renderingEngine) {\n        console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(viewportId);\n      triggerAnnotationRender(viewport.element);\n    });\n  });\n}\n\nexport default triggerAnnotationRenderForToolGroupIds;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n  utilities,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const volumeId = utilities.getVolumeId(targetId);\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    return false;\n  }\n}\n\nexport { isViewportPreScaled };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  }\n  return {\n    numberOfSlices: viewport.getNumberOfSlices(),\n    imageIndex: viewport.getSliceIndex(),\n  };\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n    const { viewport } = this.enabledElement;\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n\n    if (colormap) {\n      this.activeColormapName = colormap.name;\n    }\n    this.showAndAutoHideTicks();\n  };\n\n  private _viewportColormapModifiedCallback = (\n    evt: Types.EventTypes.ColormapModifiedEvent\n  ) => {\n    const { viewportId, colormap, volumeId } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.activeColormapName = colormap.name;\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.COLORMAP_MODIFIED,\n      this._viewportColormapModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","/**\n * Extracts the luminance values from a specified region of an image.\n *\n * @param {Object} imageData - The image data object containing pixel information.\n * @param {Uint8Array} imageData.scalarData - The pixel data array.\n * @param {boolean} imageData.color - A flag indicating if the image is in color (true) or grayscale (false).\n * @param {number} imageData.columns - The number of columns (width) in the image.\n * @param {number} x - The x-coordinate of the top-left corner of the region.\n * @param {number} y - The y-coordinate of the top-left corner of the region.\n * @param {number} width - The width of the region.\n * @param {number} height - The height of the region.\n * @returns {number[]} An array containing the luminance values of the specified region.\n */\nfunction getLuminanceFromRegion(imageData, x, y, width, height) {\n  const luminance = [];\n  let index = 0;\n  const pixelData = imageData.scalarData;\n  let spIndex, row, column;\n\n  if (imageData.color) {\n    for (row = 0; row < height; row++) {\n      for (column = 0; column < width; column++) {\n        spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n        const red = pixelData[spIndex];\n        const green = pixelData[spIndex + 1];\n        const blue = pixelData[spIndex + 2];\n\n        luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n      }\n    }\n  } else {\n    for (row = 0; row < height; row++) {\n      for (column = 0; column < width; column++) {\n        spIndex = (row + y) * imageData.columns + (column + x);\n        luminance[index++] = pixelData[spIndex];\n      }\n    }\n  }\n\n  return luminance;\n}\n\nexport { getLuminanceFromRegion };\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n  const numPixels = pixelLuminance.length;\n  let min = globalMax;\n  let max = globalMin;\n  let sum = 0;\n\n  if (numPixels < 2) {\n    return {\n      min,\n      max,\n      mean: (globalMin + globalMax) / 2,\n    };\n  }\n\n  for (let index = 0; index < numPixels; index++) {\n    const spv = pixelLuminance[index];\n\n    min = Math.min(min, spv);\n    max = Math.max(max, spv);\n    sum += spv;\n  }\n\n  return {\n    min,\n    max,\n    mean: sum / numPixels,\n  };\n}\n\nexport { calculateMinMaxMean };\n","import {\n  VolumeViewport,\n  utilities as csUtils,\n  cache,\n  StackViewport,\n} from '@cornerstonejs/core';\n\nfunction extractWindowLevelRegionToolData(viewport) {\n  if (viewport instanceof VolumeViewport) {\n    return extractImageDataVolume(viewport);\n  }\n  if (viewport instanceof StackViewport) {\n    return extractImageDataStack(viewport);\n  }\n\n  throw new Error('Viewport not supported');\n}\n\nfunction extractImageDataVolume(viewport) {\n  const { scalarData, width, height } =\n    csUtils.getCurrentVolumeViewportSlice(viewport);\n  const { min: minPixelValue, max: maxPixelValue } =\n    csUtils.getMinMax(scalarData);\n  const volumeId = viewport.getVolumeId();\n  const volume = cache.getVolume(volumeId);\n  // @ts-ignore\n  const { metadata, cornerstoneImageMetaData } = volume;\n  const { Rows: rows, Columns: columns } = metadata;\n  const { color } = cornerstoneImageMetaData;\n  return {\n    scalarData,\n    width,\n    height,\n    minPixelValue,\n    maxPixelValue,\n    rows,\n    columns,\n    color,\n  };\n}\n\nfunction extractImageDataStack(viewport) {\n  const imageData = viewport.getImageData();\n  const { scalarData } = imageData;\n  const { min: minPixelValue, max: maxPixelValue } =\n    csUtils.getMinMax(scalarData);\n  const width = imageData.dimensions[0];\n  const height = imageData.dimensions[1];\n  const { rows, columns, color } = viewport.getCornerstoneImage();\n\n  return {\n    scalarData,\n    width,\n    height,\n    minPixelValue,\n    maxPixelValue,\n    rows,\n    columns,\n    color,\n  };\n}\n\nexport { extractWindowLevelRegionToolData };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n"],"names":["AnnotationTool","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","evt","filteredAnnotations","element","currentPoints","detail","canvasCoords","canvas","annotationsNeedToBeRedrawn","annotation","isAnnotationLocked","isAnnotationVisible","annotationUID","data","activateHandleIndex","handles","activeHandleIndex","undefined","near","this","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","highlighted","notNearToolAndMarkedActive","configuration","getTextLines","statsCalculator","createAnnotation","annotationBaseData","invalidated","metadata","toolName","text","points","Array","textBox","hasMoved","worldPosition","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","label","baseData","createAnnotationForViewport","viewport","getViewReference","createAndAddAnnotation","addAnnotation","getHandleNearImagePoint","proximity","enabledElement","getEnabledElement","isCanvasAnnotation","canvasBoundingBox","worldToCanvas","i","length","point","annotationCanvasCoordinate","slice","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","color","shadow","background","lineWidth","lineDash","isSuvScaled","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","getAnnotationStyle","context","styleSpecifier","property","locked","lineOpacity","fillColor","fillOpacity","textbox","isPointNearTool","defaultLabelmapConfig","renderOutline","outlineWidthActive","outlineWidthInactive","activeSegmentOutlineWidthDelta","renderFill","renderFillInactive","fillAlpha","fillAlphaInactive","outlineOpacity","outlineOpacityInactive","isValidLabelmapConfig","config","AnnotationFrameRange","frameRangeExtractor","imageIdToFrames","match","range","split","map","it","Number","framesToString","isArray","String","framesToImageId","newRangeString","replace","setFrameRange","eventBase","referencedImageId","eventDetail","triggerEvent","eventTarget","ANNOTATION_MODIFIED","getFrameRange","annotationHydration","worldPoints","options","viewReference","viewPlaneNormal","FrameOfReferenceUID","utilities","autoGenerated","isLocked","isVisible","getReferencedImageId","worldPos","StackViewport","getClosestImageIdForStackViewport","Error","getReferenceId","actorEntries","getActors","find","actorEntry","actor","getClassName","uid","getTargetVolumeId","getTargetId","imageVolume","imageIds","getImageIds","distanceImagePairs","imagePositionPatient","distance","ImagePositionPatient","dir","dot","Math","abs","calculateDistanceToImage","sort","a","b","boundsIJK","numSlicesToProject","sliceNormalIndex","findIndex","min","max","EPSILON","CONSTANTS","calculateBoundingBox","dimensions","isWorld","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","p","getBoundingBoxAroundShapeIJK","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","renderingEngine","calibrationOrScale","type","Enums","USER","scale","add","getStackViewports","forEach","includes","calibrateSpacing","Events","state","addToolState","viewportId","getToolState","ViewportStatus","debounced","dynamicVolumesPlayingMap","Map","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_getVolumeFromViewport","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","scroll","delta","viewportStatus","RENDERED","debounceLoading","_createStackViewportCinePlayContext","VolumeViewport","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","camera","getCamera","volumeViewPlaneNormal","direction","x","_createVolumeViewportCinePlayContext","VideoViewport","getNumberOfSlices","getSliceIndex","play","fps","setPlaybackRate","getFrameRate","_createVideoViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","id","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","reverse","loop","timeouts","isTimeVarying","vector","sample","delay","sum","limit","push","_getPlayClipTimeouts","playClipAction","newStepIndex","newStepIndexOutOfRange","CLIP_STOPPED","e","console","warn","_stopClipWithData","set","window","setTimeout","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","getToolStateByViewportId","pause","dynamicCineElement","get","delete","clearTimeout","clearInterval","volumes","filter","_getVolumesFromViewport","clip","val","low","high","addContourSegmentationAnnotation","parentAnnotationUID","segmentation","segmentationId","segmentIndex","getSegmentation","representationData","CONTOUR","annotationUIDsMap","annotationsUIDsSet","Set","areSameSegment","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","isContourSegmentationAnnotation","removeContourSegmentationAnnotation","size","polyline","closed","perimeter","point1","point2","sqrt","pow","firstPoint","lastPoint","isEqual","findHandlePolylineIndex","handleIndex","contour","handle","index","closestDistance","reduce","closestIndex","testIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","findNextLink","line","lines","contourPoints","cell","nextLine","splice","remainingLines","findContours","firstCell","shift","result","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","polyData","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","fill","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","pt","entries","newIndex","getIsPointInsidePolygon","vertices","y","inside","j","xi","yi","xj","yj","processContourHoles","contours","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","holes","hContour","hIndex","outerContour","innerContour","pointsNotEnclosed","checkEnclosed","contourHoleSet","holeIndex","contourIndex","Labelmap","SegmentationRepresentations","generateContourSetsFromLabelmap","segmentations","segments","segVolumeId","vol","numSlices","segData","imageData","getPointData","getScalars","getData","pixelsPerSlice","z","ContourSets","numSegments","segIndex","segment","sliceContours","scalars","name","numberOfComponents","dataType","containedSegmentIndices","sliceIndex","isSliceEmptyForSegment","frameStart","value","has","setValue","mSquares","imageDataCopy","shallowCopy","setScalars","setInputData","cValues","setContourValues","setMergePoints","reducedSet","getOutputData","FrameNumber","ContourSet","startIdx","endIdx","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","referenceImageId","validateAnnotation","toolClass","ContourSequence","getContourSequence","ReferencedROINumber","ROIDisplayColor","floor","random","register","RectangleROIStartEndThreshold","getContourHolesDataWorld","childAnnotationUIDs","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","numPoints","canvasHoleContour","acceptAutogeneratedInterpolations","annotationGroupSelector","selector","InterpolationManager","acceptAutoGenerated","updateContourPolyline","polylineData","transforms","canvasToWorld","targetWindingDirection","decimate","enabled","epsilon","polylineWorldPoints","currentPolylineWindingDirection","parentAnnotation","currentClosedState","lastToFirstDist","windingDirection","handlePoints","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","isInvoking","leadingEdge","Boolean","cancel","cancelAnimationFrame","cancelTimer","flush","pending","getTextBoxCoordsCanvas","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","top","bottom","_determineCorners","centerY","dynamicVolume","frames","frameNumbers","keys","maskVolumeId","imageCoordinate","segmentationVolume","dataInTime","ijkCoords","maskImageData","segScalarData","getScalarData","len","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","values","isSameVolume","JSON","stringify","spacing","indexValues","frame","activeScalarData","callback","pointLPS","segPointLPS","segValue","pointIJK","segPointIJK","overlapIJKMinMax","count","perFrameSum","averageCallback","pointInShapeCallback","averageValues","_getTimePointDataMask","coordinate","worldToIndex","yMultiple","zMultiple","allScalarData","scalarIndex","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","Float32Array","SUM","currentArray","SUBTRACT","AVERAGE","k","getAnnotationNearPoint","canvasPoint","getAnnotationNearPointOnEnabledElement","renderingEngineId","toolGroup","_toolInstances","tools","found","findAnnotationNearPointByTool","tool","annotations","getAnnotations","currentId","getCurrentImageId","CalibrationTypes","PIXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","image","calibration","hasPixelSpacing","units","areaUnits","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","getCalibratedProbeUnitsAndValue","imageIndex","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","aspect","transformWorldToIndex","getSphereBoundsInfo","circlePoints","centerWorld","radiusWorld","topLeftWorld","bottomRightWorld","getDimensions","viewUp","viewRight","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJKWithCamera","getViewportForAnnotation","viewports","intersectAABB","aabb1","aabb2","minX","maxX","minY","maxY","distanceToPointSquared","aabb","aabbWidth","aabbHeight","aabbSize","aabbCenter","translatedPoint","dx","dy","dist","distanceToPoint","PointsManager","BasicStatsCalculator","runMean","m2","pointsInShape","create3","statsInit","noPointsCollection","statsCallback","newValue","newArray","idx","delta2","getStatistics","mean","stdDev","squaredDiffSum","unit","named","singleArrayAsNumber","array","pointInEllipse","ellipse","inverts","precalculated","precalculatePointInEllipse","xRadius","yRadius","zRadius","invXRadiusSq","invYRadiusSq","invZRadiusSq","center","centerL","centerP","centerS","dz","getCanvasEllipseCorners","ellipseCanvasPoints","left","distanceToPointSquaredInfo","lineStart","lineEnd","closestPoint","distanceSquared","math","dotProduct","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","x1","y1","x2","y2","x3","y3","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","denom","num","ORIENTATION_TOLERANCE","isPointOnLineSegment","orientation","p1","p2","z1","z2","mirror","mirrorPoint","staticPoint","isClosed","numPolylinePoints","distFirstToLastPoints","containsPoint","numIntersections","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","containsPoints","numPoint","getArea","n","area","getSignedArea","refPoint","aX","aY","bX","getWindingDirection","getNormal3","vecArea","aZ","bY","bZ","_getAreaVector","getNormal2","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","r","orientationValue","getLineSegmentIntersectionsIndexes","intersections","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","currentPoint","next","getSourceAndTargetPointsList","targetPolyline","sourcePolyline","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","position","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getUnvisitedOutsidePoint","mergePolylines","targetNormal","sourceNormal","dotNormals","startPoint","mergedPolyline","subtractPolylines","subtractedPolylines","subtractedPolyline","getFirstLineSegmentIntersectionIndexes","initialI","intersectPolyline","sourceLen","intersectionPointIndexes","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","pop","endPoint","maxDistSquared","maxDistIndex","distSquared","decimatedPolyline","srcIndex","dstIndex","getLineSegmentIntersectionsCoordinates","polylineIndexes","intersection","getClosestLineSegmentIntersection","initialQ2Index","p2Index","q2Index","distances","intersectionPoints","midpoint","minDistance","indexOf","subPixelResolution","xDir","yDir","getImageData","volumeSpacing","iVector","jVector","kVector","absViewRightDotI","absViewRightDotJ","absViewRightDotK","xSpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","ySpacing","closeContourProximity","newCanvasPoint","commonData","log","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","projectTo2D","sharedDimensionIndex","testPoints","every","points2D","firstDim","secondDim","projectedPolyline","isPointInsidePolyline3D","projectedHoles","hole2D","rect","width","height","lineSegments","rectToLineSegments","Object","pointInSphere","sphere","radius","radius2","INSIDE","OUTSIDE","clipT","c","tE","tL","t","box","da","db","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","smoothAnnotation","filterAnnotationsWithinSlice","getWorldWidthAndHeightFromCorners","filterAnnotationsForDisplay","getPointInLineOfSightWithCriteria","isPlaneIntersectingAABB","filterAnnotationsWithinSamePlane","pointInShapeFn","iMin","iMax","jMin","jMax","kMin","kMax","scalarData","numComps","start","getDirection","rowCosines","columnCosines","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","currentPos","startPosJ","startPosI","pointInSurroundingSphereCallback","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","sphereCornersIJK","getBoundingBoxAroundShape","_getBounds","sphereObj","pointToString","decimals","parseFloat","toFixed","idx3","getPolyDataPointIndexes","linesData","segmentSize","findStartingPoint","key","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","cachedStats","projectionPoints","concat","rectangleCornersIJK","world","g","accumulator","currentValue","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","angle","vec","axes","axis","PI","scrollSlabs","useSlabThickness","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","newFocalPoint","newPosition","setCamera","render","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","VOLUME_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","uuidv4","ChangeTypesForInterpolation","HandlesUpdated","InterpolationUpdated","toolNames","addTool","interpolationUID","interpolationCompleted","handleAnnotationCompleted","originalToolName","viewportData","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","handleAnnotationUpdate","changeType","isInterpolationUpdate","handleAnnotationDelete","numberOfSlices","getCurrentImageIdIndex","setBrushSizeForToolGroup","toolGroupId","brushSize","getToolGroup","invalidateBrushCursor","viewportsInfo","getViewportsInfo","viewportsInfoArray","viewportIds","getViewportIds","getRenderingEngine","getBrushSizeForToolGroup","toolInstances","brushToolInstance","setBrushThresholdForToolGroup","threshold","otherArgs","isDynamic","brushBasedToolInstances","strategySpecificConfiguration","THRESHOLD","getBrushThresholdForToolGroup","isLineInSegment","isInSegment","ijk1","toIJK","ijk2","testPoint","testIJK","testSize","round","unitDelta","findLargestBidirectional","maxBidirectional","testCenter","ijk","createIsInSegment","sliceContour","bidirectional","createBidirectionalForSlice","assign","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","index1","index2","distance2","handle0","handle1","unitMajor","maxMinorPoints","majorAxis","minorAxis","contourAndFindLargestBidirectional","createBidirectionalToolData","bidirectionalData","major0","major1","minor0","minor1","createImageIdReferenceMap","imageIdsArray","segmentationImageIds","async","createLabelmapVolumeForViewport","input","getEnabledElementByIds","getDefaultActor","properties","volumeLoader","labelmaps","origin","labelmap","outputData","arrayType","lpad","string","character","join","getter","seed","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","parseInt","toString","permute","perm","countNonZeroes","prunedPermutations","stack","flooded","visits","bounds","currentArgs","flood","boundaries","from","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getDefaultRepresentationConfig","representationType","getHoveredContourSegmentationAnnotation","annotationUIDs","getSegmentAtLabelmapBorder","worldPoint","searchRadius","labelmapData","LABELMAP","getScalarValueFromWorld","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","imageIdReferenceMap","segmentationImageId","getImage","segmentationRepresentations","getSegmentationIdRepresentations","segmentationRepresentationUID","segmentationActor","getActor","getMapper","getInputData","indexIJK","voxelManager","createVolumeVoxelManager","getAtIJKPoint","deltaK","neighborIJK","getAtIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","getSegmentAtWorldPoint","desiredRepresentation","getSegmentAtWorldForLabelmap","Contour","contourData","segmentIndices","annotationsSet","getSegmentAtWorldForContour","isValidRepresentationConfig","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","modified","segmentContourAction","configurationData","getSegment","defaultGetSegment","getFrameOfReferenceUID","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","style","setAnnotationStyles","jumpToSlice","segmentData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","volumeInfo","volumeSize","referenceValues","lower","upper","_handleSameSizeVolume","total","overlaps","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","triggerSegmentationDataModified","segmentationImageData","overwrite","testOverlapRange","voxelSpacing","voxelCenter","testRange","computeOffsetIndex","insert","getBrushToolInstances","toolInstance","equalsCheck","getVoxelOverlap","voxelCornersWorld","voxelCornersIJK","processVolumes","segmentationSpacing","resetPrefetchTimeout","maxImagesToPrefetch","preserveExistingPool","resetPrefetchDelay","prefetch","stackPrefetchData","stackPrefetch","currentImageIdIndex","indicesToRequest","removeFromList","imageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","preferSizeOverAccuracy","rendering","useNativeDataType","targetBuffer","preScale","requestType","addRequest","bind","onImageUpdated","target","error","enable","indexOfCurrentImage","removeEventListener","STACK_NEW_IMAGE","addEventListener","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","disable","getConfiguration","setConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","filterRequests","then","getCachedImageBasedOnImageURI","stats","decodeTimeInMS","loadTimeInMS","sizeInBytes","usage","getMaxCacheSize","cacheFill","fillTime","fillSize","roundNumber","initialTime","initialSize","updateToolState","doneCallback","stackCount","totalBytes","positionFraction","minIndex","maxIndex","getDeltaPoints","lastPoints","curr","getMeanPoints","last","page","_subtractPoints2D","client","point0","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","parse","copyPoints","prev","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","rotationAngle","pairedDistance","toolGroupIds","viewportInfo","getViewport","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vp","Active","Passive","Enabled","ToolModes","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolOptions","toolMode","mode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","getViewports","isViewportPreScaled","scaled","currentImageIndex","_getImageSliceData","lastSliceIndex","_getImageIndexToJump","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","isRangeValid","isColorbarSizeValid","areColorbarRangesEqual","areColorbarSizesEqual","clamp","ColorbarCanvas","props","validateProps","colormap","imageRange","voiRange","container","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_setCanvasSize","showFullImageRange","appendChild","dispose","parentElement","removeChild","document","createElement","pointerEvents","boxSizing","isConnected","RGBPoints","rgbPoints","colorsCount","getColorPoint","offset","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","ticks","ticksProps","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","ColorbarRangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","visible","display","_getTicks","roughStep","stepPower","log10","roughtStepNormalized","step","scaleMax","scaleMin","ticksCount","_getLeftTickInfo","labelMeasure","labelPoint","tickPoints","end","_getRightTickInfo","_getTopTickInfo","_getBottomTickInfo","maxCanvasPixelValue","rangeWidth","clearRect","textBaseline","strokeStyle","tick","measureText","tickInfo","Top","Left","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","stroke","Widget","_containerResizeCallback","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","rootElement","resizeObserver","currentContainer","unobserve","observe","destroy","disconnect","containerSize","classList","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","stopPropagation","_mouseOutCallback","hideTicks","_mouseDownCallback","_addVOIEventListeners","_mouseDragCallback","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startPoints","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","windowCenter","newVoiRange","preventDefault","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","activeColormapName","colormapName","currentVoiRange","onVoiChange","reset","updateTicksBar","colormaps","items","item","Name","some","cm","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","ticksBarTop","ticksBarLeft","manager","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","clientWidth","clientHeight","ptMultiplier","isPreScaled","fixedPTWindowWidth","xMultiplier","setProperties","viewportsContainingVolumeUID","getRange","volumeActor","getProperty","getRGBTransferFunction","interval","IMAGE_VOLUME_MODIFIED","VOI_MODIFIED","COLORMAP_MODIFIED","getLuminanceFromRegion","luminance","pixelData","spIndex","row","column","columns","red","green","blue","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","minPixelValue","maxPixelValue","getVolumeId","cornerstoneImageMetaData","Rows","rows","Columns","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","ids","pixelScalars","pixelPts","edgeLocator","newInstance","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","xyz","pId","pixelLines","getCase","eid","edgeVerts","getEdge","mergePoints","isInsertedEdge","x0","insertEdge","requestData","inData","outData","getOrigin","extent","getExtent","computeIncrements","getKernels","cv","initialize","polydata","setData","Uint32Array","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","obj","algo","setGet","vtkImageMarchingSquares$1"],"sourceRoot":""}