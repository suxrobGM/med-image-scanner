{"version":3,"file":"8993.bundle.c53aa9e510ad62fd57c7.js","mappings":"kHAGA,MAkQA,EAlQ8B,CAC5B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,C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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/src/constants/COLOR_LUT.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/elementCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/MouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/ImageMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGMouseCursor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/setCursorForElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/_getHash.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setAttributesIfNecessary.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/setNewAttributesIfValid.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawCircle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipseByCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawEllipse.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHandles.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLine.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawHeight.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPolyline.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawPath.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLink.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawLinkedTextBox.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRectByCoordinates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawArrow.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/drawRedactionRect.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ChangeTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/SegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/StrategyCallbacks.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/Touch.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolBindings.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/AnnotationStyleStates.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/WorkerTypes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/mouseToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/touchToolEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/annotationInterpolationEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventDispatchers/cameraResetEventDispatcher.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/mouse/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/touch/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/wheel/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/segmentation/imageChangeEventListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationCompletedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationSelectionListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationModifiedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/annotationRemovedListener.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/init.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/AnnotationGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationSelection.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/annotationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/ToolStyle.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getFont.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/getState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/config/helpers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/annotation/helpers/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/activeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/clipAndCacheSurfacesForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/getRepresentationSpecificConfig.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/addRepresentationData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertStackToVolumeSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/convertVolumeToStackSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentLocking.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/config/segmentationColor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/computeAndAddRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertContourToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/convertSurfaceToLabelmap.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/labelmapComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/extractContourData.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/utils/createAndAddContourSegmentationsFromClippedSurfaces.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/contourComputationStrategies.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/polySeg/registerPolySegWorker.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentIndex.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/SegmentationStateManager.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/segmentationState.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/Synchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/createSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/getAllSynchronizers.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/SynchronizerManager/destroySynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/addEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/removeEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/cancelActiveManipulations.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/state.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/svgNodeCache.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/cameraSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/presentationViewSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createPresentationViewSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/voiSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/imageSliceSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createImageSliceSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/callbacks/slabThicknessSyncCallback.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/synchronizers/createSlabThicknessSynchronizer.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/synchronizers/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AdvancedMagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/AnnotationEraserTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/CrosshairsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MIPJumpToClickTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/MagnifyTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OrientationMarkerTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/OverlayGridTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PanTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/PlanarRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceCursors.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ReferenceLinesTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ScaleOverlayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/SculptorTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/SegmentationIntersectionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/StackScrollToolMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/TrackballRotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/VolumeRotateMouseWheelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/WindowLevelRegionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/WindowLevelTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/ZoomTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/AngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ArrowAnnotateTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CircleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/CobbAngleTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/DragProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/EllipticalROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/HeightTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/KeyImageTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LengthTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/LivewireContourTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/ProbeTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/RectangleROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineContourSegmentationTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/SplineROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/UltrasoundDirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/VideoRedactionTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/AnnotationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/base/BaseTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/BrushTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/CircleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/PaintFillTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SegmentSelectTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/SphereScissorsTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/strategies/utils/stackVolumeCheck.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/types/ContourAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/getViewportsForAnnotation.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/math/vec2/findClosestPoint.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/getUniqueSegmentIndices.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/segmentation/triggerSegmentationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRender.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/triggerAnnotationRenderForViewportIds.ts"],"sourcesContent":["/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Height: extend(BASE, {\n    iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipseByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  canvasCoordinates: [Types.Point2, Types.Point2, Types.Point2, Types.Point2],\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [bottom, top, left, right] = canvasCoordinates;\n\n  const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n  const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n  const angle =\n    (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n\n  const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipseByCoordinates;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n) {\n  const top: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n  const bottom: Types.Point2 = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n  const left: Types.Point2 = [corner1[0], (corner1[1] + corner2[1]) / 2];\n  const right: Types.Point2 = [corner2[0], (corner1[1] + corner2[1]) / 2];\n\n  drawEllipseByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    ellipseUID,\n    [bottom, top, left, right],\n    (options = {}),\n    (dataId = '')\n  );\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handle: Types.Point2,\n  options = {},\n  uniqueIndex\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(\n    annotationUID,\n    'handle',\n    `hg-${handleGroupUID}-index-${uniqueIndex}`\n  );\n\n  let attributes;\n  if (type === 'circle') {\n    attributes = {\n      cx: `${handle[0]}`,\n      cy: `${handle[1]}`,\n      r: handleRadius,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      opacity: opacity,\n    };\n  } else if (type === 'rect') {\n    const handleRadiusFloat = parseFloat(handleRadius);\n    const side = handleRadiusFloat * 1.5;\n    const x = handle[0] - side * 0.5;\n    const y = handle[1] - side * 0.5;\n\n    attributes = {\n      x: `${x}`,\n      y: `${y}`,\n      width: `${side}`,\n      height: `${side}`,\n      stroke: color,\n      fill,\n      'stroke-width': strokeWidth,\n      rx: `${side * 0.1}`,\n      opacity: opacity,\n    };\n  } else {\n    throw new Error(`Unsupported handle type: ${type}`);\n  }\n\n  const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  if (existingHandleElement) {\n    setAttributesIfNecessary(attributes, existingHandleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newHandleElement = document.createElementNS(svgns, type);\n\n    setNewAttributesIfValid(attributes, newHandleElement);\n\n    svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n  }\n}\n\nexport default drawHandle;\n","import type { Types } from '@cornerstonejs/core';\n\nimport { SVGDrawingHelper } from '../types';\nimport drawHandle from './drawHandle';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  handlePoints.forEach((handle, i) => {\n    drawHandle(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      handle,\n      options,\n      i\n    );\n  });\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawHeight(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  heightUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // Drawing the head height with three lines\n  // Variables to be used when creating the height\n  const midX = end[0] + (start[0] - end[0]) / 2;\n  const endfirstLine = [midX, start[1]] as Types.Point2;\n  const endsecondLine = [midX, end[1]] as Types.Point2;\n\n  const firstLine = {\n    start: start,\n    end: endfirstLine,\n  };\n\n  const secondLine = {\n    start: endfirstLine,\n    end: endsecondLine,\n  };\n\n  const threeLine = {\n    start: endsecondLine,\n    end: end,\n  };\n\n  //1\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '1',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  //2\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  //3\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    threeLine.start,\n    threeLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `closePath` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n  }\n\n  if (closePath) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG path with the given points.\n *\n * The `closePath` option, if true, draws a closed path (last point\n * connected to the first).\n */\nexport default function drawPath(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  pathUID: string,\n  points: Types.Point2[] | Types.Point2[][],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    closePath?: boolean;\n  }\n): void {\n  // It may be a polyline with holes that will be an array with multiple\n  // 'points' arrays\n  const hasSubArrays =\n    points.length && points[0].length && Array.isArray(points[0][0]);\n\n  const pointsArrays = hasSubArrays ? points : [points];\n  const {\n    color = 'rgb(0, 255, 0)',\n    width = 10,\n    fillColor = 'none',\n    fillOpacity = 0,\n    lineWidth,\n    lineDash,\n    closePath = false,\n  } = options;\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n  const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n  let pointsAttribute = '';\n\n  for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n    const points = pointsArrays[i];\n    const numPoints = points.length;\n\n    if (numPoints < 2) {\n      continue;\n    }\n\n    for (let j = 0; j < numPoints; j++) {\n      const point = points[j];\n      const cmd = j ? 'L' : 'M';\n\n      pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(\n        1\n      )} `;\n    }\n\n    if (closePath) {\n      pointsAttribute += 'Z ';\n    }\n  }\n\n  if (!pointsAttribute) {\n    return;\n  }\n\n  const attributes = {\n    d: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingNode) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingNode);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newNode = document.createElementNS(svgns, 'path');\n\n    setNewAttributesIfValid(attributes, newNode);\n    svgDrawingHelper.appendNode(newNode, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawRectByCoordinates(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  canvasCoordinates: Types.Point2[],\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\n\n  const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\n  const height = Math.hypot(\n    topLeft[0] - bottomLeft[0],\n    topLeft[1] - bottomLeft[1]\n  );\n\n  const center = [\n    (bottomRight[0] + topLeft[0]) / 2,\n    (bottomRight[1] + topLeft[1]) / 2,\n  ];\n  const leftEdgeCenter = [\n    (bottomLeft[0] + topLeft[0]) / 2,\n    (bottomLeft[1] + topLeft[1]) / 2,\n  ];\n  const angle =\n    (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\n      180) /\n    Math.PI;\n\n  const attributes = {\n    x: `${center[0] - width / 2}`,\n    y: `${center[1] - height / 2}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport { SVGDrawingHelper } from '../types';\nimport drawRectByCoordinates from './drawRectByCoordinates';\n\n// This method is obsolete due to not supporting rotation tool. Please use drawRectByCoordinates instead.\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const topLeft: Types.Point2 = [start[0], start[1]];\n  const topRight: Types.Point2 = [end[0], start[1]];\n  const bottomLeft: Types.Point2 = [start[0], end[1]];\n  const bottomRight: Types.Point2 = [end[0], end[1]];\n\n  drawRectByCoordinates(\n    svgDrawingHelper,\n    annotationUID,\n    rectangleUID,\n    [topLeft, topRight, bottomLeft, bottomRight],\n    options,\n    dataId\n  );\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'rgb(0, 255, 0)',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","/**\n * ChangeTypes defines the types of changes occurring on annotation and\n * segmentation data.\n */\nenum ChangeTypes {\n  /**\n   * Interaction events are done when the user is actively interacting with\n   * an annotation, and probably means the event shouldn't be handled/used.\n   */\n  Interaction = 'Interaction',\n  /**\n   * HandlesUpdated occurs when the handle data is added or removed, or moved around\n   */\n  HandlesUpdated = 'HandlesUpdated',\n  /**\n   * StatsUpdated occurs when the stats are updated/calculated.  This can be used\n   * to ignore stats calculations changes occurring on initial load, while still\n   * rendering other updates.\n   */\n  StatsUpdated = 'StatsUpdated',\n  /**\n   * InitialSetup occurs when an annotation has been created initially and\n   * has the first render/data calculation being applied.\n   */\n  InitialSetup = 'InitialSetup',\n  /**\n   * Completed occurs only for the annotation completed event, just to identify it\n   */\n  Completed = 'Completed',\n  /**\n   * Occurs when an interpolation result is updated with more tool specific data.\n   */\n  InterpolationUpdated = 'InterpolationUpdated',\n}\n\nexport default ChangeTypes;\n","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  // fired when a viewport is added to the toolGroup\n  TOOLGROUP_VIEWPORT_ADDED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED',\n\n  // fired when a viewport is removed from the toolGroup\n  TOOLGROUP_VIEWPORT_REMOVED = 'CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when an annotation interpolation process completed.\n   * Make use of {@link EventTypes.AnnotationInterpolationCompletedEventType | Annotation Interpolation process Completed Event Type}\n   * for typing your event listeners for this annotation interpolation complete event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationCompletedEventDetail | Annotation interpolation process Event Detail}.\n   */\n  ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when interpolated annotations are removed.\n   * Make use of {@link EventTypes.AnnotationInterpolationRemovedEventType | Annotation Interpolation Removed Event Type}\n   * for typing your event listeners for this interpolated annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationInterpolationRemovedEventDetail | Annotation interpolation removed Event Detail}.\n   */\n  INTERPOLATED_ANNOTATIONS_REMOVED = 'CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","/**\n * Defines the names of the strategy callbacks used for performing enhanced\n * strategy operations.\n */\nenum StrategyCallbacks {\n  /**\n   * startStrategy is called at the start of a strategy, typically on mouse down\n   * Note this is separate from preview and the endings for preview, which could\n   * be called alternatively, but this may be nested within a preview.\n   */\n  OnInteractionStart = 'onInteractionStart',\n  /**\n   * finishStrategy is called at the end of a strategy being applied, usually on\n   * mouse up.\n   */\n  OnInteractionEnd = 'onInteractionEnd',\n  /**\n   * The preview can be used for tools to show what would happen on accepting\n   * before the change is actually done.  For example, a spline tool might\n   * show a preview state, and allow that to be accepted or rejected.\n   */\n  Preview = 'preview',\n  RejectPreview = 'rejectPreview',\n  AcceptPreview = 'acceptPreview',\n\n  /**\n   * Fills the given reygion\n   */\n  Fill = 'fill',\n\n  /**\n   * The default strategy function, often synonymous with fill\n   */\n  StrategyFunction = 'strategyFunction',\n\n  /**\n   * For threshold functions, this creates the thresold test.  Mostly an internal\n   * detail, but might be useful to share between strategies.\n   */\n  CreateIsInThreshold = 'createIsInThreshold',\n\n  /**\n   *  Some strategy functions need to initialize some data before being runnable.\n   * This is mostly an internal detail, just useful to have an enum here for this.\n   */\n  Initialize = 'initialize',\n\n  // Internal Details\n  INTERNAL_setValue = 'setValue',\n\n  /** inner circle size  */\n  ComputeInnerCircleRadius = 'computeInnerCircleRadius',\n}\n\nexport default StrategyCallbacks;\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n * AutoGenerated:\n *   The annotation has been auto generated;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n  AutoGenerated = 'AutoGenerated',\n}\n\nexport default AnnotationStyleStates;\n","/**\n * Worker Types are used to define the types the worker that is getting performed\n */\nenum ChangeTypes {\n  POLYSEG_CONTOUR_TO_LABELMAP = 'polySeg/convertContourToVolumeLabelmap',\n\n  POLYSEG_SURFACE_TO_LABELMAP = 'polySeg/convertSurfacesToVolumeLabelmap',\n\n  POLYSEG_CONTOUR_TO_SURFACE = 'polySeg/convertContourToSurface',\n\n  POLYSEG_LABELMAP_TO_SURFACE = 'polySeg/convertLabelmapToSurface',\n\n  SURFACE_CLIPPING = 'surfaceClipping',\n}\n\nexport default ChangeTypes;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\n\n/**\n * The enable and disable add/remove the event listeners that dispatch the\n * required events to the interpolation manager.\n */\nconst enable = function () {\n  eventTarget.addEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.addEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nconst disable = function () {\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_COMPLETED,\n    InterpolationManager.handleAnnotationCompleted as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_MODIFIED,\n    InterpolationManager.handleAnnotationUpdate as EventListener\n  );\n  eventTarget.removeEventListener(\n    Events.ANNOTATION_REMOVED,\n    InterpolationManager.handleAnnotationDelete as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is reset, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraReset` method, we call it.\n *\n * @param evt - The normalized camera reset event.\n */\nconst onCameraReset = function (evt: Types.EventTypes.CameraResetEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onResetCamera) {\n      tool.onResetCamera(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import {\n  getEnabledElement,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport {\n  math,\n  triggerAnnotationRenderForViewportIds,\n} from '../../../utilities';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAllAnnotations,\n  getChildAnnotations,\n  addChildAnnotation,\n  clearParentAnnotation,\n} from '../../../stateManagement/annotation/annotationState';\nimport {\n  AnnotationCompletedEventType,\n  ContourAnnotationCompletedEventDetail,\n} from '../../../types/EventTypes';\nimport * as contourUtils from '../../../utilities/contours';\nimport * as contourSegUtils from '../../../utilities/contourSegmentation';\nimport { ToolGroupManager, hasTool as cstHasTool } from '../../../store';\nimport { PlanarFreehandContourSegmentationTool } from '../../../tools';\nimport type { Annotation } from '../../../types';\nimport type { ContourAnnotation } from '../../../types/ContourAnnotation';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\n\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\n\nexport default async function contourSegmentationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const sourceAnnotation = evt.detail\n    .annotation as ContourSegmentationAnnotation;\n\n  if (!contourSegUtils.isContourSegmentationAnnotation(sourceAnnotation)) {\n    return;\n  }\n\n  const viewport = getViewport(sourceAnnotation);\n  const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(\n    viewport,\n    sourceAnnotation\n  );\n\n  if (!contourSegmentationAnnotations.length) {\n    return;\n  }\n\n  const sourcePolyline = convertContourPolylineToCanvasSpace(\n    sourceAnnotation.data.contour.polyline,\n    viewport\n  );\n\n  const targetAnnotationInfo = findIntersectingContour(\n    viewport,\n    sourcePolyline,\n    contourSegmentationAnnotations\n  );\n\n  if (!targetAnnotationInfo) {\n    return;\n  }\n\n  const { targetAnnotation, targetPolyline, isContourHole } =\n    targetAnnotationInfo;\n\n  if (isContourHole) {\n    const { contourHoleProcessingEnabled = false } =\n      evt.detail as ContourAnnotationCompletedEventDetail;\n\n    // Do not create holes when contourHoleProcessingEnabled is `false`\n    if (!contourHoleProcessingEnabled) {\n      return;\n    }\n\n    createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n  } else {\n    combinePolylines(\n      viewport,\n      targetAnnotation,\n      targetPolyline,\n      sourceAnnotation,\n      sourcePolyline\n    );\n  }\n}\n\nfunction isFreehandContourSegToolRegisteredForViewport(\n  viewport: Types.IViewport,\n  silent = false\n) {\n  const { toolName } = PlanarFreehandContourSegmentationTool;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewport.id,\n    viewport.renderingEngineId\n  );\n\n  let errorMessage;\n\n  if (!toolGroup.hasTool(toolName)) {\n    errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n  } else if (!toolGroup.getToolOptions(toolName)) {\n    errorMessage = `Tool ${toolName} must be in active/passive state`;\n  }\n\n  if (errorMessage && !silent) {\n    console.warn(errorMessage);\n  }\n\n  return !errorMessage;\n}\n\nfunction getViewport(annotation: Annotation) {\n  const viewports = getViewportsForAnnotation(annotation);\n  const viewportWithToolRegistered = viewports.find((viewport) =>\n    isFreehandContourSegToolRegisteredForViewport(viewport, true)\n  );\n\n  // Returns the first viewport even if freehand contour segmentation is not\n  // registered because it can be used to project the polyline to create holes.\n  // Another verification is done before appending/removing contours which is\n  // possible only when the tool is registered.\n  return viewportWithToolRegistered ?? viewports[0];\n}\n\nfunction convertContourPolylineToCanvasSpace(\n  polyline: Types.Point3[],\n  viewport: Types.IViewport\n): Types.Point2[] {\n  const numPoints = polyline.length;\n  const projectedPolyline = new Array(numPoints);\n\n  for (let i = 0; i < numPoints; i++) {\n    projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n  }\n\n  return projectedPolyline;\n}\n\nfunction getValidContourSegmentationAnnotations(\n  viewport: Types.IViewport,\n  sourceAnnotation: ContourSegmentationAnnotation\n): ContourSegmentationAnnotation[] {\n  const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n\n  // Get all annotations and filter all contour segmentations locally\n  const allAnnotations = getAllAnnotations();\n  return allAnnotations.filter(\n    (targetAnnotation) =>\n      targetAnnotation.annotationUID &&\n      targetAnnotation.annotationUID !== sourceAnnotationUID &&\n      contourSegUtils.isContourSegmentationAnnotation(targetAnnotation) &&\n      contourSegUtils.areSameSegment(targetAnnotation, sourceAnnotation) &&\n      viewport.isReferenceViewable(targetAnnotation.metadata)\n  ) as ContourSegmentationAnnotation[];\n}\n\n/**\n * Finds other contours on the same slice which intersect the source polyline,\n * represented as canvas points.\n */\nfunction findIntersectingContour(\n  viewport: Types.IViewport,\n  sourcePolyline: Types.Point2[],\n  contourSegmentationAnnotations: ContourSegmentationAnnotation[]\n): {\n  targetAnnotation: ContourSegmentationAnnotation;\n  targetPolyline: Types.Point2[];\n  isContourHole: boolean;\n} {\n  const sourceAABB = math.polyline.getAABB(sourcePolyline);\n\n  for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n    const targetAnnotation = contourSegmentationAnnotations[i];\n    const targetPolyline = convertContourPolylineToCanvasSpace(\n      targetAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    const lineSegmentsIntersect =\n      aabbIntersect &&\n      math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole =\n      aabbIntersect &&\n      !lineSegmentsIntersect &&\n      math.polyline.containsPoints(targetPolyline, sourcePolyline);\n\n    if (lineSegmentsIntersect || isContourHole) {\n      return { targetAnnotation, targetPolyline, isContourHole };\n    }\n  }\n}\n\n/**\n * Modifies the holeAnnotation to work as a contour hole in the targetAnnotation,\n * displayed on the given viewport.\n\n */\nexport function createPolylineHole(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  holeAnnotation: ContourSegmentationAnnotation\n) {\n  const { windingDirection: targetWindingDirection } =\n    targetAnnotation.data.contour;\n  const { windingDirection: holeWindingDirection } =\n    holeAnnotation.data.contour;\n\n  addChildAnnotation(targetAnnotation, holeAnnotation);\n  contourSegUtils.removeContourSegmentationAnnotation(holeAnnotation);\n\n  const { contour: holeContour } = holeAnnotation.data;\n  const holePolyline = convertContourPolylineToCanvasSpace(\n    holeContour.polyline,\n    viewport\n  );\n\n  // Calling `updateContourPolyline` method instead of reversing the polyline\n  // locally because it is also responsible for checking/fixing the winding direction.\n  contourUtils.updateContourPolyline(\n    holeAnnotation,\n    {\n      points: holePolyline,\n      closed: holeContour.closed,\n    },\n    viewport\n  );\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine } = enabledElement;\n\n  // Updating a Spline contours, for example, should also update freehand contours\n  const updatedToolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    holeAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedToolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n}\n\nfunction getContourHolesData(\n  viewport: Types.IViewport,\n  annotation: ContourAnnotation\n) {\n  return getChildAnnotations(annotation).map((holeAnnotation) => {\n    const polyline = convertContourPolylineToCanvasSpace(\n      holeAnnotation.data.contour.polyline,\n      viewport\n    );\n\n    return { annotation: holeAnnotation, polyline };\n  });\n}\n\nfunction combinePolylines(\n  viewport: Types.IViewport,\n  targetAnnotation: ContourSegmentationAnnotation,\n  targetPolyline: Types.Point2[],\n  sourceAnnotation: ContourSegmentationAnnotation,\n  sourcePolyline: Types.Point2[]\n) {\n  if (!cstHasTool(PlanarFreehandContourSegmentationTool)) {\n    console.warn(\n      `${PlanarFreehandContourSegmentationTool.toolName} is not registered in cornerstone`\n    );\n    return;\n  }\n\n  // Cannot append/remove an annotation if it will not be available on any viewport\n  if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\n    return;\n  }\n\n  const sourceStartPoint = sourcePolyline[0];\n  const mergePolylines = math.polyline.containsPoint(\n    targetPolyline,\n    sourceStartPoint\n  );\n\n  const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n  const unassignedContourHolesSet = new Set(contourHolesData);\n  const reassignedContourHolesMap = new Map();\n  const assignHoleToPolyline = (parentPolyline, holeData) => {\n    let holes = reassignedContourHolesMap.get(parentPolyline);\n\n    if (!holes) {\n      holes = [];\n      reassignedContourHolesMap.set(parentPolyline, holes);\n    }\n\n    holes.push(holeData);\n    unassignedContourHolesSet.delete(holeData);\n  };\n  const newPolylines = [];\n\n  if (mergePolylines) {\n    const mergedPolyline = math.polyline.mergePolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    newPolylines.push(mergedPolyline);\n\n    // Keep all holes because the contour can only grow when merging and there\n    // is no chance for any hole to be removed\n    Array.from(unassignedContourHolesSet.keys()).forEach((holeData) =>\n      assignHoleToPolyline(mergedPolyline, holeData)\n    );\n  } else {\n    const subtractedPolylines = math.polyline.subtractPolylines(\n      targetPolyline,\n      sourcePolyline\n    );\n\n    subtractedPolylines.forEach((newPolyline) => {\n      newPolylines.push(newPolyline);\n\n      Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n        const containsHole = math.polyline.containsPoints(\n          newPolyline,\n          holeData.polyline\n        );\n\n        if (containsHole) {\n          assignHoleToPolyline(newPolyline, holeData);\n          unassignedContourHolesSet.delete(holeData);\n        }\n      });\n    });\n  }\n\n  // Make sure the holes that will be added to the new annotation are not\n  // associated to the target annotation that will be deleted\n  Array.from(reassignedContourHolesMap.values()).forEach(\n    (contourHolesDataArray) =>\n      contourHolesDataArray.forEach((contourHoleData) =>\n        clearParentAnnotation(contourHoleData.annotation)\n      )\n  );\n\n  const { element } = viewport;\n  const enabledElement = getEnabledElement(element);\n  const { metadata, data } = targetAnnotation;\n  const { handles, segmentation } = data;\n  const { textBox } = handles;\n\n  removeAnnotation(sourceAnnotation.annotationUID);\n  removeAnnotation(targetAnnotation.annotationUID);\n\n  for (let i = 0; i < newPolylines.length; i++) {\n    const polyline = newPolylines[i];\n    const startPoint = viewport.canvasToWorld(polyline[0]);\n    const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation: ContourSegmentationAnnotation = {\n      metadata: {\n        ...metadata,\n        toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n        originalToolName: metadata.originalToolName || metadata.toolName,\n      },\n      data: {\n        cachedStats: {},\n        handles: {\n          points: [startPoint, endPoint],\n          textBox: textBox ? { ...textBox } : undefined,\n        },\n        contour: {\n          polyline: [],\n          closed: true,\n        },\n        spline: targetAnnotation.data.spline,\n        segmentation: {\n          ...segmentation,\n        },\n      },\n      annotationUID: csUtils.uuidv4() as string,\n      highlighted: true,\n      invalidated: true,\n      isLocked: false,\n      isVisible: undefined,\n      // Allow this object to be interpolated against the original interpolation\n      // data.\n      interpolationUID: targetAnnotation.interpolationUID,\n      interpolationCompleted: targetAnnotation.interpolationCompleted,\n    };\n\n    // Calling `updateContourPolyline` method instead of setting it locally\n    // because it is also responsible for checking/fixing the winding direction.\n    contourUtils.updateContourPolyline(\n      newAnnotation,\n      {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n      },\n      viewport\n    );\n\n    addAnnotation(newAnnotation, element);\n    contourSegUtils.addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation, viewport.element);\n\n    reassignedContourHolesMap\n      .get(polyline)\n      ?.forEach((holeData) =>\n        addChildAnnotation(newAnnotation, holeData.annotation)\n      );\n  }\n\n  updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\n}\n\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\n  const { viewport } = enabledElement;\n  const { element } = viewport;\n  const { renderingEngine } = enabledElement;\n\n  const updatedTtoolNames = new Set([\n    DEFAULT_CONTOUR_SEG_TOOLNAME,\n    targetAnnotation.metadata.toolName,\n    sourceAnnotation.metadata.toolName,\n  ]);\n\n  for (const toolName of updatedTtoolNames.values()) {\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      toolName\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import {\n  cache,\n  getEnabledElementByIds,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../../types/EventTypes';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../types/LabelmapTypes';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onLabelmapSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  const labelmapRepresentationData = representationData[type];\n\n  if ('volumeId' in labelmapRepresentationData) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    performVolumeLabelmapUpdate({\n      modifiedSlicesToUse,\n      representationData,\n      type,\n    });\n  }\n\n  if ('imageIdReferenceMap' in labelmapRepresentationData) {\n    // get the stack from cache, we need the imageData to be updated to GPU\n    performStackLabelmapUpdate({\n      toolGroupIds,\n      segmentationId,\n      representationData,\n      type,\n    });\n  }\n};\n\nfunction performVolumeLabelmapUpdate({\n  modifiedSlicesToUse,\n  representationData,\n  type,\n}) {\n  const segmentationVolume = cache.getVolume(\n    (representationData[type] as LabelmapSegmentationDataVolume).volumeId\n  );\n\n  if (!segmentationVolume) {\n    console.warn('segmentation not found in cache');\n    return;\n  }\n\n  const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n  // Update the texture for the volume in the GPU\n  let slicesToUpdate;\n  if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n    slicesToUpdate = modifiedSlicesToUse;\n  } else {\n    const numSlices = imageData.getDimensions()[2];\n    slicesToUpdate = [...Array(numSlices).keys()];\n  }\n\n  slicesToUpdate.forEach((i) => {\n    vtkOpenGLTexture.setUpdatedFrame(i);\n  });\n\n  // Trigger modified on the imageData to update the image\n  imageData.modified();\n}\n\nfunction performStackLabelmapUpdate({\n  toolGroupIds,\n  segmentationId,\n  representationData,\n  type,\n}) {\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      SegmentationState.getSegmentationRepresentations(toolGroupId);\n\n    const toolGroup = getToolGroup(toolGroupId);\n    const viewportsInfo = toolGroup.getViewportsInfo();\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId !== segmentationId) {\n        return;\n      }\n\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        ).viewport;\n\n        if (viewport instanceof VolumeViewport) {\n          return;\n        }\n\n        const actorEntry = viewport.getActor(\n          representation.segmentationRepresentationUID\n        );\n\n        if (!actorEntry) {\n          return;\n        }\n\n        const currentImageId = viewport.getCurrentImageId();\n\n        const segImageData = actorEntry.actor.getMapper().getInputData();\n\n        const { imageIdReferenceMap } = representationData[\n          type\n        ] as LabelmapSegmentationDataStack;\n\n        const currentSegmentationImageId =\n          imageIdReferenceMap.get(currentImageId);\n\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        segImageData.modified();\n\n        // update the cache with the new image data\n        csUtils.updateVTKImageDataWithCornerstoneImage(\n          segImageData,\n          segmentationImage\n        );\n      });\n    });\n  });\n}\n\nexport default onLabelmapSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n  const { type } = SegmentationState.getSegmentation(segmentationId);\n\n  const toolGroupIds =\n    SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    onLabelmapSegmentationDataModified(evt);\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Enums,\n  getEnabledElementByIds,\n  cache,\n  utilities,\n  Types,\n} from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\n\nconst enable = function (element: HTMLDivElement): void {\n  const { viewport } = getEnabledElement(element);\n\n  if (viewport instanceof BaseVolumeViewport) {\n    return;\n  }\n\n  element.addEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  // this listener handles the segmentation modifications\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.STACK_NEW_IMAGE,\n    _imageChangeEventListener as EventListener\n  );\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    _imageChangeEventListener as EventListener\n  );\n};\n\nconst perToolGroupManualTriggers = new Map();\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nfunction _imageChangeEventListener(evt) {\n  const eventData = evt.detail;\n  const { viewportId, renderingEngineId } = eventData;\n  const { viewport } = getEnabledElementByIds(\n    viewportId,\n    renderingEngineId\n  ) as { viewport: Types.IStackViewport };\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (!toolGroup) {\n    return;\n  }\n\n  let toolGroupSegmentationRepresentations =\n    SegmentationState.getSegmentationRepresentations(toolGroup.id) || [];\n\n  toolGroupSegmentationRepresentations =\n    toolGroupSegmentationRepresentations.filter(\n      (representation) => representation.type === Representations.Labelmap\n    );\n\n  if (!toolGroupSegmentationRepresentations?.length) {\n    return;\n  }\n\n  const segmentationRepresentations = {};\n  toolGroupSegmentationRepresentations.forEach((representation) => {\n    const segmentation = SegmentationState.getSegmentation(\n      representation.segmentationId\n    );\n\n    if (!segmentation || !segmentation.representationData?.LABELMAP) {\n      return;\n    }\n\n    const labelmapData = segmentation.representationData.LABELMAP;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      return;\n    }\n\n    const { imageIdReferenceMap } =\n      labelmapData as LabelmapSegmentationDataStack;\n\n    segmentationRepresentations[representation.segmentationRepresentationUID] =\n      {\n        imageIdReferenceMap,\n      };\n  });\n\n  const representationList = Object.keys(segmentationRepresentations);\n  const currentImageId = viewport.getCurrentImageId();\n  const actors = viewport.getActors();\n\n  const segmentationFound = actors.find((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!segmentationFound) {\n    // If the segmentation is not found, it could be because of some special cases\n    // where we are in the process of updating the volume conversion to a stack while\n    // the data is still coming in. In such situations, we should trigger the render\n    // to ensure that the segmentation actors are created, even if the data arrives late.\n\n    if (!perToolGroupManualTriggers.has(toolGroup.id)) {\n      perToolGroupManualTriggers.set(toolGroup.id, true);\n      triggerSegmentationRender(toolGroup.id);\n    }\n\n    // we should return here, since there is no segmentation actor to update\n    // we will hit this function later on after the actor is created\n    return;\n  }\n\n  actors.forEach((actor) => {\n    if (!representationList.includes(actor.uid)) {\n      return;\n    }\n    const segmentationActor = actor.actor;\n\n    const { imageIdReferenceMap } = segmentationRepresentations[actor.uid];\n\n    const derivedImageId = imageIdReferenceMap.get(currentImageId);\n\n    const segmentationImageData = segmentationActor.getMapper().getInputData();\n\n    if (!derivedImageId) {\n      // this means that this slice doesn't have a segmentation for this representation\n      // this can be a case where the segmentation was added to certain slices only\n      // so we can keep the actor but empty out the imageData\n      if (segmentationImageData.setDerivedImage) {\n        // If the image data has a set derived image, then it should be called\n        // to update any vtk or actor data associated with it.  In this case, null\n        // is used to clear the data.  THis allows intercepting/alternative\n        // to vtk calls.  Eventually the vtk version should also use this.\n        segmentationImageData.setDerivedImage(null);\n        return;\n      }\n      // This is the vtk version of the clearing out the image data, and fails\n      // to work for non scalar image data.\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: new Uint8Array(segmentationImageData.getNumberOfPoints()),\n      });\n\n      const imageData = vtkImageData.newInstance();\n      imageData.getPointData().setScalars(scalarArray);\n      segmentationActor.getMapper().setInputData(imageData);\n      return;\n    }\n\n    const derivedImage = cache.getImage(derivedImageId);\n\n    const { dimensions, spacing, direction } =\n      viewport.getImageDataMetadata(derivedImage);\n\n    const currentImage =\n      cache.getImage(currentImageId) ||\n      ({\n        imageId: currentImageId,\n      } as Types.IImage);\n    const { origin: currentOrigin } =\n      viewport.getImageDataMetadata(currentImage);\n\n    // IMPORTANT: We need to make sure that the origin of the segmentation\n    // is the same as the current image origin. This is because due to some\n    // floating point precision issues, when coming from volume to stack\n    // the origin of the segmentation can be slightly different from the\n    // current image origin. This can cause the segmentation to be rendered\n    // in the wrong location.\n    // Todo: This will not work for segmentations that are not in the same frame\n    // of reference or derived from the same image. This can happen when we have\n    // a segmentation that happens to exist in the same space as the image but is\n    // not derived from it. We need to find a way to handle this case, but don't think\n    // it makes sense to do it for the stack viewport, as the volume viewport is designed to handle this case.\n    const originToUse = currentOrigin;\n\n    segmentationImageData.setOrigin(originToUse);\n    segmentationImageData.modified();\n\n    if (\n      segmentationImageData.getDimensions()[0] !== dimensions[0] ||\n      segmentationImageData.getDimensions()[1] !== dimensions[1]\n    ) {\n      // IMPORTANT: Not sure why we can't just update the dimensions\n      // and the orientation of the image data and then call modified\n      // I tried calling modified on everything, but seems like we should remove\n      // and add the actor again below\n      viewport.removeActors([actor.uid]);\n      viewport.addImages([\n        {\n          imageId: derivedImageId,\n          actorUID: actor.uid,\n          callback: ({ imageActor }) => {\n            const scalarArray = vtkDataArray.newInstance({\n              name: 'Pixels',\n              numberOfComponents: 1,\n              values: [...derivedImage.getPixelData()],\n            });\n\n            const imageData = vtkImageData.newInstance();\n\n            imageData.setDimensions(dimensions[0], dimensions[1], 1);\n            imageData.setSpacing(spacing);\n            imageData.setDirection(direction);\n            imageData.setOrigin(originToUse);\n            imageData.getPointData().setScalars(scalarArray);\n\n            imageActor.getMapper().setInputData(imageData);\n          },\n        },\n      ]);\n\n      triggerSegmentationRender(toolGroup.id);\n      return;\n    }\n\n    if (segmentationImageData.setDerivedImage) {\n      // Update the derived image data, whether vtk or other as appropriate\n      // to the actor(s) displaying the data.\n      segmentationImageData.setDerivedImage(derivedImage);\n    } else {\n      // TODO - use setDerivedImage for this functionality\n      utilities.updateVTKImageDataWithCornerstoneImage(\n        segmentationImageData,\n        derivedImage\n      );\n    }\n    viewport.render();\n\n    // This is put here to make sure that the segmentation is rendered\n    // for the initial image as well after that we don't need it since\n    // stack new image is called when changing slices\n    if (evt.type === Enums.Events.IMAGE_RENDERED) {\n      // unsubscribe after the initial render\n      viewport.element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        _imageChangeEventListener as EventListener\n      );\n    }\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { AnnotationCompletedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\n\nexport default function annotationCompletedListener(\n  evt: AnnotationCompletedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationCompleted(evt);\n  }\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { AnnotationRemovedEventType } from '../../types/EventTypes';\nimport * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\n\nexport default function annotationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation;\n\n  if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n    contourSegmentationRemoved(evt);\n  }\n}\n","import type { AnnotationRemovedEventType } from '../../../types/EventTypes';\nimport type { ContourSegmentationAnnotation } from '../../../types/ContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\n\nexport default function contourSegmentationRemovedListener(\n  evt: AnnotationRemovedEventType\n) {\n  const annotation = evt.detail.annotation as ContourSegmentationAnnotation;\n\n  removeContourSegmentationAnnotation(annotation);\n}\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationCompletedListener,\n  annotationRemovedListener,\n  annotationSelectionListener,\n  annotationModifiedListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n} from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.enable();\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n  annotationInterpolationEventDispatcher.disable();\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_REMOVED,\n    annotationRemovedListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_COMPLETED,\n    annotationCompletedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\n\nexport type BaseEventDetail = {\n  viewportId: string;\n  renderingEngineId: string;\n};\n\n/**\n * An annotation group\n */\n\nexport default class AnnotationGroup {\n  private annotationUIDs = new Set<string>();\n  private _isVisible = true;\n\n  public visibleFilter: (uid: string) => boolean;\n\n  constructor() {\n    this.visibleFilter = this.unboundVisibleFilter.bind(this);\n  }\n\n  /**\n   * Returns true if other groups are free to hide this annotation.\n   * That is, if the annotation is not a member or is hidden.\n   */\n  protected unboundVisibleFilter(uid: string): boolean {\n    return !this._isVisible || !this.annotationUIDs.has(uid);\n  }\n\n  public has(uid: string): boolean {\n    return this.annotationUIDs.has(uid);\n  }\n  /**\n   * Sets whether annotations belonging to this group are visible or not.\n   * If there are multiple groups, then the set visible false should be called\n   * before before re-enabling the other groups with setVisible true.\n   */\n  public setVisible(\n    isVisible = true,\n    baseEvent: BaseEventDetail,\n    filter?: (annotationUID: string) => boolean\n  ) {\n    if (this._isVisible === isVisible) {\n      return;\n    }\n    this._isVisible = isVisible;\n    this.annotationUIDs.forEach((uid) => {\n      const annotation = getAnnotation(uid);\n      if (!annotation) {\n        this.annotationUIDs.delete(uid);\n        return;\n      }\n      if (annotation.isVisible === isVisible) {\n        return;\n      }\n      if (!isVisible && filter?.(uid) === false) {\n        return;\n      }\n      annotation.isVisible = isVisible;\n      const eventDetail = {\n        ...baseEvent,\n        annotation,\n      };\n      triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n    });\n  }\n\n  public get isVisible() {\n    return this._isVisible;\n  }\n\n  /** Finds the nearby/next annotation in the given direction */\n  public findNearby(uid: string, direction: 1) {\n    const uids = [...this.annotationUIDs];\n    if (uids.length === 0) {\n      return null;\n    }\n    if (!uid) {\n      return uids[direction === 1 ? 0 : uids.length - 1];\n    }\n    const index = uids.indexOf(uid);\n    if (\n      index === -1 ||\n      index + direction < 0 ||\n      index + direction >= uids.length\n    ) {\n      return null;\n    }\n    return uids[index + direction];\n  }\n\n  /**\n   * Adds the annotation to the group\n   * Does NOT change the visibility status of the annotation.\n   */\n  public add(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.add(annotationUID)\n    );\n  }\n\n  /**\n   * Removes the annotation from the group.\n   * Does not affect the visibility status of the annotation.\n   */\n  public remove(...annotationUIDs: string[]) {\n    annotationUIDs.forEach((annotationUID) =>\n      this.annotationUIDs.delete(annotationUID)\n    );\n  }\n\n  /**\n   * Removes everything from the group.\n   */\n  public clear() {\n    this.annotationUIDs.clear();\n  }\n}\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\nimport {\n  checkAndDefineTextBoxProperty,\n  checkAndDefineCachedStatsProperty,\n} from './utilities/defineProperties';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   * WARNING: The list returned here is internal tool data, not a copy, so do NOT modify it.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName]\n        ? annotations[groupKey][toolName]\n        : [];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n    checkAndDefineTextBoxProperty(annotation);\n    checkAndDefineCachedStatsProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   *\n   * @returns The removed annotations\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): Annotations => {\n    const annotations = this.annotations;\n    const removedAnnotations = [];\n\n    if (!annotations[groupKey]) {\n      return removedAnnotations;\n    }\n\n    if (toolName) {\n      const annotationsForTool = annotations[groupKey][toolName];\n      for (const annotation of annotationsForTool) {\n        this.removeAnnotation(annotation.annotationUID);\n        removedAnnotations.push(annotation);\n      }\n    } else {\n      for (const toolName in annotations[groupKey]) {\n        const annotationsForTool = annotations[groupKey][toolName];\n        for (const annotation of annotationsForTool) {\n          this.removeAnnotation(annotation.annotationUID);\n          removedAnnotations.push(annotation);\n        }\n      }\n    }\n\n    return removedAnnotations;\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * return all annotations as a single array\n   */\n  getAllAnnotations = (): Annotations => {\n    return Object.values(this.annotations)\n      .map((frameOfReferenceSpecificAnnotations) =>\n        Object.values(frameOfReferenceSpecificAnnotations)\n      )\n      .flat(2);\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   *\n   * @returns The removed annotations\n   */\n  removeAllAnnotations = (): Annotations => {\n    const removedAnnotations = [];\n\n    for (const annotation of this.getAllAnnotations()) {\n      this.removeAnnotation(annotation.annotationUID);\n      removedAnnotations.push(annotation);\n    }\n\n    return removedAnnotations;\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation?.metadata?.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationGroupSelector } from '../../types';\n\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n  triggerAnnotationRemoved,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\nfunction getAllAnnotations(): Annotations {\n  const manager = getAnnotationManager();\n  return manager.getAllAnnotations();\n}\n\n/**\n * Removes the association between the annotation passed as parameter and its\n * parent in case it has one (eg: contour holes).\n * @param annotation - Annotation\n */\nfunction clearParentAnnotation(annotation: Annotation): void {\n  const { annotationUID: childUID, parentAnnotationUID } = annotation;\n\n  if (!parentAnnotationUID) {\n    return;\n  }\n\n  const parentAnnotation = getAnnotation(parentAnnotationUID);\n  const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n\n  parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n  annotation.parentAnnotationUID = undefined;\n}\n\n/**\n * Creates a parent/child association between annotations.\n * A annotation may have only one parent and multiple children (eg: a contour\n * may have multiple holes in it).\n * @param parentAnnotation - Parent annotation\n * @param childAnnotation - Child annotation\n */\nfunction addChildAnnotation(\n  parentAnnotation: Annotation,\n  childAnnotation: Annotation\n): void {\n  const { annotationUID: parentUID } = parentAnnotation;\n  const { annotationUID: childUID } = childAnnotation;\n\n  // Make sure it is not associated with any other tool\n  clearParentAnnotation(childAnnotation);\n\n  if (!parentAnnotation.childAnnotationUIDs) {\n    parentAnnotation.childAnnotationUIDs = [];\n  }\n\n  // Check if it is already a child\n  if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n    return;\n  }\n\n  parentAnnotation.childAnnotationUIDs.push(childUID);\n  childAnnotation.parentAnnotationUID = parentUID;\n}\n\n/**\n * Returns the parent annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Parent annotation\n */\nfunction getParentAnnotation(annotation: Annotation) {\n  return annotation.parentAnnotationUID\n    ? getAnnotation(annotation.parentAnnotationUID)\n    : undefined;\n}\n\n/**\n * Returns all children annotation of a given one since annotations can be\n * associated in a parent/child way (eg: polyline holes)\n * @param annotation - Annotation\n * @returns Child annotations\n */\nfunction getChildAnnotations(annotation: Annotation) {\n  return (\n    annotation.childAnnotationUIDs?.map((childAnnotationUID) =>\n      getAnnotation(childAnnotationUID)\n    ) ?? []\n  );\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (!annotation.annotationUID) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    manager.addAnnotation(annotation, groupKey);\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    manager.addAnnotation(annotation);\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  if (!annotationUID) {\n    return;\n  }\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  // Remove all child annotations first\n  annotation.childAnnotationUIDs?.forEach((childAnnotationUID) =>\n    removeAnnotation(childAnnotationUID)\n  );\n\n  manager.removeAnnotation(annotationUID);\n\n  triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  const removedAnnotations = manager.removeAllAnnotations();\n\n  for (const annotation of removedAnnotations) {\n    triggerAnnotationRemoved({\n      annotation,\n      annotationManagerUID: manager.uid,\n    });\n  }\n}\n\n/**\n * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n * @param toolName - Optional. The name of the tool to remove annotations for.\n * @param annotationGroupSelector - The group (FrameOfReferenceUID) to remove annotations for.\n */\nfunction removeAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): void {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\n\n  for (const annotation of removedAnnotations) {\n    triggerAnnotationRemoved({\n      annotation,\n      annotationManagerUID: manager.uid,\n    });\n  }\n}\n\n/**\n * Invalidate current and all parent annotations (eg: contour holes)\n * @param annotation - Annotation\n */\nfunction invalidateAnnotation(annotation: Annotation): void {\n  let currAnnotation = annotation;\n\n  while (currAnnotation) {\n    currAnnotation.invalidated = true;\n\n    currAnnotation = currAnnotation.parentAnnotationUID\n      ? getAnnotation(currAnnotation.parentAnnotationUID)\n      : undefined;\n  }\n}\n\nexport {\n  getAllAnnotations,\n  getAnnotations,\n  getParentAnnotation,\n  getChildAnnotations,\n  clearParentAnnotation,\n  addChildAnnotation,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAnnotations,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n  invalidateAnnotation,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n\n      if (annotationToolStyles) {\n        // check first in the toolSpecific styles\n        if (annotationToolStyles[property] !== undefined) {\n          return annotationToolStyles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const viewportToolStyles = this.getViewportToolStyles(viewportId);\n\n      if (viewportToolStyles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (\n          viewportToolStyles[toolName] &&\n          viewportToolStyles[toolName][property] !== undefined\n        ) {\n          return viewportToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (\n          viewportToolStyles.global &&\n          viewportToolStyles.global[property] !== undefined\n        ) {\n          return viewportToolStyles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (toolGroupToolStyles) {\n        // check first in the toolSpecific styles\n        if (\n          toolGroupToolStyles[toolName] &&\n          toolGroupToolStyles[toolName][property] !== undefined\n        ) {\n          return toolGroupToolStyles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (\n          toolGroupToolStyles.global &&\n          toolGroupToolStyles.global[property] !== undefined\n        ) {\n          return toolGroupToolStyles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (\n      globalStyles[toolName] &&\n      globalStyles[toolName][property] !== undefined\n    ) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property] !== undefined) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data.\n * The ordering of states is:\n *   * Highlighted\n *   * Selected\n *   * Locked\n *   * Autogenerated\n *   * Default\n * So the first one that applies will be returned.\n * For the autogenerated state, it depends on the autoGenerated flag on the\n * annotation, so once that is gone/false, the annotation will go to default.\n *\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, Selected, or AutoGenerated.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n\n    if (annotation.data && annotation.autoGenerated) {\n      return AnnotationStyleStates.AutoGenerated;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport {\n  AnnotationAddedEventDetail,\n  AnnotationModifiedEventDetail,\n  AnnotationCompletedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n  AnnotationRemovedEventDetail,\n} from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  const eventType = Events.ANNOTATION_ADDED;\n  const eventDetail: AnnotationAddedEventDetail = { annotation };\n\n  if (!viewportsToRender.length) {\n    triggerEvent(eventTarget, eventType, eventDetail);\n    return;\n  }\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    eventDetail.viewportId = viewportId;\n    eventDetail.renderingEngineId = renderingEngineId;\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\n/**\n * Triggers an annotation removed event.\n * @param eventDetail - Event detail\n */\nfunction triggerAnnotationRemoved(\n  eventDetail: AnnotationRemovedEventDetail\n): void {\n  const eventType = Events.ANNOTATION_REMOVED;\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Triggers an annotation modified event.\n */\nfunction triggerAnnotationModified(\n  annotation: Annotation,\n  element: HTMLDivElement,\n  changeType = ChangeTypes.HandlesUpdated\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const eventType = Events.ANNOTATION_MODIFIED;\n  const eventDetail: AnnotationModifiedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId,\n    changeType,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Triggers an annotation completed event.\n */\nfunction triggerAnnotationCompleted(annotation: Annotation): void {\n  const eventDetail: AnnotationCompletedEventDetail = {\n    annotation,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for contours (same annotation completed\n * event but with more specific details).\n */\nfunction triggerContourAnnotationCompleted(\n  annotation: Annotation,\n  contourHoleProcessingEnabled = false\n): void {\n  const eventDetail: ContourAnnotationCompletedEventDetail = {\n    annotation,\n    contourHoleProcessingEnabled,\n  };\n\n  _triggerAnnotationCompleted(eventDetail);\n}\n\n/**\n * Triggers an annotation completed event for the `detail` provided\n * @param eventDetail - Event detail\n */\nfunction _triggerAnnotationCompleted(\n  eventDetail: AnnotationCompletedEventDetail\n) {\n  const eventType = Events.ANNOTATION_COMPLETED;\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\nexport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n  triggerAnnotationRemoved,\n  triggerAnnotationModified,\n  triggerAnnotationCompleted,\n  triggerContourAnnotationCompleted,\n};\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport {\n  getDefaultSegmentationStateManager,\n  getSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Retrieves the active segmentation for a given tool group.\n * @param toolGroupId - The ID of the tool group.\n * @returns The active segmentation Id, or undefined if no active segmentation is found.\n */\nfunction getActiveSegmentation(toolGroupId: string) {\n  const activeRepresentation = getActiveSegmentationRepresentation(toolGroupId);\n\n  if (!activeRepresentation) {\n    return;\n  }\n\n  const activeSegmentation = getSegmentation(\n    activeRepresentation.segmentationId\n  );\n\n  return activeSegmentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  getActiveSegmentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  // Create a set that contains all segments indices\n  const indicesSet = new Set(indices);\n\n  // Remove a indices that are hidden\n  segmentsHidden.forEach((segmentIndex) => indicesSet.delete(segmentIndex));\n\n  // Check if there is at least one segment visible\n  return !!indicesSet.size;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation\n * @param segmentationRepresentationUID - The id of the segmentation representation that contains the segment\n * @param segmentIndex - Index of the segment that will be updated\n * @param visibility - True to show the segment or false to hide it\n * @returns True if the segment is visible or false otherwise\n */\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param segmentIndex - Index of the segment\n * @returns True if the segment is visible or false otherwise\n */\nfunction getSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): boolean {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return false;\n  }\n\n  return !segRepresentation.segmentsHidden.has(segmentIndex);\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n  getSegmentVisibility,\n};\n","import {\n  Types,\n  Enums,\n  getWebWorkerManager,\n  eventTarget,\n  triggerEvent,\n} from '@cornerstonejs/core';\n\nimport { WorkerTypes } from '../../../enums';\nimport { pointToString } from '../../../utilities';\nimport { registerPolySegWorker } from '../polySeg/registerPolySegWorker';\nconst workerManager = getWebWorkerManager();\n\n/**\n * Surfaces info for clipping\n */\nexport type SurfacesInfo = {\n  id: string;\n  points: number[];\n  polys: number[];\n  segmentIndex: number;\n};\n\n/**\n * The result of the surface clipping\n */\nexport type SurfaceClipResult = {\n  points: number[];\n  lines: number[];\n  numberOfCells: number;\n};\n\nexport type PolyDataClipCacheType = Map<string, Map<string, SurfaceClipResult>>;\n\n/**\n * a cache from actorUID to cacheId to SurfaceClipResult\n * Map<actorUID, Map<cacheId, SurfaceClipResult>>\n * cacheId is slice specific (viewPlaneNormal, sliceIndex)\n */\nconst polyDataCache = new Map() as PolyDataClipCacheType;\nconst surfacesAABBCache = new Map();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.SURFACE_CLIPPING,\n  });\n};\n\n/**\n * Clips and caches surfaces for a specific viewport.\n *\n * @param surfacesInfo - An array of surfaces information.\n * @param viewport - The volume viewport.\n * @param segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns The cached polydata.\n */\nexport async function clipAndCacheSurfacesForViewport(\n  surfacesInfo: SurfacesInfo[],\n  viewport: Types.IVolumeViewport,\n  segmentationRepresentationUID: string\n) {\n  registerPolySegWorker();\n  // All planes is an array of planes pairs for each slice, so we should loop over them and\n  // add the planes to the clipping filter and cache the results for that slice\n\n  // Fix these ts ignores\n  // @ts-ignore\n  const planesInfo = viewport.getSlicesClippingPlanes?.();\n\n  if (!planesInfo) {\n    // this means it is probably the stack viewport not being ready\n    // in terms of planes which we should wait for the first render to\n    // get the planes\n    return;\n  }\n\n  // @ts-ignore\n  const currentSliceIndex = viewport.getSliceIndex();\n\n  // Reorder planesInfo based on proximity to currentSliceIndex\n  planesInfo.sort((a, b) => {\n    const diffA = Math.abs(a.sliceIndex - currentSliceIndex);\n    const diffB = Math.abs(b.sliceIndex - currentSliceIndex);\n    return diffA - diffB;\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  // check which surfaces don't have a cached AABB\n  // make a list of the surfaces that don't have a cached AABB\n  await updateSurfacesAABBCache(surfacesInfo);\n\n  const surfacesAABB = new Map();\n  surfacesInfo.forEach((surface) => {\n    surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));\n  });\n\n  const camera = viewport.getCamera();\n\n  await workerManager\n    .executeTask(\n      'polySeg',\n      'cutSurfacesIntoPlanes',\n      {\n        surfacesInfo,\n        planesInfo,\n        surfacesAABB,\n      },\n      {\n        callbacks: [\n          // progress callback\n          ({ progress }) => {\n            triggerWorkerProgress(eventTarget, progress);\n          },\n          // update cache callback\n          ({ sliceIndex, polyDataResults }) => {\n            polyDataResults.forEach((polyDataResult, surfaceId) => {\n              const actorUID = `${segmentationRepresentationUID}_${surfaceId}`;\n              const cacheId = generateCacheId(\n                viewport,\n                camera.viewPlaneNormal,\n                sliceIndex\n              );\n              updatePolyDataCache(actorUID, cacheId, polyDataResult);\n            });\n          },\n        ],\n      }\n    )\n    .catch((error) => {\n      console.error(error);\n    });\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return polyDataCache;\n}\n\n/**\n * Updates the surfaces AABB cache with the AABB information for the given surfaces.\n * If the AABB information for a surface already exists in the cache, it will not be updated.\n * @param surfacesInfo - An array of surfaces information.\n * @returns A Promise that resolves when the surfaces AABB cache has been updated.\n */\nasync function updateSurfacesAABBCache(surfacesInfo: SurfacesInfo[]) {\n  const surfacesWithoutAABB = surfacesInfo.filter(\n    (surface) => !surfacesAABBCache.has(surface.id)\n  );\n\n  if (!surfacesWithoutAABB.length) {\n    return;\n  }\n\n  const surfacesAABB = await workerManager.executeTask(\n    'polySeg',\n    'getSurfacesAABBs',\n    {\n      surfacesInfo: surfacesWithoutAABB,\n    },\n    {\n      callbacks: [\n        // progress callback\n        ({ progress }) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  // update the surfacesAABBCache with the new surfacesAABB\n  surfacesAABB.forEach((aabb, id) => {\n    surfacesAABBCache.set(id, aabb);\n  });\n}\n\nexport function getSurfaceActorUID(\n  segmentationRepresentationUID: string,\n  surfaceId: string\n) {\n  return `${segmentationRepresentationUID}_${surfaceId}`;\n}\n\n// Helper function to generate a cache ID\nexport function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${sliceIndex}`;\n}\n\n// Helper function to update PolyData cache\nexport function updatePolyDataCache(\n  actorUID: string,\n  cacheId: string,\n  polyDataResult: SurfaceClipResult\n) {\n  const { points, lines, numberOfCells } = polyDataResult;\n\n  let actorCache = polyDataCache.get(actorUID);\n  if (!actorCache) {\n    actorCache = new Map<string, SurfaceClipResult>();\n    polyDataCache.set(actorUID, actorCache);\n  }\n  actorCache.set(cacheId, { points, lines, numberOfCells });\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { validatePublic as validatePublicLabelmap } from '../../../tools/displayTools/Labelmap/validateLabelmap';\n\n/**\n * Validates the given segmentationInputArray to ensure it contains\n * appropriate representationProps for the representation type being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @throws If the segmentationInputArray is undefined or empty\n * @throws If the segmentationInput.segmentationId is undefined\n * @throws If the segmentationInput.representation is undefined\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || segmentationInputArray.length === 0) {\n    throw new Error(\n      'The segmentationInputArray is undefined or an empty array'\n    );\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.segmentationId. Please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'Undefined segmentationInput.representation. Please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validatePublicLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { RepresentationPublicInput } from '../../../types';\nimport { getRepresentationRenderingConfig as getLabelmapRenderingConfig } from '../../../tools/displayTools/Labelmap/labelmapDisplay';\n\nexport function getRepresentationSpecificConfig(\n  representationInput: RepresentationPublicInput\n) {\n  const { type } = representationInput;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    return getLabelmapRenderingConfig();\n  } else {\n    return {};\n  }\n}\n","import { getRenderingEngine, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n  ToolGroupSpecificRepresentation,\n  RepresentationPublicInputOptions,\n} from '../../types/SegmentationStateTypes';\nimport * as SegmentationConfig from './config/segmentationConfig';\nimport {\n  addSegmentationRepresentation as addSegmentationRepresentationToState,\n  getNextColorLUTIndex,\n  addColorLUT,\n} from './segmentationState';\nimport { getRepresentationSpecificConfig } from './helpers/getRepresentationSpecificConfig';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { SegmentationRepresentations } from '../../enums';\n\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId, options = {} as RepresentationPublicInputOptions } =\n    representationInput;\n\n  const segmentationRepresentationUID =\n    representationInput.options?.segmentationRepresentationUID ||\n    utilities.uuidv4();\n\n  // Todo: make segmentsHidden also an option that can get passed by\n  // the user\n  const segmentsHidden = new Set() as Set<number>;\n\n  const colorLUTIndexToUse = getColorLUTIndex(options);\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: representationInput.type,\n    segmentsHidden,\n    colorLUTIndex: colorLUTIndexToUse,\n    active: true,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: getRepresentationSpecificConfig(representationInput),\n    polySeg: options.polySeg,\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  addSegmentationRepresentationToState(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  if (representationInput.type === SegmentationRepresentations.Contour) {\n    getToolGroup(toolGroupId)\n      .getViewportsInfo()\n      .forEach(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n      });\n  }\n\n  return segmentationRepresentationUID;\n}\n\nfunction getColorLUTIndex(options = {} as RepresentationPublicInputOptions) {\n  const colorLUTOrIndexInput = options.colorLUTOrIndex;\n  let colorLUTIndexToUse;\n\n  if (typeof colorLUTOrIndexInput === 'number') {\n    colorLUTIndexToUse = colorLUTOrIndexInput;\n  } else {\n    const nextIndex = getNextColorLUTIndex();\n    const colorLUTToAdd = Array.isArray(colorLUTOrIndexInput)\n      ? colorLUTOrIndexInput\n      : CORNERSTONE_COLOR_LUT;\n    addColorLUT(colorLUTToAdd as Types.ColorLUT, nextIndex);\n    colorLUTIndexToUse = nextIndex;\n  }\n  return colorLUTIndexToUse;\n}\n\nexport { addSegmentationRepresentation };\n","import {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { addSegmentationRepresentation } from './addSegmentationRepresentation';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nexport default addSegmentationRepresentations;\n","import { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { ContourSegmentationData } from '../../types/ContourTypes';\nimport { SurfaceSegmentationData } from '../../types/SurfaceTypes';\nimport { getSegmentation } from './segmentationState';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\ntype SegmentationData =\n  | LabelmapSegmentationData\n  | ContourSegmentationData\n  | SurfaceSegmentationData;\n\ntype AddRepresentationData = {\n  segmentationId: string;\n  type: SegmentationRepresentations;\n  data: SegmentationData;\n};\n\n/**\n * This will add representation data to the segmentation, for rendering.\n * Each segmentation can have multiple representation data, for example\n * labelmap, contour and surface representation data. For each representation\n * the relevant data should be provided, for instance for the labelmap\n * representation the volumeId should be provided, for contour the contour data\n * which includes geometryIds of the contour sets, and for surface the surface\n * data which includes geometryId of the points and cells.\n *\n * Note: if the representation data already exists for the segmentation, it will\n * be overwritten.\n *\n * @param segmentationId - id of the segmentation\n * @param representationData - representation data to add, it can be either\n * labelmap, contour or surface representation data.\n */\nfunction addRepresentationData({\n  segmentationId,\n  type,\n  data,\n}: AddRepresentationData) {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation.representationData[type]) {\n    console.warn(\n      `Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`\n    );\n\n    // update the representation data class\n  }\n\n  switch (type) {\n    case SegmentationRepresentations.Labelmap:\n      if (data) {\n        segmentation.representationData[type] =\n          data as LabelmapSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Contour:\n      if (data) {\n        segmentation.representationData[type] = data as ContourSegmentationData;\n      }\n      break;\n    case SegmentationRepresentations.Surface:\n      if (data) {\n        segmentation.representationData[type] = data as SurfaceSegmentationData;\n      }\n      break;\n    default:\n      throw new Error(`Invalid representation type ${type}`);\n  }\n}\n\nexport default addRepresentationData;\n","import {\n  volumeLoader,\n  utilities as csUtils,\n  eventTarget,\n  cache,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport { triggerSegmentationRender } from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataStack } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\nasync function computeVolumeSegmentationFromStack({\n  imageIdReferenceMap,\n  options,\n}: {\n  imageIdReferenceMap: Map<string, string>;\n  options?: {\n    volumeId?: string;\n  };\n}): Promise<{ volumeId: string }> {\n  const segmentationImageIds = Array.from(imageIdReferenceMap.values());\n\n  const additionalDetails = {\n    imageIdReferenceMap,\n  };\n\n  const volumeId = options?.volumeId ?? csUtils.uuidv4();\n\n  await volumeLoader.createAndCacheVolumeFromImages(\n    volumeId,\n    segmentationImageIds,\n    {\n      additionalDetails,\n    }\n  );\n\n  return { volumeId };\n}\n\n/**\n * Converts a stack-based segmentation to a volume-based segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId to use for the segmentation.\n * @param [params.options.volumeId] - the new volumeId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.newSegmentationId] - the new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nasync function convertStackToVolumeSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    volumeId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataStack;\n\n  const { volumeId } = await computeVolumeSegmentationFromStack({\n    imageIdReferenceMap: data.imageIdReferenceMap,\n    options,\n  });\n\n  await updateSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    options,\n    volumeId,\n  });\n}\n\n// This function is responsible for updating the segmentation state\nasync function updateSegmentationState({\n  segmentationId,\n  toolGroupId,\n  volumeId,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  volumeId: string;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataStack;\n\n    const imageIdReferenceMap = data.imageIdReferenceMap;\n\n    Array.from(imageIdReferenceMap.values()).forEach((imageId) => {\n      cache.removeImageLoadObject(imageId);\n    });\n\n    segmentation.representationData.LABELMAP = {\n      volumeId,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      volumeId,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  // Note: It is crucial to trigger the data modified event. This ensures that the\n  // old texture is updated to the GPU, especially in scenarios where it may not be getting updated.\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nexport { convertStackToVolumeSegmentation, computeVolumeSegmentationFromStack };\n","import {\n  Types,\n  cache,\n  eventTarget,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport {\n  triggerSegmentationRender,\n  createImageIdReferenceMap,\n} from '../../utilities/segmentation';\nimport { getSegmentation } from './segmentationState';\nimport { LabelmapSegmentationDataVolume } from '../../types/LabelmapTypes';\nimport { triggerSegmentationDataModified } from './triggerSegmentationEvents';\n\n// This function is responsible for the conversion calculations\nexport async function computeStackSegmentationFromVolume({\n  volumeId,\n}: {\n  volumeId: string;\n}): Promise<{ imageIdReferenceMap: Map<string, string> }> {\n  const segmentationVolume = cache.getVolume(volumeId) as Types.IImageVolume;\n\n  // we need to decache the segmentation Volume so that we use it\n  // for the conversion\n\n  // So here we have two scenarios that we need to handle:\n  // 1. the volume was derived from a stack and we need to decache it, this is easy\n  // since we just need purge the volume from the cache and those images will get\n  // their copy of the image back\n  // 2. It was actually a native volume and we need to decache it, this is a bit more\n  // complicated since then we need to decide on the imageIds for it to get\n  // decached to\n  const hasCachedImages = segmentationVolume.imageCacheOffsetMap.size > 0;\n  // Initialize the variable to hold the final result\n  let isAllImagesCached = false;\n\n  if (hasCachedImages) {\n    // Check if every imageId in the volume is in the _imageCache\n    isAllImagesCached = segmentationVolume.imageIds.every((imageId) =>\n      cache.getImage(imageId)\n    );\n  }\n\n  //Todo: This is a hack to get the rendering engine\n  const renderingEngine = getRenderingEngines()[0];\n  const volumeUsedInOtherViewports = renderingEngine\n    .getVolumeViewports()\n    .find((vp) => vp.hasVolumeId(volumeId));\n\n  segmentationVolume.decache(!volumeUsedInOtherViewports && isAllImagesCached);\n\n  const imageIdReferenceMap =\n    _getImageIdReferenceMapForStackSegmentation(segmentationVolume);\n\n  // check if the imageIds have been cache, if not we should actually copy\n\n  return { imageIdReferenceMap };\n}\n\n// Updated original function to call the new separate functions\nexport async function convertVolumeToStackSegmentation({\n  segmentationId,\n  options,\n}: {\n  segmentationId: string;\n  options?: {\n    toolGroupId: string;\n    newSegmentationId?: string;\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const data = segmentation.representationData\n    .LABELMAP as LabelmapSegmentationDataVolume;\n  const { imageIdReferenceMap } = await computeStackSegmentationFromVolume({\n    volumeId: data.volumeId,\n  });\n\n  await updateStackSegmentationState({\n    segmentationId,\n    toolGroupId: options.toolGroupId,\n    imageIdReferenceMap,\n    options,\n  });\n}\n\n/**\n * Converts a volume segmentation to a stack segmentation.\n *\n * @param params - The parameters for the conversion.\n * @param params.segmentationId - The segmentationId to convert.\n * @param [params.options] - The conversion options.\n * @param params.options.toolGroupId - The new toolGroupId that the new segmentation will belong to.\n * @param [params.options.newSegmentationId] -  The new segmentationId to use for the segmentation. If not provided, a new ID will be generated.\n * @param [params.options.removeOriginal] - Whether or not to remove the original segmentation. Defaults to true.\n *\n * @returns A promise that resolves when the conversion is complete.\n */\nexport async function updateStackSegmentationState({\n  segmentationId,\n  toolGroupId,\n  imageIdReferenceMap,\n  options,\n}: {\n  segmentationId: string;\n  toolGroupId: string;\n  imageIdReferenceMap: Map<any, any>;\n  options?: {\n    removeOriginal?: boolean;\n  };\n}): Promise<void> {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (options?.removeOriginal) {\n    const data = segmentation.representationData\n      .LABELMAP as LabelmapSegmentationDataVolume;\n\n    if (cache.getVolume(data.volumeId)) {\n      cache.removeVolumeLoadObject(data.volumeId);\n    }\n\n    segmentation.representationData.LABELMAP = {\n      imageIdReferenceMap,\n    };\n  } else {\n    segmentation.representationData.LABELMAP = {\n      ...segmentation.representationData.LABELMAP,\n      imageIdReferenceMap,\n    };\n  }\n\n  await addSegmentationRepresentations(toolGroupId, [\n    {\n      segmentationId,\n      type: SegmentationRepresentations.Labelmap,\n    },\n  ]);\n\n  triggerSegmentationRender(toolGroupId);\n  eventTarget.addEventListenerOnce(Events.SEGMENTATION_RENDERED, () =>\n    triggerSegmentationDataModified(segmentationId)\n  );\n}\n\nfunction _getImageIdReferenceMapForStackSegmentation(\n  segmentationVolume: Types.IImageVolume\n) {\n  // There might be or might not be segmentationImageIds, if it is a volume\n  // segmentation converted from stack segmentation, there will be segmentationImageIds\n  // otherwise, if it is empty volume segmentation derived from\n  // a volume that is not a stack, there will be no segmentationImageIds\n\n  if (segmentationVolume.additionalDetails?.imageIdReferenceMap) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the imageIdReferenceMap from the additionalDetails\n    return segmentationVolume.additionalDetails.imageIdReferenceMap;\n  } else if (\n    segmentationVolume.referencedImageIds?.length &&\n    !segmentationVolume.referencedImageIds[0].startsWith('derived')\n  ) {\n    // this means the segmentation volume is derived from a stack segmentation\n    // and we can use the referencedImageIds from the segmentationVolume\n    const referencedImageIds = segmentationVolume.referencedImageIds;\n    const segmentationImageIds = segmentationVolume.imageIds;\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIds].reverse()\n    );\n  } else {\n    // check if the segmentation volume is derived from another volume and\n    // whether if that volume has imageIds\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without referenced volume to stack segmentation yet'\n      );\n    }\n\n    if (!referencedVolume?.imageIds?.length) {\n      throw new Error(\n        'Cannot convert volumetric segmentation without imageIds to stack segmentation yet'\n      );\n    }\n\n    if (referencedVolume.imageIds?.[0].startsWith('derived')) {\n      throw new Error(\n        `Cannot convert volume segmentation that is derived from another segmentation\n         to stack segmentation yet, include the additionalDetails.imageIdReferenceMap\n         in the volume segmentation in case you need it for the conversion`\n      );\n    }\n\n    // if the referenced volume has imageIds, and itself is not derived from\n    // another segmentation then we can use the imageIds from the referenced volume\n    const referencedImageIds = referencedVolume.imageIds;\n\n    let segmentationImageIdsToUse = segmentationVolume.imageIds;\n    if (!segmentationImageIdsToUse?.length) {\n      // If segmentation Ids don't exist it means that the segmentation is literally\n      // just a volume so we need to assume imageIds and decache it to the _imageCache\n      // so that it can be used for the conversion\n      segmentationImageIdsToUse =\n        segmentationVolume.convertToImageSlicesAndCache();\n    }\n\n    return createImageIdReferenceMap(\n      referencedImageIds,\n      [...segmentationImageIdsToUse].reverse()\n    );\n  }\n}\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Types.Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  let colorValue = colorLUT[segmentIndex];\n  if (!colorValue) {\n    if (typeof segmentIndex !== 'number') {\n      throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\n    }\n    colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n  }\n  return colorValue;\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Types.Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport addRepresentationData from '../addRepresentationData';\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\nimport { debounce } from '../../../utilities';\nimport { registerPolySegWorker } from './registerPolySegWorker';\n\nconst computedRepresentations = new Map<\n  string,\n  SegmentationRepresentations[]\n>();\n\n/**\n * Computes a representation using the provided computation function, adds the computed data,\n * subscribes to segmentation changes, and triggers segmentation modification.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param representationType - The type of the segmentation representation.\n * @param computeFunction - The function that computes the representation data.\n * @param options - Additional options for computing the representation.\n * @returns - A promise that resolves with the computed representation data.\n */\nasync function computeAndAddRepresentation<T>(\n  segmentationId: string,\n  representationType: SegmentationRepresentations,\n  computeFunction: () => Promise<T>,\n  updateFunction?: () => void\n): Promise<T> {\n  // register the worker if it hasn't been registered yet\n  registerPolySegWorker();\n\n  // Compute the specific representation data\n  const data = await computeFunction();\n\n  // Add the computed data to the system\n  addRepresentationData({\n    segmentationId,\n    type: representationType,\n    data,\n  });\n\n  // Update internal structures and possibly UI components\n  if (!computedRepresentations.has(segmentationId)) {\n    computedRepresentations.set(segmentationId, []);\n  }\n\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations.includes(representationType)) {\n    representations.push(representationType);\n  }\n\n  // Subscribe to any changes in the segmentation data for real-time updates\n  subscribeToSegmentationChanges(updateFunction);\n\n  // Notify other system parts that segmentation data has been modified\n  triggerSegmentationModified(segmentationId);\n\n  return data;\n}\n\n/**\n * Subscribes to segmentation changes by adding an event listener for the SEGMENTATION_DATA_MODIFIED event.\n * If there is an existing listener, it will be unsubscribed before adding the new listener.\n */\nfunction subscribeToSegmentationChanges(updateFunction) {\n  const debouncedUpdateFunction = (event) => {\n    _debouncedSegmentationModified(event, updateFunction);\n  };\n\n  updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n\n  eventTarget.removeEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n\n  eventTarget.addEventListener(\n    Events.SEGMENTATION_DATA_MODIFIED,\n    updateFunction._debouncedUpdateFunction\n  );\n}\n\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n  const segmentationId = event.detail.segmentationId;\n  const representations = computedRepresentations.get(segmentationId);\n  if (!representations || !representations.length) {\n    return;\n  }\n\n  updateFunction(segmentationId);\n\n  if (representations.length) {\n    triggerSegmentationModified(segmentationId);\n  }\n}, 300);\n\nexport { computeAndAddRepresentation };\n","import { Enums, Types, eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport { ContourSegmentationData } from '../../../../types';\nimport { getAnnotation } from '../../../annotation/annotationState';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a contour representation to a surface representation.\n *\n * @param contourRepresentationData - The contour segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertContourToSurface(\n  contourRepresentationData: ContourSegmentationData,\n  segmentIndex: number\n): Promise<Types.SurfaceData> {\n  const { annotationUIDsMap } = contourRepresentationData;\n\n  // loop over all annotations in the segment and flatten their polylines\n  const polylines = [];\n  const numPointsArray = [];\n  const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n\n  for (const annotationUID of annotationUIDs) {\n    const annotation = getAnnotation(annotationUID);\n    const { polyline } = annotation.data.contour;\n    numPointsArray.push(polyline.length);\n    polyline.forEach((polyline) => polylines.push(...polyline));\n  }\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToSurface',\n    {\n      polylines,\n      numPointsArray,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import { Enums, Types, geometryLoader } from '@cornerstonejs/core';\nimport { getColorForSegmentIndex } from '../../config/segmentationColor';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../../segmentationState';\nimport { RawSurfacesData } from './surfaceComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Creates and caches surfaces from raw surface data.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param rawSurfacesData - The raw surface data.\n * @param options - Additional options for creating and caching surfaces.\n * @param options.segmentIndices - An array of segment indices.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns An object containing the IDs of the created surfaces.\n */\nexport async function createAndCacheSurfacesFromRaw(\n  segmentationId: string,\n  rawSurfacesData: RawSurfacesData,\n  options: PolySegConversionOptions = {}\n) {\n  // Initialize segmentationRepresentation and toolGroupId if a representation UID is provided\n  let segmentationRepresentation: any, toolGroupId: any;\n  if (options.segmentationRepresentationUID) {\n    ({ segmentationRepresentation, toolGroupId } =\n      findSegmentationRepresentationByUID(\n        options.segmentationRepresentationUID\n      ));\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const geometryIds = new Map<number, string>();\n\n  // Loop through raw surfaces data and create surfaces\n  const promises = Object.keys(rawSurfacesData).map(async (index: string) => {\n    const rawSurfaceData = rawSurfacesData[index];\n    const segmentIndex = rawSurfaceData.segmentIndex;\n\n    // Get the color either from the segmentation representation or randomly generated\n    const color = segmentationRepresentation;\n    getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID,\n      segmentIndex\n    ).slice(0, 3);\n\n    if (!color) {\n      throw new Error(\n        'No color found for segment index, unable to create surface'\n      );\n    }\n\n    const closedSurface = {\n      id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,\n      color,\n      frameOfReferenceUID: 'test-frameOfReferenceUID',\n      data: {\n        points: rawSurfaceData.data.points,\n        polys: rawSurfaceData.data.polys,\n      },\n    };\n\n    const geometryId = closedSurface.id;\n    geometryIds.set(segmentIndex, geometryId);\n\n    return geometryLoader.createAndCacheGeometry(geometryId, {\n      type: Enums.GeometryType.SURFACE,\n      geometryData: closedSurface as Types.PublicSurfaceData,\n    });\n  });\n\n  await Promise.all(promises);\n\n  return {\n    geometryIds,\n  };\n}\n","import {\n  Types,\n  cache,\n  eventTarget,\n  triggerEvent,\n  Enums,\n} from '@cornerstonejs/core';\nimport { getWebWorkerManager } from '@cornerstonejs/core';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { computeVolumeSegmentationFromStack } from '../../convertStackToVolumeSegmentation';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,\n  });\n};\n\n/**\n * Converts a labelmap representation to a surface representation.\n *\n * @param labelmapRepresentationData - The labelmap segmentation data.\n * @param segmentIndex - The index of the segment to convert.\n * @param isVolume - Optional flag indicating whether the labelmap is a volume or a stack. Default is true.\n * @returns A promise that resolves to the surface data.\n */\nexport async function convertLabelmapToSurface(\n  labelmapRepresentationData: LabelmapSegmentationData,\n  segmentIndex: number,\n  isVolume = true\n): Promise<Types.SurfaceData> {\n  let volumeId;\n  if (isVolume) {\n    volumeId = (labelmapRepresentationData as LabelmapSegmentationDataVolume)\n      .volumeId;\n  } else {\n    const { imageIdReferenceMap } =\n      labelmapRepresentationData as LabelmapSegmentationDataStack;\n    ({ volumeId } = await computeVolumeSegmentationFromStack({\n      imageIdReferenceMap,\n    }));\n  }\n\n  const volume = cache.getVolume(volumeId);\n\n  const scalarData = volume.getScalarData();\n  const { dimensions, spacing, origin, direction } = volume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const results = await workerManager.executeTask(\n    'polySeg',\n    'convertLabelmapToSurface',\n    {\n      scalarData,\n      dimensions,\n      spacing,\n      origin,\n      direction,\n      segmentIndex,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  return results;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport { convertContourToSurface } from './convertContourToSurface';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from '../../../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { convertLabelmapToSurface } from './convertLabelmapToSurface';\n\nexport type RawSurfacesData = {\n  segmentIndex: number;\n  data: Types.SurfaceData;\n}[];\n\n/**\n * Computes surface data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for surface computation.\n * @returns A promise that resolves to the computed surface data.\n * @throws An error if there is no surface data available for the segmentation.\n */\nexport async function computeSurfaceData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawSurfacesData: RawSurfacesData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawSurfacesData = await computeSurfaceFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP as LabelmapSegmentationData) {\n      // convert volume labelmap to surface\n      rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawSurfacesData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  const surfacesData = await createAndCacheSurfacesFromRaw(\n    segmentationId,\n    rawSurfacesData,\n    options\n  );\n\n  return surfacesData;\n}\n\nasync function computeSurfaceFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  // Todo: validate valid labelmap representation\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation?.representationData?.LABELMAP) {\n    console.warn('Only support surface update from labelmaps');\n    return;\n  }\n\n  const isVolume = isVolumeSegmentation(\n    segmentation.representationData.LABELMAP\n  );\n\n  const labelmapRepresentationData = segmentation.representationData.LABELMAP;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map((index) => {\n    const surface = convertLabelmapToSurface(\n      labelmapRepresentationData as\n        | LabelmapSegmentationDataVolume\n        | LabelmapSegmentationDataStack,\n      index,\n      isVolume\n    );\n\n    return surface;\n  });\n\n  const surfaces = await Promise.allSettled(promises);\n  const errors = surfaces.filter((p) => p.status === 'rejected');\n\n  if (errors.length > 0) {\n    console.error(errors);\n    throw new Error('Failed to convert labelmap to surface');\n  }\n\n  const rawSurfacesData = surfaces\n    .map((surface, index) => {\n      if (surface.status === 'fulfilled') {\n        return { segmentIndex: segmentIndices[index], data: surface.value };\n      }\n    })\n    .filter(Boolean);\n\n  return rawSurfacesData;\n}\n\n/**\n * Computes the surface from contour segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for surface computation.\n * @returns A promise that resolves to the raw surfaces data.\n */\nasync function computeSurfaceFromContourSegmentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n): Promise<RawSurfacesData> {\n  const segmentation = getSegmentation(segmentationId);\n\n  const contourRepresentationData = segmentation.representationData.CONTOUR;\n\n  const segmentIndices =\n    options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n\n  const promises = segmentIndices.map(async (index) => {\n    const surface = await convertContourToSurface(\n      contourRepresentationData as ContourSegmentationData,\n      index\n    );\n\n    return { segmentIndex: index, data: surface };\n  });\n\n  const surfaces = await Promise.all(promises);\n\n  return surfaces;\n}\n\nexport {\n  computeSurfaceFromContourSegmentation,\n  computeSurfaceFromLabelmapSegmentation,\n};\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeSurfaceData } from './surfaceComputationStrategies';\nimport { updateSurfaceData } from './updateSurfaceData';\n\n/**\n * Computes and adds a surface representation for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Additional options for computing the surface representation.\n * @param options.segmentIndices - The indices of the segments to compute the surface for.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation to compute the surface for.\n *\n * @returns A promise that resolves when the surface representation is computed and added.\n */\nexport function computeAndAddSurfaceRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Surface,\n    () => computeSurfaceData(segmentationId, options),\n    () => updateSurfaceData(segmentationId)\n  );\n}\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  getSegmentationRepresentations,\n  getToolGroupIdsWithSegmentation,\n} from '../../segmentationState';\nimport { triggerSegmentationModified } from '../../triggerSegmentationEvents';\nimport { ToolGroupSpecificRepresentations } from '../../../../types/SegmentationStateTypes';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { computeSurfaceFromLabelmapSegmentation } from './surfaceComputationStrategies';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\n\nexport async function updateSurfaceData(segmentationId) {\n  const surfacesObj = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId\n  );\n\n  if (!surfacesObj) {\n    return;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  const indices = getUniqueSegmentIndices(segmentationId);\n\n  if (!indices.length) {\n    // means all segments were removed so we need to empty out\n    // the geometry data\n    const geometryIds = segmentation.representationData.SURFACE.geometryIds;\n    geometryIds.forEach((geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    });\n\n    triggerSegmentationModified(segmentationId);\n\n    return;\n  }\n\n  const promises = surfacesObj.map(({ data, segmentIndex }) => {\n    const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;\n\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      // means it is a new segment getting added while we were\n      // listening to the segmentation data modified event\n      const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n      return toolGroupIds.map((toolGroupId) => {\n        const segmentationRepresentations = getSegmentationRepresentations(\n          toolGroupId\n        ) as ToolGroupSpecificRepresentations;\n\n        return segmentationRepresentations.map((segmentationRepresentation) => {\n          if (\n            segmentationRepresentation.type !==\n            SegmentationRepresentations.Surface\n          ) {\n            return;\n          }\n          segmentation.representationData.SURFACE.geometryIds.set(\n            segmentIndex,\n            geometryId\n          );\n\n          return createAndCacheSurfacesFromRaw(\n            segmentationId,\n            [{ segmentIndex, data }],\n            {\n              segmentationRepresentationUID:\n                segmentationRepresentation.segmentationRepresentationUID,\n            }\n          );\n        });\n      });\n    } else if (indices.includes(segmentIndex)) {\n      // if the geometry already exists and the segmentIndex is\n      // still present, update the geometry data\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints(data.points);\n      surface.setPolys(data.polys);\n    } else {\n      const surface = geometry.data as Types.ISurface;\n      surface.setPoints([]);\n      surface.setPolys([]);\n    }\n  });\n\n  await Promise.all(promises);\n\n  triggerSegmentationModified(segmentationId);\n}\n","import { vec3 } from 'gl-matrix';\nimport {\n  Types,\n  cache,\n  utilities,\n  getWebWorkerManager,\n  volumeLoader,\n  imageLoader,\n  metaData,\n  Enums,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport {\n  Annotation,\n  ContourAnnotation,\n  ContourSegmentationData,\n  PolySegConversionOptions,\n} from '../../../../types';\nimport { getAnnotation } from '../../..';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_CONTOUR_TO_LABELMAP,\n  });\n};\n\nexport async function convertContourToVolumeLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const { viewport } = options;\n\n  const imageIds = utilities.getViewportImageIds(viewport);\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  const segmentationVolumeId = utilities.uuidv4();\n\n  const volumeProps = utilities.generateVolumePropsFromImageIds(\n    imageIds,\n    segmentationVolumeId\n  );\n\n  const { metadata, dimensions, origin, direction, spacing, scalarData } =\n    volumeProps;\n\n  const segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n    {\n      dimensions,\n      origin,\n      direction,\n      spacing,\n      metadata,\n      imageIds: imageIds.map((imageId) => `generated://${imageId}`),\n      referencedImageIds: imageIds,\n    },\n    segmentationVolumeId\n  );\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToVolumeLabelmap',\n    {\n      segmentIndices,\n      dimensions,\n      scalarData,\n      origin,\n      direction,\n      spacing,\n      annotationUIDsInSegmentMap,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertContourToStackLabelmap(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error(\n      'No viewport provided, labelmap computation from contour requires viewports'\n    );\n  }\n\n  const viewport = options.viewport as Types.IStackViewport;\n\n  const imageIds = viewport.getImageIds();\n\n  if (!imageIds) {\n    throw new Error(\n      'No imageIds found, labelmap computation from contour requires viewports with imageIds'\n    );\n  }\n\n  // check if the imageIds are already cached\n  imageIds.forEach((imageId) => {\n    if (!cache.getImageLoadObject(imageId)) {\n      throw new Error(\n        'ImageIds must be cached before converting contour to labelmap'\n      );\n    }\n  });\n\n  // create\n  const { imageIds: segmentationImageIds } =\n    await imageLoader.createAndCacheDerivedSegmentationImages(imageIds);\n\n  const { segmentIndices, annotationUIDsInSegmentMap } =\n    _getAnnotationMapFromSegmentation(contourRepresentationData, options);\n\n  // information for the referenced to the segmentation image\n  // Define constant to hold segmentation information\n  const segmentationsInfo = new Map();\n\n  // Loop through each segmentation image ID\n  segmentationImageIds.forEach((segImageId, index) => {\n    // Fetch the image from cache\n    const segImage = cache.getImage(segImageId);\n\n    // Fetch metadata for the image\n    const imagePlaneModule = metaData.get(\n      Enums.MetadataModules.IMAGE_PLANE,\n      segImageId\n    );\n\n    // Extract properties from image metadata\n    let {\n      columnCosines,\n      rowCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n      imagePositionPatient,\n    } = imagePlaneModule;\n\n    // Set defaults if necessary\n    columnCosines = columnCosines ?? [0, 1, 0];\n    rowCosines = rowCosines ?? [1, 0, 0];\n    rowPixelSpacing = rowPixelSpacing ?? 1;\n    columnPixelSpacing = columnPixelSpacing ?? 1;\n    imagePositionPatient = imagePositionPatient ?? [0, 0, 0];\n\n    // Create vector from row and column cosines\n    const rowCosineVec = vec3.fromValues(\n      rowCosines[0],\n      rowCosines[1],\n      rowCosines[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      columnCosines[0],\n      columnCosines[1],\n      columnCosines[2]\n    );\n\n    // Calculate scan axis normal\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n    // Define direction and spacing\n    const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];\n    const spacing = [rowPixelSpacing, columnPixelSpacing, 1];\n\n    // Set origin\n    const origin = imagePositionPatient;\n\n    // Store segmentation information\n    segmentationsInfo.set(imageIds[index], {\n      direction,\n      spacing,\n      origin,\n      scalarData: segImage.getPixelData(),\n      imageId: segImageId,\n      dimensions: [segImage.width, segImage.height, 1],\n    });\n  });\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newSegmentationsScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertContourToStackLabelmap',\n    {\n      segmentationsInfo,\n      annotationUIDsInSegmentMap,\n      segmentIndices,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  const imageIdReferenceMap = new Map();\n  newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {\n    const segmentationInfo = segmentationsInfo.get(referencedImageId);\n    const { imageId: segImageId } = segmentationInfo;\n\n    const segImage = cache.getImage(segImageId);\n    segImage.getPixelData().set(scalarData);\n    segImage.imageFrame?.pixelData?.set(scalarData);\n\n    imageIdReferenceMap.set(referencedImageId, segImageId);\n  });\n\n  return {\n    imageIdReferenceMap,\n  };\n}\n\nfunction _getAnnotationMapFromSegmentation(\n  contourRepresentationData: ContourSegmentationData,\n  options: PolySegConversionOptions = {}\n) {\n  const annotationMap = contourRepresentationData.annotationUIDsMap;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : Array.from(annotationMap.keys());\n\n  const annotationUIDsInSegmentMap = new Map<number, any>();\n  segmentIndices.forEach((index) => {\n    const annotationUIDsInSegment = annotationMap.get(index);\n\n    // Todo: there is a bug right now where the annotationUIDsInSegment has both\n    // children and parent annotations, so we need to filter out the parent\n    // annotations only\n\n    let uids = Array.from(annotationUIDsInSegment);\n\n    uids = uids.filter(\n      (uid) => !(getAnnotation(uid) as Annotation).parentAnnotationUID\n    );\n\n    const annotations = uids.map((uid) => {\n      const annotation = getAnnotation(uid) as ContourAnnotation;\n      const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n\n      return {\n        polyline: annotation.data.contour.polyline,\n        referencedImageId: annotation.metadata.referencedImageId,\n        holesPolyline:\n          hasChildAnnotations &&\n          annotation.childAnnotationUIDs.map((childUID) => {\n            const childAnnotation = getAnnotation(\n              childUID\n            ) as ContourAnnotation;\n            return childAnnotation.data.contour.polyline;\n          }),\n      };\n    });\n\n    annotationUIDsInSegmentMap.set(index, annotations);\n  });\n\n  return { segmentIndices, annotationUIDsInSegmentMap };\n}\n","import {\n  Enums,\n  Types,\n  cache,\n  eventTarget,\n  getWebWorkerManager,\n  triggerEvent,\n} from '@cornerstonejs/core';\nimport { SurfaceSegmentationData } from '../../../../types/SurfaceTypes';\nimport { WorkerTypes } from '../../../../enums';\n\nconst workerManager = getWebWorkerManager();\n\nconst triggerWorkerProgress = (eventTarget, progress) => {\n  triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n    progress,\n    type: WorkerTypes.POLYSEG_SURFACE_TO_LABELMAP,\n  });\n};\n\nexport async function convertSurfaceToVolumeLabelmap(\n  surfaceRepresentationData: SurfaceSegmentationData,\n  segmentationVolume: Types.IImageVolume\n) {\n  const { geometryIds } = surfaceRepresentationData;\n  if (!geometryIds?.size) {\n    throw new Error('No geometry IDs found for surface representation');\n  }\n\n  const segmentsInfo = new Map() as Map<\n    number,\n    {\n      points: number[];\n      polys: number[];\n    }\n  >;\n\n  geometryIds.forEach((geometryId, segmentIndex) => {\n    const geometry = cache.getGeometry(geometryId);\n    const geometryData = geometry.data as Types.ISurface;\n    const points = geometryData.getPoints();\n    const polys = geometryData.getPolys();\n\n    segmentsInfo.set(segmentIndex, {\n      points,\n      polys,\n    });\n  });\n\n  const { dimensions, direction, origin, spacing } = segmentationVolume;\n\n  triggerWorkerProgress(eventTarget, 0);\n\n  const newScalarData = await workerManager.executeTask(\n    'polySeg',\n    'convertSurfacesToVolumeLabelmap',\n    {\n      segmentsInfo,\n      dimensions,\n      spacing,\n      direction,\n      origin,\n    },\n    {\n      callbacks: [\n        (progress) => {\n          triggerWorkerProgress(eventTarget, progress);\n        },\n      ],\n    }\n  );\n\n  triggerWorkerProgress(eventTarget, 1);\n\n  segmentationVolume.imageData\n    .getPointData()\n    .getScalars()\n    .setData(newScalarData);\n  segmentationVolume.imageData.modified();\n\n  // update the scalarData in the volume as well\n  segmentationVolume.modified();\n\n  return {\n    volumeId: segmentationVolume.volumeId,\n  };\n}\n\nexport async function convertSurfaceToStackLabelmap() {\n  // TODO\n}\n","import { VolumeViewport, volumeLoader, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport { getSegmentation } from '../../segmentationState';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  convertContourToStackLabelmap,\n  convertContourToVolumeLabelmap,\n} from './convertContourToLabelmap';\nimport { convertSurfaceToVolumeLabelmap } from './convertSurfaceToLabelmap';\nimport { computeStackSegmentationFromVolume } from '../../convertVolumeToStackSegmentation';\nimport { PolySegConversionOptions } from '../../../../types';\n\nexport type RawLabelmapData =\n  | LabelmapSegmentationDataVolume\n  | LabelmapSegmentationDataStack;\n\nexport async function computeLabelmapData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawLabelmapData: RawLabelmapData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.CONTOUR) {\n      rawLabelmapData = await computeLabelmapFromContourSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.SURFACE) {\n      rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(\n        segmentation.segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawLabelmapData) {\n    throw new Error(\n      'Not enough data to convert to surface, currently only support converting volume labelmap to surface if available'\n    );\n  }\n\n  return rawLabelmapData;\n}\n\nasync function computeLabelmapFromContourSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from contour segmentation without providing the viewport'\n    );\n  }\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.CONTOUR;\n\n  const convertFunction = isVolume\n    ? convertContourToVolumeLabelmap\n    : convertContourToStackLabelmap;\n\n  const result = await convertFunction(representationData, {\n    segmentIndices,\n    segmentationRepresentationUID: options.segmentationRepresentationUID,\n    viewport: options.viewport,\n  });\n\n  return result;\n}\n\nasync function computeLabelmapFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<LabelmapSegmentationDataVolume | LabelmapSegmentationDataStack> {\n  const isVolume = options.viewport instanceof VolumeViewport ?? true;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentation = getSegmentation(segmentationId);\n\n  const segmentsGeometryIds = new Map() as Map<number, string>;\n  const representationData = segmentation.representationData.SURFACE;\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentsGeometryIds.set(segmentIndex, geometryId);\n    }\n  });\n\n  if (isVolume && !options.viewport) {\n    // Todo: we don't have support for volume viewport without providing the\n    // viewport, since we need to get the referenced volumeId from the viewport\n    // but we can alternatively provide the volumeId directly, or even better\n    // the target metadata for the volume (spacing, origin, dimensions, etc.)\n    // and then we can create the volume from that\n    throw new Error(\n      'Cannot compute labelmap from surface segmentation without providing the viewport'\n    );\n  }\n\n  let segmentationVolume;\n  if (isVolume) {\n    const defaultActor = options.viewport.getDefaultActor();\n    const { uid: volumeId } = defaultActor;\n    segmentationVolume =\n      await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId);\n  } else {\n    // for stack we basically need to create a volume from the stack\n    // imageIds and then create a segmentation volume from that and finally\n    // convert the surface to a labelmap and later on convert the labelmap\n    // to a stack labelmap\n    const imageIds = (options.viewport as Types.IStackViewport).getImageIds();\n    const volumeId = 'generatedSegmentationVolumeId';\n    const volumeProps = utilities.generateVolumePropsFromImageIds(\n      imageIds,\n      volumeId\n    );\n\n    // we don't need the imageIds for the viewport (e.g., CT), but rather\n    // want to use the imageIds as a reference\n    delete volumeProps.imageIds;\n\n    segmentationVolume = await volumeLoader.createLocalSegmentationVolume(\n      {\n        ...volumeProps,\n        scalarData: volumeProps.scalarData as Types.PixelDataTypedArray,\n        referencedImageIds: imageIds,\n      },\n      volumeId\n    );\n  }\n\n  const result = await convertSurfaceToVolumeLabelmap(\n    { geometryIds: segmentsGeometryIds },\n    segmentationVolume\n  );\n\n  if (isVolume) {\n    return result;\n  }\n\n  // we need to convert the volume labelmap to a stack labelmap\n  const stackData = (await computeStackSegmentationFromVolume({\n    volumeId: segmentationVolume.volumeId,\n  })) as LabelmapSegmentationDataStack;\n\n  return stackData;\n}\n\nexport { computeLabelmapFromContourSegmentation };\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeLabelmapData } from './labelmapComputationStrategies';\nimport { PolySegConversionOptions } from '../../../../types';\n\n/**\n * Computes and adds the labelmap representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddLabelmapRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Labelmap,\n    () => computeLabelmapData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { PolyDataClipCacheType } from '../../../helpers/clipAndCacheSurfacesForViewport';\nimport { RawContourData } from '../contourComputationStrategies';\n\n/**\n * Extracts contour data from the given polyDataCache.\n * @param polyDataCache - The polyData cache containing intersection information.\n * @param segmentIndexMap - Optional map for mapping surface IDs to segment indices.\n * @returns A map of segment indices to an array of contour results.\n */\nexport function extractContourData(\n  polyDataCache: PolyDataClipCacheType,\n  segmentIndexMap?: Map<string, number>\n) {\n  const rawResults = new Map() as RawContourData;\n\n  for (const [cacheId, intersectionInfo] of polyDataCache) {\n    // Todo; fix this\n    const surfaceId = cacheId.split('_')[1];\n\n    for (const [_, result] of intersectionInfo) {\n      if (!result) {\n        continue;\n      }\n      const segmentIndex = Number(surfaceId) || segmentIndexMap?.get(surfaceId);\n\n      if (!segmentIndex) {\n        continue;\n      }\n\n      if (!rawResults.has(segmentIndex)) {\n        rawResults.set(segmentIndex, []);\n      }\n\n      rawResults.get(segmentIndex).push(result);\n    }\n  }\n  return rawResults;\n}\n","import { PlanarFreehandContourSegmentationTool } from '../../../../../tools';\nimport { addAnnotation } from '../../../../annotation/annotationState';\nimport { RawContourData } from '../contourComputationStrategies';\nimport { utilities, type Types } from '@cornerstonejs/core';\n\n/**\n * Creates and adds contour segmentations from a clipped surface.\n *\n * @param rawContourData - The raw contour data.\n * @param viewport - The viewport.\n * @param segmentationId - The segmentation ID.\n */\nexport function createAndAddContourSegmentationsFromClippedSurfaces(\n  rawContourData: RawContourData,\n  viewport: Types.IViewport,\n  segmentationId: string\n) {\n  const annotationUIDsMap = new Map<number, Set<string>>();\n\n  for (const [segmentIndex, contoursData] of rawContourData) {\n    for (const contourData of contoursData) {\n      const { points } = contourData;\n\n      const { lineSegments, linesNumberOfPoints } =\n        _extractLineSegments(contourData);\n\n      // There may be a few lines as the surface might not be closed and could have holes in it.\n      // Currently, we simply render the generated contour as empty fill to indicate\n      // the presence of holes. However, filling the proper area with\n      //  fillAlpha requires further work.\n      for (let i = 0; i < lineSegments.length; i++) {\n        const line = lineSegments[i];\n        const polyline = [];\n\n        for (let j = 0; j < linesNumberOfPoints[i]; j++) {\n          const pointIndex = line[j];\n          polyline.push([\n            points[3 * pointIndex],\n            points[3 * pointIndex + 1],\n            points[3 * pointIndex + 2],\n          ]);\n        }\n\n        if (polyline.length < 3) {\n          continue;\n        }\n\n        const contourSegmentationAnnotation = {\n          annotationUID: utilities.uuidv4(),\n          data: {\n            contour: {\n              closed: true,\n              polyline,\n            },\n            segmentation: {\n              segmentationId,\n              segmentIndex,\n            },\n            handles: {},\n          },\n          handles: {},\n          highlighted: false,\n          autoGenerated: false,\n          invalidated: false,\n          isLocked: false,\n          isVisible: true,\n          metadata: {\n            toolName: PlanarFreehandContourSegmentationTool.toolName,\n            ...viewport.getViewReference(),\n          },\n        };\n\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n\n        const currentSet = annotationUIDsMap.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n      }\n    }\n  }\n\n  return annotationUIDsMap;\n}\n\nconst _extractLineSegments = (contourData) => {\n  const { numberOfCells, lines } = contourData;\n\n  const lineSegments = [];\n  const linesNumberOfPoints = [];\n\n  for (let i = 0; i < lines.length; ) {\n    const pointsInLine = lines[i];\n    linesNumberOfPoints.push(pointsInLine);\n    lineSegments.push(lines.slice(i + 1, i + pointsInLine + 1));\n    i += pointsInLine + 1;\n\n    if (lineSegments.length === numberOfCells) {\n      break;\n    }\n  }\n\n  return { lineSegments, linesNumberOfPoints };\n};\n","import { cache } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation';\nimport {\n  getSegmentation,\n  setSegmentationRepresentationSpecificConfig,\n} from '../../segmentationState';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeSurfaceFromLabelmapSegmentation } from '../Surface/surfaceComputationStrategies';\nimport {\n  SurfaceClipResult,\n  clipAndCacheSurfacesForViewport,\n} from '../../helpers/clipAndCacheSurfacesForViewport';\nimport { extractContourData } from './utils/extractContourData';\nimport { createAndAddContourSegmentationsFromClippedSurfaces } from './utils/createAndAddContourSegmentationsFromClippedSurfaces';\nimport { getToolGroupForViewport } from '../../../../store/ToolGroupManager';\n\n// the map between segment index and the intersection points and lines\nexport type RawContourData = Map<number, SurfaceClipResult[]>;\n\n/**\n * Computes contour data for a given segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for the computation.\n * @returns An object containing the annotation UIDs map.\n * @throws Error if there is not enough data to convert to contour.\n */\nexport async function computeContourData(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  let rawContourData: RawContourData;\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData;\n\n  try {\n    if (representationData.SURFACE) {\n      rawContourData = await computeContourFromSurfaceSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    } else if (representationData.LABELMAP) {\n      rawContourData = await computeContourFromLabelmapSegmentation(\n        segmentationId,\n        {\n          segmentIndices,\n          ...options,\n        }\n      );\n    }\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n\n  if (!rawContourData) {\n    throw new Error(\n      'Not enough data to convert to contour, currently only support converting volume labelmap to contour if available'\n    );\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  // create the new annotations and add them to the segmentation state representation\n  // data for the contour representation\n  const annotationUIDsMap = createAndAddContourSegmentationsFromClippedSurfaces(\n    rawContourData,\n    viewport,\n    segmentationId\n  );\n\n  // make the segmentation configuration fillAlpha 0 since\n  // we don't have proper hole support right now\n  // Todo: add hole support\n  const toolGroupId = getToolGroupForViewport(viewport.id)?.id;\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    {\n      CONTOUR: {\n        fillAlpha: 0,\n      },\n    }\n  );\n\n  return {\n    annotationUIDsMap,\n  };\n}\n\n/**\n * Computes the contour from a labelmap segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns The raw contour data.\n */\nasync function computeContourFromLabelmapSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n) {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from labelmap');\n  }\n\n  const results = await computeSurfaceFromLabelmapSegmentation(\n    segmentationId,\n    options\n  );\n\n  if (!results?.length) {\n    console.error('Failed to convert labelmap to surface or labelmap is empty');\n    return;\n  }\n\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const pointsAndPolys = results.map((surface) => {\n    return {\n      id: surface.segmentIndex.toString(),\n      points: surface.data.points,\n      polys: surface.data.polys,\n      segmentIndex: surface.segmentIndex,\n    };\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    pointsAndPolys,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache);\n\n  return rawResults;\n}\n\n/**\n * Computes the contour from a surface segmentation.\n * @param segmentationId - The ID of the segmentation.\n * @param options - The options for the contour computation.\n * @returns A promise that resolves to the raw contour data.\n * @throws An error if the viewport is not provided.\n */\nasync function computeContourFromSurfaceSegmentation(\n  segmentationId,\n  options: PolySegConversionOptions = {}\n): Promise<RawContourData> {\n  if (!options.viewport) {\n    throw new Error('Viewport is required to compute contour from surface');\n  }\n  const { viewport, segmentationRepresentationUID } = options;\n\n  const segmentIndices = options.segmentIndices?.length\n    ? options.segmentIndices\n    : getUniqueSegmentIndices(segmentationId);\n\n  const segmentIndexToSurfaceId = new Map() as Map<number, string>;\n  const surfaceIdToSegmentIndex = new Map() as Map<string, number>;\n\n  const segmentation = getSegmentation(segmentationId);\n  const representationData = segmentation.representationData.SURFACE;\n\n  const surfacesInfo = [];\n  representationData.geometryIds.forEach((geometryId, segmentIndex) => {\n    if (segmentIndices.includes(segmentIndex)) {\n      segmentIndexToSurfaceId.set(segmentIndex, geometryId);\n      const surface = cache.getGeometry(geometryId)?.data as Types.ISurface;\n      if (surface) {\n        surfacesInfo.push({\n          id: geometryId,\n          points: surface.getPoints(),\n          polys: surface.getPolys(),\n        });\n      }\n    }\n  });\n\n  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {\n    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);\n  });\n\n  const polyDataCache = await clipAndCacheSurfacesForViewport(\n    surfacesInfo,\n    viewport as Types.IVolumeViewport,\n    segmentationRepresentationUID\n  );\n\n  const rawResults = extractContourData(polyDataCache, surfaceIdToSegmentIndex);\n\n  return rawResults;\n}\n\nexport { computeContourFromLabelmapSegmentation };\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { PolySegConversionOptions } from '../../../../types';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeContourData } from './contourComputationStrategies';\n/**\n * Computes and adds the contour representation for a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @param options - Optional parameters for computing the labelmap representation.\n * @param options.segmentIndices - An array of segment indices to include in the labelmap representation.\n * @param options.segmentationRepresentationUID - The UID of the segmentation representation.\n * @returns A promise that resolves when the labelmap representation is computed and added.\n */\nexport function computeAndAddContourRepresentation(\n  segmentationId: string,\n  options: PolySegConversionOptions = {}\n) {\n  return computeAndAddRepresentation(\n    segmentationId,\n    SegmentationRepresentations.Contour,\n    () => computeContourData(segmentationId, options),\n    () => undefined\n  );\n}\n","import { SegmentationRepresentations } from '../../../enums';\nimport { validateLabelmap } from '../../../tools/displayTools/Labelmap';\nimport { SegmentationRepresentationData } from '../../../types';\nimport {\n  findSegmentationRepresentationByUID,\n  getSegmentation,\n} from '../segmentationState';\n\n// Map of conversion paths between source and target representations\n// You should read it as \"source\" -> \"targets\"\nconst conversionPaths = new Map<\n  SegmentationRepresentations,\n  Set<SegmentationRepresentations>\n>([\n  [\n    SegmentationRepresentations.Labelmap,\n    new Set([\n      SegmentationRepresentations.Surface,\n      SegmentationRepresentations.Contour,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Contour,\n    new Set([\n      SegmentationRepresentations.Labelmap,\n      SegmentationRepresentations.Surface,\n    ]),\n  ],\n  [\n    SegmentationRepresentations.Surface,\n    new Set([SegmentationRepresentations.Labelmap]),\n  ],\n]);\n\n/**\n * Determines whether the requested representation can be computed, based on\n * the existing representation types and available conversion paths.\n * This is used in the labelmapDisplay and surfaceDisplay logic if the\n * requested representation is not available whether we can use the existing\n * representation to compute the requested representation. You can checkout the polySeg\n * examples to see how this is used polyDataActorManipulationTools and others\n *\n * @param segmentationRepresentationUID - The UID of the desired segmentation representation.\n * @returns true if the requested representation can be computed, otherwise false.\n */\nfunction canComputeRequestedRepresentation(\n  segmentationRepresentationUID: string\n): boolean {\n  const representationInfo = findSegmentationRepresentationByUID(\n    segmentationRepresentationUID\n  );\n\n  if (!representationInfo?.segmentationRepresentation) {\n    return false;\n  }\n\n  const { segmentationRepresentation } = representationInfo;\n  const { type: representationType, polySeg } = segmentationRepresentation;\n\n  if (!polySeg || !polySeg.enabled) {\n    return false;\n  }\n\n  const { representationData } = getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  const existingRepresentationTypes =\n    getExistingRepresentationTypes(representationData);\n\n  return existingRepresentationTypes.some((existingRepresentationType) =>\n    canConvertFromTo(existingRepresentationType, representationType)\n  );\n}\n\n/**\n * Retrieves the existing representation types for the given representationData\n * by verifying the validity of each representation type.\n *\n * @param representationData - The representation data\n * @returns supportedTypes - An array of valid representation types\n */\nfunction getExistingRepresentationTypes(\n  representationData: SegmentationRepresentationData\n): string[] {\n  const supportedTypes: string[] = [];\n\n  Object.keys(representationData).forEach((representationType) => {\n    const representationTypeData = representationData[representationType];\n\n    let validateFn;\n    switch (representationType) {\n      case SegmentationRepresentations.Labelmap:\n        validateFn = validateLabelmap;\n        break;\n      // Todo: add validation for other representation types\n    }\n\n    if (validateFn) {\n      try {\n        validateFn(representationTypeData);\n        supportedTypes.push(representationType);\n      } catch (error) {\n        console.warn(\n          `Validation failed for labelmap of type ${representationType}`\n        );\n      }\n    } else {\n      supportedTypes.push(representationType);\n    }\n  });\n\n  return supportedTypes;\n}\n\nasync function canConvertFromTo(fromRepresentationType, toRepresentationType) {\n  return (\n    conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||\n    false\n  );\n}\n\nexport { canComputeRequestedRepresentation };\n","import { getWebWorkerManager } from '@cornerstonejs/core';\n\nlet registered = false;\n\nexport function registerPolySegWorker() {\n  if (registered) {\n    return;\n  }\n\n  registered = true;\n\n  const workerFn = () => {\n    // @ts-ignore\n    return new Worker(\n      // @ts-ignore\n      new URL('../../../workers/polySegConverters', import.meta.url),\n      {\n        name: 'polySeg',\n      }\n    );\n  };\n\n  const workerManager = getWebWorkerManager();\n\n  const options = {\n    maxWorkerInstances: 1, // Todo, make this configurable\n    autoTerminateOnIdle: {\n      enabled: true,\n      idleTimeThreshold: 2000,\n    },\n  };\n\n  workerManager.registerWorker('polySeg', workerFn, options);\n}\n","import { invalidateBrushCursor } from '../../utilities/segmentation/';\nimport {\n  getSegmentation,\n  getToolGroupIdsWithSegmentation,\n} from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event. Also it invalidates the brush cursor for all toolGroups that\n * has the segmentationId as active segment (since the brush cursor color\n * should change as well)\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (typeof segmentIndex === 'string') {\n    console.warn('segmentIndex is a string, converting to number');\n    segmentIndex = Number(segmentIndex);\n  }\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n\n  // get all toolGroups that has the segmentationId as active\n  // segment and call invalidateBrushCursor on them\n  const toolGroups = getToolGroupIdsWithSegmentation(segmentationId);\n  toolGroups.forEach((toolGroupId) => {\n    invalidateBrushCursor(toolGroupId);\n  });\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import cloneDeep from 'lodash.clonedeep';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport getDefaultSurfaceConfig from '../../tools/displayTools/Surface/surfaceConfig';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\nconst defaultSurfaceConfig = getDefaultSurfaceConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n    [SegmentationRepresentations.Surface]: defaultSurfaceConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): Types.ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  getNextColorLUTIndex(): number {\n    return this.state.colorLUT.length;\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations?.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig,\n    options?: {\n      clear: false;\n    }\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    if (!segmentationRepresentation.segmentSpecificConfig || options?.clear) {\n      segmentationRepresentation.segmentSpecificConfig = {};\n    }\n\n    Object.keys(config).forEach((key) => {\n      segmentationRepresentation.segmentSpecificConfig[key] = config[key];\n    });\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: Types.ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.warn('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = cloneDeep(colorLUT);\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { SegmentationRepresentations } from '../../../enums';\nimport {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\nimport type { ContourSegmentationData } from '../../../types/ContourTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n  const isContourRepresentation =\n    representation.type === SegmentationRepresentations.Contour;\n  let data = representation.data ? { ...representation.data } : null;\n\n  // Contour representation data is defined internally\n  data = !data && isContourRepresentation ? {} : data;\n\n  // Data cannot be undefined for labelmap and surface\n  if (!data) {\n    throw new Error('Segmentation representation data may not be undefined');\n  }\n\n  if (isContourRepresentation) {\n    const contourData = <ContourSegmentationData>data;\n\n    // geometryIds will be removed in a near future. It still exist in the\n    // code for compatibility only but it is optional from now on.\n    contourData.geometryIds = contourData.geometryIds ?? [];\n\n    // Make sure annotationUIDsMap is defined because an empty contour is\n    // created before adding contour annotations to the map. Also it prevents\n    // breaking legacy code after moving from geometryIds to annotationUIDsMap.\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n  }\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type { Types } from '@cornerstonejs/core';\nimport type {\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Finds all segmentation representations with the given segmentationId.\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of found segmentation representations.\n */\nfunction getSegmentationIdRepresentations(segmentationId) {\n  const allRepresentations = getAllSegmentationRepresentations() || {};\n  const foundRepresentations = [];\n\n  for (const toolGroupId in allRepresentations) {\n    const toolGroupRepresentations = allRepresentations[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) => representation.segmentationId === segmentationId\n    );\n\n    if (foundRepresentation) {\n      foundRepresentations.push(foundRepresentation);\n    }\n  }\n\n  return foundRepresentations;\n}\n\n/**\n * Finds a segmentation representation by its UID.\n *\n * @param segmentationRepresentationUID - The UID of the segmentation representation to find.\n * @returns The found segmentation representation, or undefined if not found.\n */\nfunction findSegmentationRepresentationByUID(\n  segmentationRepresentationUID: string\n): {\n  toolGroupId: string;\n  segmentationRepresentation: ToolGroupSpecificRepresentation;\n} {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return {\n        segmentationRepresentation: foundRepresentation,\n        toolGroupId,\n      };\n    }\n  }\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nfunction getToolGroupIdFromSegmentationRepresentationUID(\n  segmentationRepresentationUID: string\n): string {\n  const allToolGroupRepresentations = getAllSegmentationRepresentations() || [];\n\n  const toolGroupIds = Object.keys(allToolGroupRepresentations);\n\n  for (const toolGroupId of toolGroupIds) {\n    const toolGroupRepresentations =\n      getAllSegmentationRepresentations()[toolGroupId];\n\n    const foundRepresentation = toolGroupRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (foundRepresentation) {\n      return toolGroupId;\n    }\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Removes all segmentation representations associated with a tool group.\n * @param toolGroupId - The ID of the tool group.\n */\nfunction removeSegmentationRepresentations(toolGroupId: string): void {\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((representation) => {\n    removeSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n  });\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): Types.ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\nfunction getNextColorLUTIndex(): number {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getNextColorLUTIndex();\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: Types.ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  removeSegmentationRepresentations,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  getSegmentationIdRepresentations,\n  // color\n  addColorLUT,\n  getColorLUT,\n  getNextColorLUTIndex,\n  removeColorLUT,\n  //\n  findSegmentationRepresentationByUID,\n  getToolGroupIdFromSegmentationRepresentationUID,\n};\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\nimport { setSegmentationDirty } from '../../utilities/segmentation/getUniqueSegmentIndices';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  // set it to dirty to force the next call to getUniqueSegmentIndices to\n  // recalculate the segment indices\n  setSegmentationDirty(segmentationId);\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _auxiliaryEventNames: string[];\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n    this._auxiliaryEventNames = this._options.auxiliaryEventNames || [];\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /**\n   * Sets a synchronizer enabled\n   */\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const viewport =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    if (!viewport) {\n      console.warn(\n        `Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`\n      );\n      return;\n    }\n\n    const element = viewport.element;\n\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n\n    if (this._auxiliaryEventNames.length) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        element.addEventListener(eventName, this._onEvent.bind(this));\n      });\n    }\n\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n\n    //@ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n\n    if (this._auxiliaryEventNames) {\n      this._auxiliaryEventNames.forEach((eventName) => {\n        //@ts-ignore\n        element.removeEventListener(eventName, this._eventHandler);\n      });\n    }\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        const result = this._eventHandler(\n          this,\n          sourceViewport,\n          targetViewport,\n          sourceEvent,\n          this._options\n        );\n\n        // if the result is a promise, then add it to the list of promises\n        // to wait for before setting _ignoreFiredEvents to false\n        if (result instanceof Promise) {\n          promises.push(result);\n        }\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(vUid.renderingEngineId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const viewport = renderingEngine.getViewport(vUid.viewportId);\n\n      if (!viewport) {\n        return;\n      }\n\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId?: string\n): IToolGroup | undefined {\n  if (!renderingEngineId) {\n    renderingEngineId = getRenderingEngines().find((re) =>\n      re.getViewports().find((vp) => vp.id === viewportId)\n    )?.id;\n  }\n\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Check if a given tool is already registered\n * @param ToolClass - A tool class to check\n * @returns True if the tool is alredy registered or false otherwise\n */\nexport function hasTool(ToolClass): boolean {\n  const toolName = ToolClass.toolName;\n\n  return !!(toolName && state.tools[toolName]);\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  cameraResetEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n  imageChangeEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  cameraResetEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n  imageChangeEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n  cameraResetEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n\n  // labelmap\n  imageChangeEventListener.disable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n  cameraResetEventDispatcher.disable(element);\n\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nimport cloneDeep from 'lodash.clonedeep';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = {\n    ...cloneDeep({\n      ...defaultState,\n      svgNodeCache: {},\n    }),\n    svgNodeCache: {\n      ...defaultState.svgNodeCache,\n    },\n  };\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function presentationViewSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  _sourceEvent,\n  options?: Types.ViewPresentationSelector\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const presentationView = sViewport.getViewPresentation(options);\n\n  tViewport.setViewPresentation(presentationView);\n\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string,\n  options?: Types.ViewPresentation\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    presentationViewSyncCallback,\n    options\n  );\n\n  return presentationView;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param modifiedEvent - The COLORMAP_MODIFIED or VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  modifiedEvent: any,\n  options?: any\n): void {\n  const eventDetail = modifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n  if (options?.syncColormap && colormap) {\n    tProperties.colormap = colormap;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    const isFusion = tViewport._actors && tViewport._actors.size > 1;\n    if (isFusion) {\n      tViewport.setProperties(tProperties, volumeId);\n    } else {\n      tViewport.setProperties(tProperties);\n    }\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n  syncColormap: boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options: VOISynchronizerOptions\n): Synchronizer {\n  //  = { syncInvertState: true } if options is not provided or undefined or {}\n  options = Object.assign(\n    { syncInvertState: true, syncColormap: true },\n    options\n  );\n\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    {\n      auxiliaryEventNames: [Enums.Events.COLORMAP_MODIFIED],\n      ...options,\n    }\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    targetId,\n    sourceId\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function imageSliceSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId) as\n    | Types.IVolumeViewport\n    | Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  let imageIndexToSet = closestImageIdIndex2.index;\n  if (tViewport instanceof VolumeViewport) {\n    // since in case of volume viewport our stack is reversed, we should\n    // reverse the index as well\n    imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n  }\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: imageIndexToSet,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport | Types.IVolumeViewport,\n  viewport2: Types.IStackViewport | Types.IVolumeViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `ImageSliceSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createImageSliceSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    imageSliceSyncCallback,\n    {\n      auxiliaryEventNames: [VOLUME_NEW_IMAGE],\n    }\n  );\n\n  return stackImageSynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the slab thickness.\n */\nexport default function slabThicknessSyncCallback(\n  _synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  const slabThickness = (\n    sViewport as Types.IVolumeViewport\n  ).getSlabThickness?.();\n  if (!slabThickness) {\n    return;\n  }\n  (tViewport as Types.IVolumeViewport).setSlabThickness?.(slabThickness);\n  tViewport.render();\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback` based on presentation view\n * values and not based on absolute camera positions.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createPresentationViewSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const presentationView = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    slabThicknessSyncCallback\n  );\n\n  return presentationView;\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\n\n// for backward compatibility\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\n\nexport {\n  createCameraPositionSynchronizer,\n  createPresentationViewSynchronizer,\n  createVOISynchronizer,\n  createZoomPanSynchronizer,\n  createImageSliceSynchronizer,\n  createStackImageSynchronizer,\n  createSlabThicknessSynchronizer,\n};\n","import { AnnotationTool } from './base';\n\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAllAnnotations,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nenum AdvancedMagnifyToolActions {\n  ShowZoomFactorsList = 'showZoomFactorsList',\n}\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n  static Actions = AdvancedMagnifyToolActions;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 3,\n          zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: {\n          showZoomFactorsList: {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const canvasHandlePoints = this._getCanvasHandlePoints(\n      canvasPos,\n      radius\n    ) as [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        // this means that the last coordinate for the points\n        // is 0 and should not be used for calculations\n        isCanvasAnnotation: true,\n        handles: {\n          points: canvasHandlePoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { canvas: canvasDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            const point = annotationPoints[i];\n            point[0] += canvasDelta[0];\n            point[1] += canvasDelta[1];\n            annotation.invalidated = true;\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  onSetToolDisabled = () => {\n    // reset\n    this.magnifyViewportManager.dispose();\n    // remove the annotations from the state for that toolGroup\n    const annotations = getAllAnnotations();\n    annotations.forEach((annotation) => {\n      if (annotation.metadata.toolName === this.getToolName()) {\n        removeAnnotation(annotation.annotationUID);\n      }\n    });\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points;\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += canvasDelta[0];\n      point[1] += canvasDelta[1];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const canvasDelta = deltaPoints.canvas;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += canvasDelta[0];\n        point[1] += canvasDelta[1];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points;\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newCanvasHandlePoints = this._getCanvasHandlePoints(\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newCanvasHandlePoints[0];\n    points[1] = newCanvasHandlePoints[1];\n    points[2] = newCanvasHandlePoints[2];\n    points[3] = newCanvasHandlePoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!filteredAnnotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points;\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineWidth: 5,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n    return [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0], // left\n    ];\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { ToolGroupManager } from '../store';\nimport {\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\n\nclass AnnotationEraserTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'mouse');\n  };\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    return this._deleteNearbyAnnotations(evt, 'touch');\n  };\n\n  _deleteNearbyAnnotations(\n    evt: EventTypes.InteractionEventType,\n    interactionType: string\n  ): boolean {\n    const { renderingEngineId, viewportId, element, currentPoints } =\n      evt.detail;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup) {\n      return false;\n    }\n\n    const tools = toolGroup._toolInstances;\n    const annotationsToRemove = [];\n\n    for (const toolName in tools) {\n      const toolInstance = tools[toolName];\n\n      if (\n        typeof toolInstance.isPointNearTool !== 'function' ||\n        typeof toolInstance.filterInteractableAnnotationsForElement !==\n          'function'\n      ) {\n        continue;\n      }\n\n      const annotations = getAnnotations(toolName, element);\n\n      if (!annotations.length) {\n        continue;\n      }\n\n      const interactableAnnotations =\n        toolInstance.filterInteractableAnnotationsForElement(\n          element,\n          annotations\n        ) || [];\n\n      for (const annotation of interactableAnnotations) {\n        if (\n          toolInstance.isPointNearTool(\n            element,\n            annotation,\n            currentPoints.canvas,\n            10,\n            interactionType\n          )\n        ) {\n          annotationsToRemove.push(annotation.annotationUID);\n        }\n      }\n    }\n\n    for (const annotationUID of annotationsToRemove) {\n      setAnnotationSelected(annotationUID);\n      removeAnnotation(annotationUID);\n    }\n\n    evt.preventDefault();\n\n    return true;\n  }\n}\n\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: false,\n\n        viewportIndicatorsConfig: {\n          radius: 5,\n          x: null,\n          y: null,\n        },\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  resetCrosshairs = () => {\n    const viewportsInfo = this._getViewportsInfo();\n    for (const viewportInfo of viewportsInfo) {\n      const { viewportId, renderingEngineId } = viewportInfo;\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { viewport } = enabledElement;\n      const resetPan = true;\n      const resetZoom = true;\n      const resetToCenter = true;\n      const resetRotation = true;\n      const suppressEvents = true;\n      viewport.resetCamera(\n        resetPan,\n        resetZoom,\n        resetToCenter,\n        resetRotation,\n        suppressEvents\n      );\n      (viewport as Types.IVolumeViewport).resetSlabThickness();\n      const { element } = viewport;\n      let annotations = this._getAnnotations(enabledElement);\n      annotations = this.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n      if (annotations.length) {\n        removeAnnotation(annotations[0].annotationUID);\n      }\n      viewport.render();\n    }\n\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      console.warn(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n      return;\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  onResetCamera = (evt) => {\n    this.resetCrosshairs();\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      const { viewportIndicatorsConfig } = this.configuration;\n\n      const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n      const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n      const referenceColorCoordinates = [\n        clientWidth * xOffset,\n        clientHeight * yOffset,\n      ];\n\n      const circleRadius =\n        viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates as Types.Point2,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    const annotations =\n      getAnnotations(this.getToolName(), viewport.element) || [];\n    const viewportIds = this._getViewportsInfo().map(\n      ({ viewportId }) => viewportId\n    );\n\n    // filter the annotations to only keep that are for this toolGroup\n    const toolGroupAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      return viewportIds.includes(data.viewportId);\n    });\n\n    return toolGroupAnnotations;\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { type Types, utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const volumeId = this.getTargetVolumeId(viewport);\n\n    if (!volumeId) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  private _hasBeenRemoved = false;\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      if (this._hasBeenRemoved) {\n        return;\n      }\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n    this._hasBeenRemoved = true;\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n    this._hasBeenRemoved = false;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElementByIds,\n  getRenderingEngines,\n} from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n  _resizeObservers = new Map();\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n\n    this._subscribeToViewportEvents();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n    this._unsubscribeToViewportNewVolumeSet();\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  resize = (viewportId) => {\n    const orientationMarker = this.orientationMarkers[viewportId];\n    if (!orientationMarker) {\n      return;\n    }\n\n    const { orientationWidget } = orientationMarker;\n    orientationWidget.updateViewport();\n  };\n\n  _unsubscribeToViewportNewVolumeSet() {\n    const unsubscribe = () => {\n      const viewportsInfo = this._getViewportsInfo();\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const { viewport } = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n        const { element } = viewport;\n\n        element.removeEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          this.initViewports.bind(this)\n        );\n\n        const resizeObserver = this._resizeObservers.get(viewportId);\n        resizeObserver.unobserve(element);\n      });\n    };\n\n    eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\n        return;\n      }\n      unsubscribe();\n      this.initViewports();\n    });\n  }\n\n  _subscribeToViewportEvents() {\n    const subscribeToElementResize = () => {\n      const viewportsInfo = this._getViewportsInfo();\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const { viewport } = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n        const { element } = viewport;\n        this.initViewports();\n\n        element.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          this.initViewports.bind(this)\n        );\n\n        const resizeObserver = new ResizeObserver(() => {\n          // Todo: i wish there was a better way to do this\n          setTimeout(() => {\n            const element = getEnabledElementByIds(\n              viewportId,\n              renderingEngineId\n            );\n            if (!element) {\n              return;\n            }\n            const { viewport } = element;\n            this.resize(viewportId);\n            viewport.render();\n          }, 100);\n        });\n\n        resizeObserver.observe(element);\n\n        this._resizeObservers.set(viewportId, resizeObserver);\n      });\n    };\n\n    subscribeToElementResize();\n\n    eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n      if (evt.detail.toolGroupId !== this.toolGroupId) {\n        return;\n      }\n\n      subscribeToElementResize();\n      this.initViewports();\n    });\n  }\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    viewports.forEach((viewport) => {\n      if (!viewport.getWidget(this.getToolName())) {\n        this.addAxisActorInViewport(viewport);\n      }\n    });\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    viewport.addWidget(this.getToolName(), orientationWidget);\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    // This occurs when the mouse event is fired but the mouse hasn't moved a full pixel yet (high resolution mice)\n    if (\n      deltaPointsWorld[0] === 0 &&\n      deltaPointsWorld[1] === 0 &&\n      deltaPointsWorld[2] === 0\n    ) {\n      return;\n    }\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { type Types, getEnabledElementByViewportId } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewportId: string;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport?.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewportId: sourceViewport.id,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolConfiguration = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewportId } = this.editData;\n\n    let renderStatus = false;\n\n    // we need to grab the viewport again since there might have been\n    // a change in the viewport state since the last time we cached it\n    const { viewport: sourceViewport } =\n      getEnabledElementByViewportId(sourceViewportId) || {};\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    if (canvasCoordinates.length < 2) {\n      return renderStatus;\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (\n      this.editData.annotation &&\n      this.editData.annotation.data.viewportId == viewport.id\n    ) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width / window.devicePixelRatio || 1,\n      height: canvas.height / window.devicePixelRatio || 1,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  ContourAnnotation,\n} from '../types';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates } from '../enums';\nimport { ToolGroupManager } from '../store';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport type { ISculptToolShape } from '../types/ISculptToolShape';\nimport { distancePointToContour } from './distancePointToContour';\n\nexport type SculptData = {\n  mousePoint: Types.Point3;\n  mouseCanvasPoint: Types.Point2;\n  points: Array<Types.Point3>;\n  maxSpacing: number;\n  element: HTMLDivElement;\n};\n\ntype CommonData = {\n  activeAnnotationUID: string | null;\n  viewportIdsToRender: any[];\n  isEditingOpenContour: boolean;\n  canvasLocation: Types.Point2 | undefined;\n};\n\n/**\n * This tool allows modifying the contour data for planar freehand by sculpting\n * it externally using another shape to push the contour in one direction or the other.\n */\nclass SculptorTool extends BaseTool {\n  static toolName: string;\n  registeredShapes = new Map();\n  private isActive = false;\n  private selectedShape: string;\n  private commonData: CommonData = {\n    activeAnnotationUID: null,\n    viewportIdsToRender: [],\n    isEditingOpenContour: false,\n    canvasLocation: undefined,\n  };\n  private sculptData?: SculptData;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        minSpacing: 1,\n        referencedToolNames: [\n          'PlanarFreehandROI',\n          'PlanarFreehandContourSegmentationTool',\n        ],\n        toolShape: 'circle',\n        referencedToolName: 'PlanarFreehandROI',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n    this.setToolShape(this.configuration.toolShape);\n  }\n\n  /**\n   * Register different tool shapes for sculptor tool\n   * @param shapeName name of shape\n   * @param shapeClass shape class\n   */\n  registerShapes<T extends ISculptToolShape>(\n    shapeName: string,\n    shapeClass: new () => T\n  ): void {\n    const shape = new shapeClass();\n    this.registeredShapes.set(shapeName, shape);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const element = eventData.element;\n\n    this.configureToolSize(evt);\n    this.selectFreehandTool(eventData);\n\n    if (this.commonData.activeAnnotationUID === null) {\n      return;\n    }\n\n    this.isActive = true;\n\n    hideElementCursor(element);\n    this.activateModify(element);\n    return true;\n  };\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.configureToolSize(evt);\n      this.updateCursor(evt);\n    } else {\n      this.commonData.canvasLocation = undefined;\n    }\n  };\n\n  /**\n   * Sculpts the freehand ROI with freehandSculpter tool, moving,\n   * adding and removing handles as necessary.\n   *\n   * @param eventData - Data object associated with the event.\n   * @param points - Array of points\n   */\n  protected sculpt(eventData: any, points: Array<Types.Point3>): void {\n    const config = this.configuration;\n    const element = eventData.element;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\n\n    this.sculptData = {\n      mousePoint: eventData.currentPoints.world,\n      mouseCanvasPoint: eventData.currentPoints.canvas,\n      points,\n      maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n      element: element,\n    };\n\n    const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n\n    if (pushedHandles.first !== undefined) {\n      this.insertNewHandles(pushedHandles);\n    }\n  }\n\n  /**\n   * Interpolates or fills in points between two points within a specified\n   * maximum spacing constraint.\n   */\n  protected interpolatePointsWithinMaxSpacing(\n    i: number,\n    points: Array<Types.Point3>,\n    indicesToInsertAfter: Array<number>,\n    maxSpacing: number\n  ): void {\n    const { element } = this.sculptData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const nextHandleIndex = contourIndex(i + 1, points.length);\n\n    const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n    const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n\n    const distanceToNextHandle = point.distanceToPoint(\n      currentCanvasPoint,\n      nextCanvasPoint\n    );\n\n    if (distanceToNextHandle > maxSpacing) {\n      indicesToInsertAfter.push(i);\n    }\n  }\n\n  /**\n   * Updates cursor size\n   *\n   * @param evt - The event\n   */\n  private updateCursor(evt: EventTypes.InteractionEventType): void {\n    const eventData = evt.detail;\n    const element = eventData.element;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    this.commonData.viewportIdsToRender = [viewport.id];\n\n    const annotations = this.filterSculptableAnnotationsForElement(element);\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const activeAnnotation = annotations.find(\n      (annotation) =>\n        annotation.annotationUID === this.commonData.activeAnnotationUID\n    );\n\n    this.commonData.canvasLocation = eventData.currentPoints.canvas;\n\n    if (this.isActive) {\n      activeAnnotation.highlighted = true;\n    } else {\n      const cursorShape = this.registeredShapes.get(this.selectedShape);\n      const canvasCoords = eventData.currentPoints.canvas;\n      cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      this.commonData.viewportIdsToRender\n    );\n  }\n\n  /**\n   * Returns sculptable freehand ROI annotations\n   *\n   * @param element - The viewport element\n   */\n  private filterSculptableAnnotationsForElement(\n    element: HTMLDivElement\n  ): ContourAnnotation[] {\n    const config = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    const sculptableAnnotations = [];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n\n    config.referencedToolNames.forEach((referencedToolName: string) => {\n      const annotations = getAnnotations(referencedToolName, element);\n      if (annotations) {\n        sculptableAnnotations.push(...annotations);\n      }\n    });\n\n    return toolInstance.filterInteractableAnnotationsForElement(\n      element,\n      sculptableAnnotations\n    );\n  }\n\n  /** Just pass the tool size interaction onto the internal tool size */\n  private configureToolSize(evt: EventTypes.InteractionEventType): void {\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\n    cursorShape.configureToolSize(evt);\n  }\n\n  /**\n   * Inserts additional handles in sparsely sampled regions of the contour\n   */\n  private insertNewHandles(pushedHandles: {\n    first: number;\n    last: number | undefined;\n  }): void {\n    const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n    let newIndexModifier = 0;\n    for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n      const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n\n      this.insertHandleRadially(insertIndex);\n      newIndexModifier++;\n    }\n  }\n\n  /**\n   * Returns an array of indicies that describe where new handles should be inserted\n   *\n   * @param pushedHandles - The first and last handles that were pushed.\n   */\n  private findNewHandleIndices(pushedHandles: {\n    first: number | undefined;\n    last: number | undefined;\n  }): Array<number> {\n    const { points, maxSpacing } = this.sculptData;\n    const indicesToInsertAfter = [];\n\n    for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n      this.interpolatePointsWithinMaxSpacing(\n        i,\n        points,\n        indicesToInsertAfter,\n        maxSpacing\n      );\n    }\n\n    return indicesToInsertAfter;\n  }\n\n  /**\n   * Inserts a handle on the surface of the circle defined by toolSize and the mousePoint.\n   *\n   * @param insertIndex - The index to insert the new handle.\n   */\n  private insertHandleRadially(insertIndex: number): void {\n    const { points } = this.sculptData;\n\n    if (\n      insertIndex > points.length - 1 &&\n      this.commonData.isEditingOpenContour\n    ) {\n      return;\n    }\n\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\n\n    const previousIndex = insertIndex - 1;\n    const nextIndex = contourIndex(insertIndex, points.length);\n    const insertPosition = cursorShape.getInsertPosition(\n      previousIndex,\n      nextIndex,\n      this.sculptData\n    );\n    const handleData = insertPosition;\n\n    points.splice(insertIndex, 0, handleData);\n  }\n\n  /**\n   * Select the freehand tool to be edited\n   *\n   * @param eventData - Data object associated with the event.\n   */\n  private selectFreehandTool(eventData: any): void {\n    const closestAnnotationUID =\n      this.getClosestFreehandToolOnElement(eventData);\n\n    if (closestAnnotationUID === undefined) {\n      return;\n    }\n\n    this.commonData.activeAnnotationUID = closestAnnotationUID;\n  }\n\n  /**\n   * Finds the nearest handle to the mouse cursor for all freehand\n   * data on the element.\n   *\n   * @param eventData - Data object associated with the event.\n   */\n  private getClosestFreehandToolOnElement(eventData: any): string {\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const config = this.configuration;\n\n    const annotations = this.filterSculptableAnnotationsForElement(element);\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const canvasPoints = eventData.currentPoints.canvas;\n\n    const closest = {\n      distance: Infinity,\n      toolIndex: undefined,\n      annotationUID: undefined,\n    };\n\n    for (let i = 0; i < annotations?.length; i++) {\n      if (annotations[i].isLocked || !annotations[i].isVisible) {\n        continue;\n      }\n\n      const distanceFromTool = distancePointToContour(\n        viewport,\n        annotations[i],\n        canvasPoints\n      );\n\n      if (distanceFromTool === -1) {\n        continue;\n      }\n\n      if (distanceFromTool < closest.distance) {\n        closest.distance = distanceFromTool;\n        closest.toolIndex = i;\n        closest.annotationUID = annotations[i].annotationUID;\n      }\n    }\n\n    this.commonData.isEditingOpenContour =\n      !annotations[closest.toolIndex].data.contour.closed;\n\n    config.referencedToolName =\n      annotations[closest.toolIndex].metadata.toolName;\n\n    return closest.annotationUID;\n  }\n\n  /**\n   * Event handler for MOUSE_UP during the active loop.\n   *\n   * @param evt - The event\n   */\n  private endCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const config = this.configuration;\n    const enabledElement = getEnabledElement(element);\n\n    this.isActive = false;\n    this.deactivateModify(element);\n    resetElementCursor(element);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n\n    const annotations = this.filterSculptableAnnotationsForElement(element);\n\n    const activeAnnotation = annotations.find(\n      (annotation) =>\n        annotation.annotationUID === this.commonData.activeAnnotationUID\n    );\n\n    if (toolInstance.configuration.calculateStats) {\n      activeAnnotation.invalidated = true;\n    }\n\n    triggerAnnotationModified(activeAnnotation, element);\n  };\n\n  /**\n   * Event handler for MOUSE_DRAG during the active loop.\n   *\n   * @param evt - The event\n   */\n  private dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const element = eventData.element;\n\n    this.updateCursor(evt);\n\n    const annotations = this.filterSculptableAnnotationsForElement(element);\n    const activeAnnotation = annotations.find(\n      (annotation) =>\n        annotation.annotationUID === this.commonData.activeAnnotationUID\n    );\n\n    if (!annotations?.length || !this.isActive) {\n      return;\n    }\n\n    const points = activeAnnotation.data.contour.polyline;\n\n    this.sculpt(eventData, points);\n  };\n\n  /**\n   * Attaches event listeners to the element such that is is visible, modifiable, and new data can be created.\n   * @param element - - The viewport element to attach event listeners to.\n   */\n  protected activateModify(element: HTMLDivElement): void {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this.endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this.endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this.dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this.endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this.endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this.dragCallback as EventListener\n    );\n  }\n\n  /**\n   * Removes event listeners from the element.\n   * @param element - The viewport element to remove event listeners from.\n   */\n  protected deactivateModify(element: HTMLDivElement): void {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this.endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this.endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this.dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this.endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this.endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this.dragCallback as EventListener\n    );\n  }\n\n  /**\n   * Sets the tool shape to the specified tool\n   */\n  public setToolShape(toolShape: string): void {\n    this.selectedShape =\n      this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n  }\n\n  /**\n   * Renders the cursor annotation on screen so that the user can choose the\n   * annotation size.\n   */\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const viewportIdsToRender = this.commonData.viewportIdsToRender;\n\n    if (\n      !this.commonData.canvasLocation ||\n      this.mode !== ToolModes.Active ||\n      !viewportIdsToRender.includes(viewport.id)\n    ) {\n      return;\n    }\n\n    const annotations = this.filterSculptableAnnotationsForElement(element);\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    let color = getStyleProperty(\n      'color',\n      styleSpecifier,\n      AnnotationStyleStates.Default,\n      this.mode\n    );\n\n    if (this.isActive) {\n      color = getStyleProperty(\n        'color',\n        styleSpecifier,\n        AnnotationStyleStates.Highlighted,\n        this.mode\n      );\n    }\n\n    const cursorShape = this.registeredShapes.get(this.selectedShape);\n\n    cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n      color,\n    });\n  }\n}\n\n/**\n * Function calculates the index of a contour given a position `i` and the length of the contour.\n * It ensures that the resulting index is within the bounds of the contour by wrapping around if needed.\n * This function is useful for obtaining neighboring indices or other related indices within the contour,\n * such as for navigating or accessing elements in a circular or looped structure\n */\nexport const contourIndex = (i: number, length: number): number => {\n  return (i + length) % length;\n};\n\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          closePath: true,\n          lineWidth: 2,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPath(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { getEnabledElementByIds, VolumeViewport } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n    const deltaPointY = deltaPoints.canvas[1];\n\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = this.getTargetVolumeId(viewport);\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = viewport.getNumberOfSlices();\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n        scrollSlabs: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const volumeId = this.getTargetVolumeId(viewport);\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n      scrollSlabs: this.configuration.scrollSlabs,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport {\n  eventTarget,\n  getEnabledElement,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  cleanUp: () => void;\n  _resizeObservers = new Map();\n  _viewportAddedListener: (evt: any) => void;\n  _hasResolutionChanged = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntry = viewport.getDefaultActor();\n    const actor = actorEntry.actor as Types.VolumeActor;\n    const mapper = actor.getMapper();\n    const originalSampleDistance = mapper.getSampleDistance();\n\n    if (!this._hasResolutionChanged) {\n      mapper.setSampleDistance(originalSampleDistance * 2);\n      this._hasResolutionChanged = true;\n\n      if (this.cleanUp !== null) {\n        // Clean up previous event listener\n        document.removeEventListener('mouseup', this.cleanUp);\n      }\n\n      this.cleanUp = () => {\n        mapper.setSampleDistance(originalSampleDistance);\n        viewport.render();\n        this._hasResolutionChanged = false;\n      };\n\n      document.addEventListener('mouseup', this.cleanUp, { once: true });\n    }\n    return true;\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n    return viewports;\n  };\n\n  onSetToolActive = () => {\n    const subscribeToElementResize = () => {\n      const viewportsInfo = this._getViewportsInfo();\n      viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        if (!this._resizeObservers.has(viewportId)) {\n          const { viewport } = getEnabledElementByIds(\n            viewportId,\n            renderingEngineId\n          ) || { viewport: null };\n\n          if (!viewport) {\n            return;\n          }\n\n          const { element } = viewport;\n\n          const resizeObserver = new ResizeObserver(() => {\n            const element = getEnabledElementByIds(\n              viewportId,\n              renderingEngineId\n            );\n            if (!element) {\n              return;\n            }\n            const { viewport } = element;\n            viewport.resetCamera();\n            viewport.render();\n          });\n\n          resizeObserver.observe(element);\n          this._resizeObservers.set(viewportId, resizeObserver);\n        }\n      });\n    };\n\n    subscribeToElementResize();\n\n    this._viewportAddedListener = (evt) => {\n      if (evt.detail.toolGroupId === this.toolGroupId) {\n        subscribeToElementResize();\n      }\n    };\n\n    eventTarget.addEventListener(\n      Events.TOOLGROUP_VIEWPORT_ADDED,\n      this._viewportAddedListener\n    );\n  };\n\n  onSetToolDisabled = () => {\n    // Disconnect all resize observers\n    this._resizeObservers.forEach((resizeObserver, viewportId) => {\n      resizeObserver.disconnect();\n      this._resizeObservers.delete(viewportId);\n    });\n\n    if (this._viewportAddedListener) {\n      eventTarget.removeEventListener(\n        Events.TOOLGROUP_VIEWPORT_ADDED,\n        this._viewportAddedListener\n      );\n      this._viewportAddedListener = null; // Clear the reference to the listener\n    }\n  };\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 30,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    //Calculate angle in radian as glmatrix rotate is in radian\n    const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { AnnotationTool } from './base';\n\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { RectangleROIAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\n\nimport { windowLevel } from '../utilities/voi';\n\nimport { clip } from '../utilities';\n\n/**\n * WindowLevelRegion tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image to draw a rectangle region which is used to calculate\n * the windowCenter and windowWidth based on the ROI\n *\n */\n\nclass WindowLevelRegionTool extends AnnotationTool {\n  static toolName;\n\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // The minimum window width to be applied to the viewport regardless of the calculated value\n        minWindowWidth: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType): any => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    removeAnnotation(annotation.annotationUID);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    triggerAnnotationCompleted(annotation);\n\n    this.applyWindowLevelRegion(annotation, element);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n    const DEFAULT_HANDLE_INDEX = 3;\n    points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n\n    const bottomLeftCanvas = worldToCanvas(points[0]);\n    const topRightCanvas = worldToCanvas(points[3]);\n\n    const bottomRightCanvas = <Types.Point2>[\n      topRightCanvas[0],\n      bottomLeftCanvas[1],\n    ];\n    const topLeftCanvas = <Types.Point2>[\n      bottomLeftCanvas[0],\n      topRightCanvas[1],\n    ];\n\n    const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n    const topLeftWorld = canvasToWorld(topLeftCanvas);\n\n    points[1] = bottomRightWorld;\n    points[2] = topLeftWorld;\n\n    annotation.invalidated = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  applyWindowLevelRegion = (annotation, element): void => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const startCanvas = canvasCoordinates[0];\n    const endCanvas = canvasCoordinates[3];\n\n    let left = Math.min(startCanvas[0], endCanvas[0]);\n    let top = Math.min(startCanvas[1], endCanvas[1]);\n    let width = Math.abs(startCanvas[0] - endCanvas[0]);\n    let height = Math.abs(startCanvas[1] - endCanvas[1]);\n\n    left = clip(left, 0, imageData.width);\n    top = clip(top, 0, imageData.height);\n    width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n    height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n\n    // Get the pixel data in the rectangular region\n    const pixelLuminanceData = windowLevel.getLuminanceFromRegion(\n      imageData,\n      Math.round(left),\n      Math.round(top),\n      width,\n      height\n    );\n\n    // Calculate the minimum and maximum pixel values\n    const minMaxMean = windowLevel.calculateMinMaxMean(\n      pixelLuminanceData,\n      imageData.minPixelValue,\n      imageData.maxPixelValue\n    );\n\n    // Adjust the viewport window width and center based on the calculated values\n    if (this.configuration.minWindowWidth === undefined) {\n      this.configuration.minWindowWidth = 10;\n    }\n\n    const windowWidth = Math.max(\n      Math.abs(minMaxMean.max - minMaxMean.min),\n      this.configuration.minWindowWidth\n    );\n    const windowCenter = minMaxMean.mean;\n\n    const voiRange = utilities.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    viewport.setProperties({ voiRange });\n    viewport.render();\n  };\n\n  cancel = (): void => {\n    return null;\n  };\n\n  isPointNearTool = () => {\n    return null;\n  };\n\n  toolSelectedCallback = (): void => {\n    return null;\n  };\n\n  handleSelectedCallback = (): void => {\n    return null;\n  };\n\n  _activateModify = (): void => {\n    return null;\n  };\n\n  _deactivateModify = (): void => {\n    return null;\n  };\n}\n\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  cache,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    const properties = viewport.getProperties();\n    if (viewport instanceof VolumeViewport) {\n      volumeId = this.getTargetVolumeId(viewport);\n\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      if (!volume) {\n        throw new Error('Volume not found ' + volumeId);\n      }\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (properties.voiRange) {\n      modality = (viewport as any).modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT an the viewport is pre-scaled (SUV),\n    // treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT && isPreScaled) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    // If the range is not valid. Do nothing\n    if (newRange.lower >= newRange.upper) {\n      return;\n    }\n\n    viewport.setProperties({\n      voiRange: newRange,\n    });\n\n    viewport.render();\n\n    if (viewport instanceof VolumeViewport) {\n      viewportsContainingVolumeUID.forEach((vp) => {\n        if (viewport !== vp) {\n          vp.render();\n        }\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    return ratio > 1 ? Math.round(ratio) : ratio;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    if (imageData.getRange) {\n      const imageDataRange = imageData.getRange();\n      return imageDataRange[1] - imageDataRange[0];\n    }\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { roundNumber } from '../../utilities';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n      const { dimensions, imageData } = this.getTargetIdImage(\n        targetId,\n        renderingEngine\n      );\n\n      // Decide if there's at least one handle is outside of image\n      this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n        .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n        .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  if (isNaN(angle)) {\n    // The verbiage for incomplete angle is set in cachedStats\n    return [`${angle}`];\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        triggerAnnotationCompleted(annotation);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      triggerAnnotationModified(annotation, element);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      const handles1 = [index1, index2];\n      const handles2 = [index3, index4];\n\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles1\n      );\n\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles2\n      );\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\n      const widthUnit = dist1 > dist2 ? units2 : units1;\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: units1,\n        lengthUnit,\n        widthUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedAspect } from '../../utilities/getCalibratedUnits';\nimport { getCalibratedLengthUnitsAndScale, roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      pos2Index[0] = Math.floor(pos2Index[0]);\n      pos2Index[1] = Math.floor(pos2Index[1]);\n      pos2Index[2] = Math.floor(pos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\n\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\n\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const handles = [pos1Index, pos2Index];\n        const { scale, units, areaUnits } = getCalibratedLengthUnitsAndScale(\n          image,\n          handles\n        );\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS) =>\n            pointInEllipse(ellipseObj, pointLPS, {\n              fast: true,\n            }),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          max: stats.max?.value,\n          stdDev: stats.stdDev?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: areaUnits,\n          radius: worldWidth / 2 / scale,\n          radiusUnit: units,\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        showArcLines: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      if (this.configuration.showArcLines) {\n        lineUID = 'arc1';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc1Start as Types.Point2,\n          arc1End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n\n        lineUID = 'arc2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          arc2Start as Types.Point2,\n          arc2End as Types.Point2,\n          {\n            color,\n            lineWidth: '1',\n          }\n        );\n      }\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      if (this.configuration.showArcLines) {\n        const arc1TextBoxUID = 'arcAngle1';\n\n        const arc1TextLine = [\n          `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc1TextBoxUID,\n          arc1TextLine,\n          arch1TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n\n        const arc2TextBoxUID = 'arcAngle2';\n\n        const arc2TextLine = [\n          `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n        ];\n\n        const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arc2TextBoxUID,\n          arc2TextLine,\n          arch2TextPosCanvas,\n          {\n            ...options,\n            padding: 3,\n          }\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const { color } = this.getAnnotationStyle({\n      annotation,\n      styleSpecifier,\n    });\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipseByCoordinates as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      const canvasCorners = <Array<Types.Point2>>(\n        getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n      );\n\n      const { centerPointRadius } = this.configuration;\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(annotation, viewport, renderingEngine);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (annotation, viewport, renderingEngine) => {\n    const data = annotation.data;\n    const { element } = viewport;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const post2Index = transformWorldToIndex(imageData, worldPos2);\n\n      post2Index[0] = Math.floor(post2Index[0]);\n      post2Index[1] = Math.floor(post2Index[1]);\n      post2Index[2] = Math.floor(post2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      this.isHandleOutsideImage = !this._isInsideVolume(\n        pos1Index,\n        post2Index,\n        dimensions\n      );\n\n      const iMin = Math.min(pos1Index[0], post2Index[0]);\n      const iMax = Math.max(pos1Index[0], post2Index[0]);\n\n      const jMin = Math.min(pos1Index[1], post2Index[1]);\n      const jMax = Math.max(pos1Index[1], post2Index[1]);\n\n      const kMin = Math.min(pos1Index[2], post2Index[2]);\n      const kMax = Math.max(pos1Index[2], post2Index[2]);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const center = [\n        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n      ] as Types.Point3;\n\n      const ellipseObj = {\n        center,\n        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n      };\n\n      const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n        viewPlaneNormal,\n        viewUp,\n        worldPos1,\n        worldPos2\n      );\n      const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n\n      const handles = [pos1Index, post2Index];\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles\n      );\n\n      const area =\n        Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n        scale /\n        scale;\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        mean: stats.mean?.value,\n        max: stats.max?.value,\n        stdDev: stats.stdDev?.value,\n        statsArray: stats.array,\n        pointsInShape,\n        isEmptyArea,\n        areaUnit: areaUnits,\n        modalityUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawHeight as drawHeightSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * HeightTool let you draw annotations that measures the height of two drawing\n * points on a slice. You can use the HeightTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(HeightTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(HeightTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(HeightTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass HeightTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  //Lines to generate height\n  endfirstLine: Types.Point2;\n  endsecondLine: Types.Point2;\n  //Middle lines:\n  midX: number;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const {\n      viewPlaneNormal,\n      viewUp,\n      position: cameraPosition,\n    } = viewport.getCamera();\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        ...viewport.getViewReference({ points: [worldPos] }),\n        toolName: this.getToolName(),\n        referencedImageId,\n        viewUp,\n        cameraPosition,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided height annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the height annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const heightUID = '0';\n\n      //Draw Height:\n      drawHeightSvg(\n        svgDrawingHelper,\n        annotationUID,\n        heightUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash: lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateHeight(pos1, pos2) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n    const dz = pos2[2] - pos1[2];\n    //SAGITAL X alway 0\n    //CORONAL Y alway 0\n    //AXIAL Z alway 0\n\n    //SAGITAL:\n    if (dx == 0) {\n      //SAGITAL when it reaches 0 takes the measurement of Y, to correct it we return 0.\n      if (dy != 0) {\n        //SAGITAL use Z:\n        return Math.abs(dz);\n      } else {\n        return 0;\n      }\n    }\n    //SAGITAL AND CORONAL use Z:\n    //CORONAL:\n    else if (dy == 0) {\n      //CORONAL use Z:\n      return Math.abs(dz);\n    }\n    //AXIAL\n    else if (dz == 0) {\n      //AXIAL use Y:\n      return Math.abs(dy);\n    }\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const handles = [index1, index2];\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\n\n      const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        height,\n        unit: units,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { height, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (height === undefined || height === null || isNaN(height)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(height)} ${unit}`];\n\n  return textLines;\n}\n\nHeightTool.toolName = 'Height';\nexport default HeightTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\n\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { resetElementCursor } from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { Annotation } from '../../types';\n\ntype Point2 = Types.Point2;\n\nclass KeyImageTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        getTextCallback,\n        changeTextCallback,\n        canvasPosition: [10, 10],\n        canvasSize: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = KeyImageTool.createAnnotation({\n      metadata: { ...viewport.getViewReference(), referencedImageId },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.configuration.getTextCallback((text) => {\n      if (!text) {\n        removeAnnotation(annotation.annotationUID);\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n        this.isDrawing = false;\n        return;\n      }\n      annotation.data.text = text;\n\n      triggerAnnotationCompleted(annotation);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n    });\n\n    return annotation;\n  };\n\n  public cancel() {\n    // No op - the annotation can't be in a partial state\n  }\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { canvasPosition, canvasSize } = this.configuration;\n    if (!canvasPosition?.length) {\n      return false;\n    }\n    if (\n      Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n        canvasSize / 2 &&\n      Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n        canvasSize / 2\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    annotation.highlighted = true;\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle\n  ): void {\n    // Nothing special to do here.\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this._deactivateModify(element);\n    resetElementCursor(element);\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as Annotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as Annotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n  }\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { canvasPosition, canvasSize } = this.configuration;\n      if (canvasPosition?.length) {\n        const arrowUID = '1';\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasPosition.map((it) => it + canvasSize) as Point2,\n          canvasPosition as Point2,\n          {\n            color,\n            width: 1,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nKeyImageTool.toolName = 'KeyImage';\n\nexport default KeyImageTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const {\n      viewPlaneNormal,\n      viewUp,\n      position: cameraPosition,\n    } = viewport.getCamera();\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        ...viewport.getViewReference({ points: [worldPos] }),\n        toolName: this.getToolName(),\n        referencedImageId,\n        viewUp,\n        cameraPosition,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const handles = [index1, index2];\n      const { scale, units } = getCalibratedLengthUnitsAndScale(image, handles);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: units,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport type { ContourSegmentationAnnotation } from '../../types';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\n\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n  static toolName;\n\n  /**\n   * Updates the interpolated annotations with the currently displayed image data,\n   * performing hte livewire on the image data as generated.\n   * Note - this function is only called for interpolated livewire SEGMENTATION\n   * objects, and will return immediately otherwise.\n   *\n   * The work for the interpolation is performed in a microtask, enabling this\n   * method to return quickly for faster render speeds, but ensuring that the\n   * annotation data isn't updated before the changes are performed.  The removes\n   * some irritating flickering on navigation.\n   */\n  public updateInterpolatedAnnotation(\n    annotation: ContourSegmentationAnnotation,\n    enabledElement: Types.IEnabledElement\n  ) {\n    // The interpolation sources is used as a flag here - a true livewire\n    // behaviour would be to perform a livewire between the two planes\n    // closest to this plane for each point, and use that handle.  That is\n    // oblique, however, which is not currently supported.\n    if (\n      this.editData ||\n      !annotation.invalidated ||\n      !annotation.data.handles.interpolationSources\n    ) {\n      return;\n    }\n    annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n\n    // See docs above for why this is a microtask\n    queueMicrotask(() => {\n      if (!annotation.data.handles.interpolationSources) {\n        return;\n      }\n      const { points } = annotation.data.handles;\n\n      const { element } = enabledElement.viewport;\n      this.setupBaseEditData(points[0], element, annotation);\n      const { length: count } = points;\n      const { scissors } = this;\n      const { nearestEdge, repeatInterpolation } =\n        this.configuration.interpolation;\n      annotation.data.handles.originalPoints = points;\n      const { worldToSlice, sliceToWorld } = this.editData;\n      const handleSmoothing = [];\n\n      // New path generation - go through the handles and regenerate the polyline\n      if (nearestEdge) {\n        let lastPoint = worldToSlice(points[points.length - 1]);\n        // Nearest edge handling\n        points.forEach((point, hIndex) => {\n          const testPoint = worldToSlice(point);\n          lastPoint = testPoint;\n          handleSmoothing.push(testPoint);\n\n          // Fill the costs buffer and then find the minimum cost\n          // This is a little too aggressive about pulling the line in\n          scissors.startSearch(lastPoint);\n          scissors.findPathToPoint(testPoint);\n          // Fill the costs for a point a bit further along by searching for a\n          // point further along.\n          scissors.findPathToPoint(\n            worldToSlice(points[(hIndex + 3) % points.length])\n          );\n          const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n          if (!csUtils.isEqual(testPoint, minPoint)) {\n            handleSmoothing[hIndex] = minPoint;\n            lastPoint = minPoint;\n            points[hIndex] = sliceToWorld(minPoint);\n          }\n        });\n      }\n\n      // Regenerate the updated data based on the updated handles\n      const acceptedPath = new LivewirePath();\n      for (let i = 0; i < count; i++) {\n        scissors.startSearch(worldToSlice(points[i]));\n        const path = scissors.findPathToPoint(\n          worldToSlice(points[(i + 1) % count])\n        );\n        acceptedPath.addPoints(path);\n      }\n\n      // Now, update the rendering\n      this.updateAnnotation(acceptedPath);\n      this.scissors = null;\n      this.scissorsNext = null;\n      this.editData = null;\n      annotation.data.handles.interpolationSources = null;\n\n      if (repeatInterpolation) {\n        triggerAnnotationModified(\n          annotation,\n          enabledElement.viewport.element,\n          ChangeTypes.InterpolationUpdated\n        );\n      }\n    });\n  }\n\n  /**\n   * Adds the update to the interpolated annotaiton on render an instance,\n   * but otherwise just calls the parent render annotation instance.\n   */\n  protected renderAnnotationInstance(renderContext): boolean {\n    const { enabledElement, svgDrawingHelper } = renderContext;\n    const annotation =\n      renderContext.annotation as ContourSegmentationAnnotation;\n    const { annotationUID } = annotation;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { showInterpolationPolyline } =\n      this.configuration.interpolation || {};\n\n    this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n    const { originalPolyline } = annotation.data.contour;\n\n    const rendered = super.renderAnnotationInstance(renderContext);\n\n    if (\n      showInterpolationPolyline &&\n      originalPolyline &&\n      annotation.autoGenerated\n    ) {\n      const polylineCanvasPoints = originalPolyline.map(\n        worldToCanvas\n      ) as Types.Point2[];\n      polylineCanvasPoints.push(polylineCanvasPoints[0]);\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'interpolationContour-0',\n        polylineCanvasPoints,\n        {\n          color: '#70ffff',\n          lineWidth: 1,\n          fillOpacity: 0,\n        }\n      );\n    }\n\n    return rendered;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by LivewireContourTool\n    return true;\n  }\n}\n\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\nexport default LivewireContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { math, triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { LivewireContourAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport {\n  triggerAnnotationModified,\n  triggerContourAnnotationCompleted,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2; // px\n\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n  public static toolName: string;\n  protected scissors: LivewireScissors;\n  /** The scissors from the next handle, used for editing */\n  protected scissorsNext: LivewireScissors;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: LivewireContourAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    confirmedPath?: LivewirePath;\n    currentPath?: LivewirePath;\n    /** The next path segment, on the other side of the handle */\n    confirmedPathNext?: LivewirePath;\n    closed?: boolean;\n    worldToSlice?: (point: Types.Point3) => Types.Point2;\n    sliceToWorld?: (point: Types.Point2) => Types.Point3;\n    originalPath?: Types.Point3[];\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n\n        /**\n         * Configuring this to a value larger than 0 will snap handles to nearby\n         * livewire points, within the given rectangle surrounding the clicked point.\n         * If set to 0, then the exact clicked point will be used instead, which may\n         * not be an edge and can result in jagged outlines.\n         * The unit is image pixels (index).\n         */\n        snapHandleNearby: 2,\n\n        /**\n         * Interpolation is only available for segmentation versions of these\n         * tools.  To use it on the segmentation tools, set enabled to true,\n         * and create two livewire contours in the same segment index, separated\n         * by at least one slice.\n         */\n        interpolation: {\n          enabled: false,\n\n          /**\n           * Set the nearestEdge to snap interpolated handles to an edge within\n           * the given number of pixels.  Setting to 0 disables snap to pixel\n           * for interpolation and the interpolated point will be used directly.\n           * Setting to too large a value may result in many points outside the contour\n           * being chosen.\n           */\n          nearestEdge: 2,\n          /**\n           * Set to true to show the interpolated polyline, which can be useful\n           * when understanding the nearest edge and\n           */\n          showInterpolationPolyline: false,\n        },\n\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n\n        actions: {\n          undo: {\n            method: 'undo',\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  protected setupBaseEditData(\n    worldPos,\n    element,\n    annotation,\n    nextPos?,\n    contourHoleProcessingEnabled?\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.isDrawing = true;\n\n    const viewportImageData = viewport.getImageData();\n    const { imageData: vtkImageData } = viewportImageData;\n    let worldToSlice: (point: Types.Point3) => Types.Point2;\n    let sliceToWorld: (point: Types.Point2) => Types.Point3;\n    let { scalarData } = viewportImageData;\n    let width;\n    let height;\n\n    if (!(viewport instanceof VolumeViewport) && scalarData) {\n      width = viewportImageData.dimensions[0];\n      height = viewportImageData.dimensions[1];\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `worldToSlice` in this case returns the same IJK\n      // coordinate from index space.\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        return [ijkPoint[0], ijkPoint[1]];\n      };\n\n      // Method only to simplify the code making stack and volume viewports code\n      // similar and avoiding `if(stack)/else` whenever a coordinate needs to be\n      // transformed because `sliceToWorld` in this case receives the same IJK\n      // coordinate from index space.\n      sliceToWorld = (point: Types.Point2) =>\n        csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n    } else if (viewport instanceof VolumeViewport) {\n      const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n      const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n\n      worldToSlice = (point: Types.Point3) => {\n        const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n        const slicePoint = vec3.transformMat4(\n          [0, 0, 0],\n          ijkPoint,\n          indexToSliceMatrix\n        );\n\n        return [slicePoint[0], slicePoint[1]];\n      };\n\n      sliceToWorld = (point: Types.Point2) => {\n        const ijkPoint = vec3.transformMat4(\n          [0, 0, 0],\n          [point[0], point[1], 0],\n          sliceToIndexMatrix\n        ) as Types.Point3;\n\n        return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n      };\n\n      scalarData = sliceImageData.scalarData;\n      width = sliceImageData.width;\n      height = sliceImageData.height;\n    } else {\n      throw new Error('Viewport not supported');\n    }\n    scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n    const { voiRange } = viewport.getProperties();\n    const startPos = worldToSlice(worldPos);\n\n    this.scissors = LivewireScissors.createInstanceFromRawPixelData(\n      scalarData as Float32Array,\n      width,\n      height,\n      voiRange\n    );\n    if (nextPos) {\n      this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(\n        scalarData as Float32Array,\n        width,\n        height,\n        voiRange\n      );\n      this.scissorsNext.startSearch(worldToSlice(nextPos));\n    }\n\n    // Scissors always start at the startPos for both editing handles and\n    // for initial rendering\n    this.scissors.startSearch(startPos);\n\n    const newAnnotation = !nextPos;\n\n    const confirmedPath = new LivewirePath();\n    const currentPath = new LivewirePath();\n    const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n\n    confirmedPath.addPoint(startPos);\n    confirmedPath.addControlPoint(startPos);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      hasMoved: false,\n      lastCanvasPoint,\n      confirmedPath,\n      currentPath,\n      confirmedPathNext: currentPathNext,\n      closed: false,\n      handleIndex:\n        this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n      worldToSlice,\n      sliceToWorld,\n      contourHoleProcessingEnabled,\n    };\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): LivewireContourAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { world: worldPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const annotation = this.createAnnotation(evt);\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    this.setupBaseEditData(\n      worldPos,\n      element,\n      annotation,\n      undefined,\n      contourHoleProcessingEnabled\n    );\n    this.addAnnotation(annotation, element);\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      this.editData.viewportIdsToRender\n    );\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LivewireContourAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const proximitySquared = proximity * proximity;\n    const canvasPoints = annotation.data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    let startPoint = canvasPoints[canvasPoints.length - 1];\n\n    for (let i = 0; i < canvasPoints.length; i++) {\n      const endPoint = canvasPoints[i];\n      const distanceToPointSquared = math.lineSegment.distanceToPointSquared(\n        startPoint,\n        endPoint,\n        canvasCoords\n      );\n\n      if (distanceToPointSquared <= proximitySquared) {\n        return true;\n      }\n\n      startPoint = endPoint;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LivewireContourAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (\n    evt: EventTypes.InteractionEventType,\n    clearAnnotation = false\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      (this.isHandleOutsideImage &&\n        this.configuration.preventHandleOutsideImage) ||\n      clearAnnotation\n    ) {\n      removeAnnotation(annotation.annotationUID);\n      this.clearEditData();\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n      return;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n\n    this.triggerChangeEvent(\n      annotation,\n      enabledElement,\n      changeType,\n      contourHoleProcessingEnabled\n    );\n    this.clearEditData();\n  };\n\n  protected clearEditData() {\n    this.editData = null;\n    this.scissors = null;\n    this.scissorsNext = null;\n    this.isDrawing = false;\n  }\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: LivewireContourAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled = false\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      triggerContourAnnotationCompleted(\n        annotation,\n        contourHoleProcessingEnabled\n      );\n    } else {\n      triggerAnnotationModified(\n        annotation,\n        enabledElement.viewport.element,\n        changeType\n      );\n    }\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } =\n      this.editData;\n\n    if (this.editData.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n    let worldPos = worldPosOriginal;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const controlPoints = this.editData.currentPath.getControlPoints();\n    let closePath = controlPoints.length >= 2 && doubleClick;\n\n    // Check if user clicked on the first point to close the curve\n    if (controlPoints.length >= 2) {\n      const closestHandlePoint = {\n        index: -1,\n        distSquared: Infinity,\n      };\n\n      // Check if there is a control point close to the cursor\n      for (let i = 0, len = controlPoints.length; i < len; i++) {\n        const controlPoint = controlPoints[i];\n        const worldControlPoint = sliceToWorld(controlPoint);\n        const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n\n        const distSquared = math.point.distanceToPointSquared(\n          canvasPos,\n          canvasControlPoint\n        );\n\n        if (\n          distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n          distSquared < closestHandlePoint.distSquared\n        ) {\n          closestHandlePoint.distSquared = distSquared;\n          closestHandlePoint.index = i;\n        }\n      }\n\n      if (closestHandlePoint.index === 0) {\n        closePath = true;\n      }\n    }\n\n    const { snapHandleNearby } = this.configuration;\n    // Snap the handles as they get created, but not during edit\n    if (snapHandleNearby && !this.editData.closed) {\n      const currentPath = new LivewirePath();\n      const snapPoint = this.scissors.findMinNearby(\n        worldToSlice(worldPosOriginal),\n        1\n      );\n      const pathPoints = this.scissors.findPathToPoint(snapPoint);\n      currentPath.addPoints(pathPoints);\n      currentPath.prependPath(this.editData.confirmedPath);\n      worldPos = sliceToWorld(snapPoint);\n      this.editData.currentPath = currentPath;\n    }\n\n    this.editData.closed = this.editData.closed || closePath;\n    this.editData.confirmedPath = this.editData.currentPath;\n\n    // Add the current cursor position as a new control point after clicking\n    const lastPoint = this.editData.currentPath.getLastPoint();\n\n    this.editData.confirmedPath.addControlPoint(lastPoint);\n    annotation.data.handles.points.push(sliceToWorld(lastPoint));\n\n    // Start a new search starting at the last control point\n    this.scissors.startSearch(worldToSlice(worldPos));\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (this.editData.closed) {\n      // Update the annotation because `editData` will be set to null\n      this.updateAnnotation(this.editData.confirmedPath);\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { element, currentPoints } = evt.detail;\n    const { world: worldPos, canvas: canvasPos } = currentPoints;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = canvasPos;\n\n    const { width: imgWidth, height: imgHeight } = this.scissors;\n    const { worldToSlice } = this.editData;\n    const slicePoint: Types.Point2 = worldToSlice(worldPos);\n\n    // Check if the point is inside the bounding box\n    if (\n      slicePoint[0] < 0 ||\n      slicePoint[1] < 0 ||\n      slicePoint[0] >= imgWidth ||\n      slicePoint[1] >= imgHeight\n    ) {\n      return;\n    }\n\n    const pathPoints = this.scissors.findPathToPoint(slicePoint);\n    const currentPath = new LivewirePath();\n    currentPath.addPoints(pathPoints);\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(this.editData.confirmedPath);\n\n    // Store the new path\n    this.editData.currentPath = currentPath;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  public editHandle(\n    worldPos: Types.Point3,\n    element,\n    annotation: LivewireContourAnnotation,\n    handleIndex: number\n  ) {\n    const { data } = annotation;\n    const { points: handlePoints } = data.handles;\n    const { length: numHandles } = handlePoints;\n    const previousHandle =\n      handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n    const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n\n    if (!this.editData?.confirmedPathNext) {\n      this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n      const { polyline } = data.contour;\n      const confirmedPath = new LivewirePath();\n      const confirmedPathNext = new LivewirePath();\n      const { worldToSlice } = this.editData;\n      const previousIndex = findHandlePolylineIndex(\n        annotation,\n        handleIndex - 1\n      );\n      const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n      if (nextIndex === -1 || previousIndex === -1) {\n        throw new Error(\n          `Can't find handle index ${nextIndex === -1 && nextHandle} ${\n            previousIndex === -1 && previousHandle\n          }`\n        );\n      }\n      if (handleIndex === 0) {\n        // For this case, the next/previous indices are swapped, and the\n        // path data gets inserted in between the newly generated data, so\n        // handle this case specially\n        confirmedPathNext.addPoints(\n          polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice)\n        );\n      } else {\n        confirmedPath.addPoints(\n          polyline.slice(0, previousIndex + 1).map(worldToSlice)\n        );\n        confirmedPathNext.addPoints(\n          polyline.slice(nextIndex, polyline.length).map(worldToSlice)\n        );\n      }\n      this.editData.confirmedPath = confirmedPath;\n      this.editData.confirmedPathNext = confirmedPathNext;\n    }\n    const { editData, scissors } = this;\n    const { worldToSlice, sliceToWorld } = editData;\n\n    const { activeHandleIndex } = data.handles;\n    if (activeHandleIndex === null || activeHandleIndex === undefined) {\n      data.handles.activeHandleIndex = handleIndex;\n    } else if (activeHandleIndex !== handleIndex) {\n      throw new Error(\n        `Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`\n      );\n    }\n    const slicePos = worldToSlice(worldPos);\n    if (\n      slicePos[0] < 0 ||\n      slicePos[0] >= scissors.width ||\n      slicePos[1] < 0 ||\n      slicePos[1] >= scissors.height\n    ) {\n      // Find path to point hangs if the position is outside the image data\n      return;\n    }\n    handlePoints[handleIndex] = sliceToWorld(slicePos);\n\n    const pathPointsLeft = scissors.findPathToPoint(slicePos);\n    const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n    const currentPath = new LivewirePath();\n\n    // Merge the \"confirmed\" path that goes from the first control point to the\n    // last one with the current path that goes from the last control point to\n    // the cursor point\n    currentPath.prependPath(editData.confirmedPath);\n    if (handleIndex !== 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n    currentPath.addPoints(pathPointsRight.reverse());\n    currentPath.appendPath(editData.confirmedPathNext);\n    if (handleIndex === 0) {\n      currentPath.addPoints(pathPointsLeft);\n    }\n\n    // Store the new path\n    editData.currentPath = currentPath;\n\n    annotation.invalidated = true;\n    editData.hasMoved = true;\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    if (handleIndex === undefined) {\n      // Drag mode - moving object\n      console.warn('No drag implemented for livewire');\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n      this.editHandle(worldPos, element, annotation, handleIndex);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.scissors = null;\n    return annotation.annotationUID;\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  public renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean {\n    // Update the annotation that is in editData (being edited)\n    this.updateAnnotation(this.editData?.currentPath);\n\n    return super.renderAnnotation(enabledElement, svgDrawingHelper);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for LivewireContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType) {\n    const contourSegmentationAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n\n    const annotation = <LivewireContourAnnotation>csUtils.deepMerge(\n      contourSegmentationAnnotation,\n      {\n        data: {\n          handles: {\n            points: [[...worldPos]],\n          },\n        },\n      }\n    );\n    return annotation;\n  }\n\n  /**\n   * Clears any in progress edits, mostly used to get rid of accidentally started\n   * contours that happen on clicking not quite the right handle point.\n   * Eventually this is to be replaced with a proper undo, once that framework\n   * is available.\n   */\n  public undo(element, config, evt) {\n    if (!this.editData) {\n      // TODO - proper undo\n      return;\n    }\n    this._endCallback(evt, true);\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(renderContext: {\n    enabledElement: Types.IEnabledElement;\n    targetId: string;\n    annotation: LivewireContourAnnotation;\n    annotationStyle: Record<string, any>;\n    svgDrawingHelper: SVGDrawingHelper;\n  }): boolean {\n    const { annotation, enabledElement, svgDrawingHelper, annotationStyle } =\n      renderContext;\n\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const newAnnotation = this.editData?.newAnnotation;\n    const { lineWidth, lineDash, color } = annotationStyle;\n\n    // Render the first control point only when the annotation is drawn for the\n    // first time to make it easier to know where the user needs to click to\n    // to close the ROI.\n    if (\n      highlighted ||\n      (newAnnotation &&\n        annotation.annotationUID === this.editData?.annotation?.annotationUID)\n    ) {\n      const handleGroupUID = '0';\n      const canvasHandles = handles.points.map(worldToCanvas);\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasHandles,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    return true;\n  }\n\n  protected updateAnnotation(livewirePath: LivewirePath) {\n    if (!this.editData || !livewirePath) {\n      return;\n    }\n\n    const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } =\n      this.editData;\n    let { pointArray: imagePoints } = livewirePath;\n\n    if (imagePoints.length > 1) {\n      imagePoints = [...imagePoints, imagePoints[0]];\n    }\n\n    // Save the annotation in clockwise winding direction only after closing it\n    // because reversing the handle points may cause some weird issues\n    const targetWindingDirection =\n      newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n\n    this.updateContourPolyline(\n      annotation,\n      {\n        points: imagePoints,\n        closed,\n        targetWindingDirection,\n      },\n      {\n        canvasToWorld: sliceToWorld,\n        worldToCanvas: worldToSlice,\n      }\n    );\n  }\n}\n\nLivewireContourTool.toolName = 'LivewireContour';\nexport default LivewireContourTool;\n","import { utilities } from '@cornerstonejs/core';\nimport type { PublicToolProps } from '../../types';\nimport type { AnnotationRenderContext } from '../../types';\nimport { PlanarFreehandContourSegmentationAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\n\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n          /**\n           * Allow open contours false means to not allow a final/complete\n           * annotation to be done as an open contour.  This does not mean\n           * that the contour won't be open during creation.\n           */\n          allowOpenContours: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by PlanarFreehandROITool\n    return true;\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const annotation =\n      renderContext.annotation as PlanarFreehandContourSegmentationAnnotation;\n    const { invalidated } = annotation;\n\n    // Render the annotation before triggering events\n    const renderResult = super.renderAnnotationInstance(renderContext);\n\n    if (invalidated) {\n      const { segmentationId } = annotation.data.segmentation;\n\n      // This event is trigged by ContourSegmentationBaseTool but PlanarFreehandROITool\n      // is the only contour class that does not call `renderAnnotationInstace` from\n      // its base class.\n      triggerSegmentationDataModified(segmentationId);\n    }\n\n    return renderResult;\n  }\n}\n\nPlanarFreehandContourSegmentationTool.toolName =\n  'PlanarFreehandContourSegmentationTool';\n\nexport default PlanarFreehandContourSegmentationTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const { viewportId, renderingEngine } = getEnabledElement(element);\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\n\n      if (!data.cachedStats) {\n        data.cachedStats = {};\n      }\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { renderingEngineId, viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      const samplesPerPixel =\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0] * samplesPerPixel;\n        const zMultiple = dimensions[0] * dimensions[1] * samplesPerPixel;\n\n        const baseIndex =\n          index[2] * zMultiple +\n          index[1] * yMultiple +\n          index[0] * samplesPerPixel;\n        let value =\n          samplesPerPixel > 2\n            ? [\n                scalarData[baseIndex],\n                scalarData[baseIndex + 1],\n                scalarData[baseIndex + 2],\n              ]\n            : scalarData[baseIndex];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = csUtils.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        let modalityUnit;\n\n        if (modality === 'US') {\n          const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n            index,\n          ]);\n\n          const hasEnhancedRegionValues = calibratedResults.values.every(\n            (value) => value !== null\n          );\n\n          value = hasEnhancedRegionValues ? calibratedResults.values : value;\n          modalityUnit = hasEnhancedRegionValues\n            ? calibratedResults.units\n            : 'raw';\n        } else {\n          modalityUnit = getModalityUnit(\n            modality,\n            annotation.metadata.referencedImageId,\n            modalityUnitOptions\n          );\n        }\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      triggerAnnotationModified(annotation, element);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  if (value instanceof Array && modalityUnit instanceof Array) {\n    for (let i = 0; i < value.length; i++) {\n      textLines.push(`${roundNumber(value[i])} ${modalityUnit[i]}`);\n    }\n  } else {\n    textLines.push(`${roundNumber(value)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRectByCoordinates as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n\n      const pos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      pos1Index[0] = Math.floor(pos1Index[0]);\n      pos1Index[1] = Math.floor(pos1Index[1]);\n      pos1Index[2] = Math.floor(pos1Index[2]);\n\n      const pos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      pos2Index[0] = Math.floor(pos2Index[0]);\n      pos2Index[1] = Math.floor(pos2Index[1]);\n      pos2Index[2] = Math.floor(pos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(pos1Index[0], pos2Index[0]);\n        const iMax = Math.max(pos1Index[0], pos2Index[0]);\n\n        const jMin = Math.min(pos1Index[1], pos2Index[1]);\n        const jMax = Math.max(pos1Index[1], pos2Index[1]);\n\n        const kMin = Math.min(pos1Index[2], pos2Index[2]);\n        const kMax = Math.max(pos1Index[2], pos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const handles = [pos1Index, pos2Index];\n        const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n          image,\n          handles\n        );\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats.mean?.value,\n          stdDev: stats.stdDev?.value,\n          max: stats.max?.value,\n          statsArray: stats.array,\n          pointsInShape: pointsInShape,\n          areaUnit: areaUnits,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport { PublicToolProps } from '../../types';\nimport SplineROITool from './SplineROITool';\n\nclass SplineContourSegmentationTool extends SplineROITool {\n  static toolName;\n\n  constructor(toolProps: PublicToolProps) {\n    const initialProps = utilities.deepMerge(\n      {\n        configuration: {\n          calculateStats: false,\n        },\n      },\n      toolProps\n    );\n\n    super(initialProps);\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Re-enable contour segmentation behavior disabled by SplineROITool\n    return true;\n  }\n}\n\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\nexport default SplineContourSegmentationTool;\n","import {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getChildAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport {\n  Events,\n  MouseBindings,\n  KeyboardBindings,\n  ChangeTypes,\n} from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport type {\n  Annotation,\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  AnnotationRenderContext,\n} from '../../types';\nimport {\n  math,\n  throttle,\n  roundNumber,\n  triggerAnnotationRenderForViewportIds,\n  getCalibratedLengthUnitsAndScale,\n} from '../../utilities';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\n\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport type { SplineROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport type {\n  AnnotationModifiedEventDetail,\n  ContourAnnotationCompletedEventDetail,\n} from '../../types/EventTypes';\nimport { ISpline } from '../../types/ISpline';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\n\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\n\nconst DEFAULT_SPLINE_CONFIG = {\n  resolution: 20,\n  controlPointAdditionDistance: 6,\n  controlPointDeletionDistance: 6,\n  showControlPointsConnectors: false,\n  controlPointAdditionEnabled: true,\n  controlPointDeletionEnabled: true,\n};\n\nenum SplineTypesEnum {\n  Cardinal = 'CARDINAL',\n  Linear = 'LINEAR',\n  CatmullRom = 'CATMULLROM',\n  BSpline = 'BSPLINE',\n}\n\nenum SplineToolActions {\n  AddControlPoint = 'addControlPoint',\n  DeleteControlPoint = 'deleteControlPoint',\n}\n\nclass SplineROITool extends ContourSegmentationBaseTool {\n  static toolName;\n  static SplineTypes = SplineTypesEnum;\n  static Actions = SplineToolActions;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: SplineROIAnnotation;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    lastCanvasPoint?: Types.Point2;\n    contourHoleProcessingEnabled?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n  fireChangeOnUpdate: {\n    annotationUID: string;\n    changeType: ChangeTypes;\n    contourHoleProcessingEnabled: boolean;\n  } = null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        spline: {\n          configuration: {\n            [SplineTypesEnum.Cardinal]: {\n              Class: CardinalSpline,\n              scale: 0.5,\n            },\n            [SplineTypesEnum.CatmullRom]: {\n              Class: CatmullRomSpline,\n            },\n            [SplineTypesEnum.Linear]: {\n              Class: LinearSpline,\n            },\n            [SplineTypesEnum.BSpline]: {\n              Class: BSpline,\n              controlPointAdditionEnabled: false,\n              controlPointDeletionEnabled: false,\n              showControlPointsConnectors: true,\n            },\n          },\n          type: SplineTypesEnum.CatmullRom,\n          drawPreviewEnabled: true,\n          lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n        },\n        actions: {\n          [SplineToolActions.AddControlPoint]: {\n            method: 'addControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n          [SplineToolActions.DeleteControlPoint]: {\n            method: 'deleteControlPointCallback',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Primary,\n                modifierKey: KeyboardBindings.Ctrl,\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(evt: EventTypes.InteractionEventType): SplineROIAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const contourHoleProcessingEnabled =\n      getMouseModifierKey(evt.detail.event) ===\n      this.configuration.contourHoleAdditionModifierKey;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const annotation = this.createAnnotation(evt) as SplineROIAnnotation;\n\n    this.isDrawing = true;\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      lastCanvasPoint: canvasPos,\n      contourHoleProcessingEnabled,\n    };\n\n    this._activateDraw(element);\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const { instance: spline } = annotation.data.spline;\n\n    return spline.isPointNearCurve(canvasCoords, proximity);\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._activateModify(element);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation,\n      contourHoleProcessingEnabled,\n    } = this.editData;\n    const { data } = annotation;\n    annotation.autoGenerated = false;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    // Decide whether there's at least one point is outside image\n    const image = this.getTargetIdImage(\n      this.getTargetId(enabledElement.viewport),\n      enabledElement.renderingEngine\n    );\n    const { imageData, dimensions } = image;\n    this.isHandleOutsideImage = data.handles.points\n      .map((p) => utilities.transformWorldToIndex(imageData, p))\n      .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const changeType = newAnnotation\n      ? ChangeTypes.Completed\n      : ChangeTypes.HandlesUpdated;\n    if (!this.fireChangeOnUpdate) {\n      this.fireChangeOnUpdate = {\n        annotationUID: annotation.annotationUID,\n        changeType,\n        contourHoleProcessingEnabled,\n      };\n    } else {\n      this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n      this.fireChangeOnUpdate.changeType = changeType;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  private _keyDownCallback = (evt: EventTypes.KeyDownEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const key = eventDetail.key ?? '';\n    const { lastControlPointDeletionKeys } = this.configuration.spline;\n    const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n\n    if (!deleteLastPoint) {\n      return;\n    }\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length === SPLINE_MIN_POINTS) {\n      this.cancel(element);\n      return;\n    } else {\n      const controlPointIndex = data.handles.points.length - 1;\n      this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    const { drawPreviewEnabled } = this.configuration.spline;\n\n    // Does not force a re-render if preview is not enabled\n    if (!drawPreviewEnabled) {\n      return;\n    }\n\n    const { element } = evt.detail;\n    const { renderingEngine } = getEnabledElement(element);\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    evt.preventDefault();\n  };\n\n  private _mouseDownCallback = (evt: EventTypes.InteractionEventType): void => {\n    const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    if (data.contour.closed) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    let closeContour = data.handles.points.length >= 2 && doubleClick;\n    let addNewPoint = true;\n\n    // Check if user clicked on the first point to close the curve\n    if (data.handles.points.length >= 3) {\n      const { instance: spline } = data.spline;\n      const closestControlPoint = spline.getClosestControlPointWithinDistance(\n        canvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      if (closestControlPoint?.index === 0) {\n        addNewPoint = false;\n        closeContour = true;\n      }\n    }\n\n    if (addNewPoint) {\n      data.handles.points.push(worldPoint);\n    }\n\n    data.contour.closed = data.contour.closed || closeContour;\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (data.contour.closed) {\n      this._endCallback(evt);\n    }\n\n    evt.preventDefault();\n  };\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      this.moveAnnotation(annotation, worldPosDelta);\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel(element: HTMLDivElement) {\n    // If it is not in mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    if (newAnnotation) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    super.cancelAnnotation(annotation);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData = null;\n    return annotation.annotationUID;\n  }\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: SplineROIAnnotation,\n    contourHoleProcessingEnabled: boolean\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    const eventDetail: ContourAnnotationCompletedEventDetail = {\n      annotation,\n      changeType: ChangeTypes.Completed,\n      contourHoleProcessingEnabled,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n      changeType,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation complete or modified event based on changeType.\n   */\n  triggerChangeEvent = (\n    annotation: SplineROIAnnotation,\n    enabledElement: Types.IEnabledElement,\n    changeType = ChangeTypes.StatsUpdated,\n    contourHoleProcessingEnabled\n  ): void => {\n    if (changeType === ChangeTypes.Completed) {\n      this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    } else {\n      this.triggerAnnotationModified(annotation, enabledElement, changeType);\n    }\n  };\n\n  private _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  private _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.addEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  private _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n    element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n    element.removeEventListener(\n      Events.MOUSE_DOUBLE_CLICK,\n      this._mouseDownCallback\n    );\n\n    element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n  };\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for SplineContourSegmentationTool\n    return false;\n  }\n\n  /**\n   * Render an annotation instance\n   * @param renderContext - Render context that contains the annotation, enabledElement, etc.\n   * @returns True if the annotation is rendered or false otherwise\n   */\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper, annotationStyle } =\n      renderContext;\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { element } = viewport;\n    const annotation = renderContext.annotation as SplineROIAnnotation;\n    const { annotationUID, data, highlighted } = annotation;\n    const { handles } = data;\n    const { points: controlPoints, activeHandleIndex } = handles;\n    const newAnnotation = this.editData?.newAnnotation;\n\n    const {\n      lineWidth,\n      lineDash,\n      color,\n      locked: annotationLocked,\n    } = annotationStyle;\n\n    const canvasCoordinates = controlPoints.map((p) =>\n      worldToCanvas(p)\n    ) as Types.Point2[];\n\n    const { drawPreviewEnabled } = this.configuration.spline;\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = annotation.data.spline.instance;\n\n    const childAnnotations = getChildAnnotations(annotation);\n    const missingAnnotation = childAnnotations.findIndex((it) => !it);\n    if (missingAnnotation !== -1) {\n      // Child annotations go AWOL for a variety of reasons, so report is specifically here\n      throw new Error(\n        `Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`\n      );\n    }\n    // Update current and all child annotations/splines\n    const splineAnnotationsGroup = [annotation, ...childAnnotations].filter(\n      (annotation) => this._isSplineROIAnnotation(annotation)\n    ) as SplineROIAnnotation[];\n\n    splineAnnotationsGroup.forEach((annotation) => {\n      const spline = this._updateSplineInstance(element, annotation);\n      const splinePolylineCanvas = spline.getPolylinePoints();\n\n      this.updateContourPolyline(\n        annotation,\n        {\n          points: splinePolylineCanvas,\n          closed: data.contour.closed,\n          targetWindingDirection: ContourWindingDirection.Clockwise,\n        },\n        viewport\n      );\n    });\n\n    // Let the base class render the contour\n    super.renderAnnotationInstance(renderContext);\n\n    // If cachedStats does not exist, or the areaUnit is missing (as part of\n    // import/hydration etc.), force to recalculate the stats from the points\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].areaUnit == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        area: null,\n        areaUnit: null,\n      };\n\n      this._calculateCachedStats(annotation, element);\n    } else if (annotation.invalidated) {\n      this._throttledCalculateCachedStats(annotation, element);\n    }\n\n    let activeHandleCanvasCoords;\n\n    if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n      // Not locked or creating and hovering over handle, so render handle.\n      activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n    }\n\n    if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n      const handleGroupUID = '0';\n\n      // Move this call to the base class (contour seg) in the near future\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates,\n        {\n          color,\n          lineWidth: Math.max(1, lineWidth),\n          handleRadius: '3',\n        }\n      );\n    }\n\n    if (\n      drawPreviewEnabled &&\n      spline.numControlPoints > 1 &&\n      this.editData?.lastCanvasPoint &&\n      !spline.closed\n    ) {\n      const { lastCanvasPoint } = this.editData;\n      const previewPolylinePoints = spline.getPreviewPolylinePoints(\n        lastCanvasPoint,\n        SPLINE_CLICK_CLOSE_CURVE_DIST\n      );\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'previewSplineChange',\n        previewPolylinePoints,\n        {\n          color: '#9EA0CA',\n          lineDash,\n          lineWidth: 1,\n        }\n      );\n    }\n\n    if (splineConfig.showControlPointsConnectors) {\n      const controlPointsConnectors = [...canvasCoordinates];\n\n      // Connect the last point to the first one when the spline is closed\n      if (spline.closed) {\n        controlPointsConnectors.push(canvasCoordinates[0]);\n      }\n\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        'controlPointsConnectors',\n        controlPointsConnectors,\n        {\n          color: 'rgba(255, 255, 255, 0.5)',\n          lineWidth: 1,\n        }\n      );\n    }\n\n    this._renderStats(\n      annotation,\n      viewport,\n      svgDrawingHelper,\n      annotationStyle.textbox\n    );\n\n    if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n      this.triggerChangeEvent(\n        annotation,\n        enabledElement,\n        this.fireChangeOnUpdate.changeType,\n        this.fireChangeOnUpdate.contourHoleProcessingEnabled\n      );\n      this.fireChangeOnUpdate = null;\n    }\n\n    annotation.invalidated = false;\n    return true;\n  }\n\n  /**\n   * Creates new interpolated handles for the spline control given the\n   * polyline data.  This allows creating the spline from polyline data\n   * directly.\n   */\n  protected createInterpolatedSplineControl(annotation) {\n    if (annotation.data.handles.points?.length) {\n      // The interpolation itself created the handles\n      return;\n    }\n    const { polyline } = annotation.data.contour;\n    if (!polyline || !polyline.length) {\n      return;\n    }\n    annotation.data.handles.points = [];\n    const { points } = annotation.data.handles;\n    const increment = Math.max(10, Math.floor(polyline.length / 20));\n    for (let i = 0; i < polyline.length - increment; i += increment) {\n      points.push(polyline[i]);\n    }\n    points.push(polyline[polyline.length - 1]);\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const contourAnnotation = super.createAnnotation(evt);\n    const { world: worldPos } = evt.detail.currentPoints;\n    const { type: splineType } = this.configuration.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const spline = new splineConfig.Class();\n    const createSpline = () => ({\n      type: splineConfig.type,\n      instance: spline,\n      resolution: splineConfig.resolution,\n    });\n\n    // Add an action to create a new spline data on creating an interpolated\n    // instance.\n    let onInterpolationComplete;\n    if (this.configuration.interpolation?.enabled) {\n      onInterpolationComplete = (annotation) => {\n        annotation.data.spline ||= createSpline();\n        this.createInterpolatedSplineControl(annotation);\n      };\n    }\n\n    return <SplineROIAnnotation>utilities.deepMerge(contourAnnotation, {\n      data: {\n        handles: {\n          points: [[...worldPos]],\n        },\n        spline: createSpline(),\n        cachedStats: {},\n      },\n      onInterpolationComplete,\n    });\n  }\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    svgDrawingHelper,\n    textboxStyle\n  ) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    if (!data.spline.instance.closed || !textboxStyle.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = 'textBox';\n    const boundingBox = drawLinkedTextBoxSvg(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      textboxStyle\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n\n  addControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const { data } = annotation;\n    const splineType = data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointAdditionDistance;\n\n    if (splineConfig.controlPointAdditionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    const { instance: spline } = data.spline;\n    const canvasPos = evt.detail.currentPoints.canvas;\n    const closestPointInfo = spline.getClosestPoint(canvasPos);\n\n    if (closestPointInfo.distance > maxDist) {\n      return;\n    }\n\n    // Add a point at the `u` position from Parameter Space\n    const { index, point: canvasPoint } = spline.addControlPointAtU(\n      closestPointInfo.uValue\n    );\n\n    data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  private _deleteControlPointByIndex(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation,\n    controlPointIndex: number\n  ) {\n    const enabledElement = getEnabledElement(element);\n    const { points: controlPoints } = annotation.data.handles;\n\n    // There is no curve with only 2 points\n    if (controlPoints.length === 3) {\n      removeAnnotation(annotation.annotationUID);\n    } else {\n      controlPoints.splice(controlPointIndex, 1);\n    }\n\n    const { renderingEngine } = enabledElement;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    annotation.invalidated = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  deleteControlPointCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: SplineROIAnnotation\n  ) => {\n    const splineType = annotation.data.spline.type;\n    const splineConfig = this._getSplineConfig(splineType);\n    const maxDist = splineConfig.controlPointDeletionDistance;\n\n    if (splineConfig.controlPointDeletionEnabled === false) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const { canvas: canvasPos } = currentPoints;\n    const { instance: spline } = annotation.data.spline;\n    const closestControlPoint = spline.getClosestControlPointWithinDistance(\n      canvasPos,\n      maxDist\n    );\n\n    if (!closestControlPoint) {\n      return;\n    }\n\n    this._deleteControlPointByIndex(\n      element,\n      annotation,\n      closestControlPoint.index\n    );\n  };\n\n  _isSplineROIAnnotation(\n    annotation: Annotation\n  ): annotation is SplineROIAnnotation {\n    return !!(<SplineROIAnnotation>annotation).data?.spline;\n  }\n\n  /**\n   * Get a spline config merged with the default settings.\n   * @param type - Spline type (CARDINAL, CATMULLROM, LINEAR or BSPLINE)\n   * @returns Spline configuration\n   */\n  private _getSplineConfig(type: string) {\n    const { configuration: config } = this;\n    const splineConfigs = config.spline.configuration;\n\n    return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n  }\n\n  private _updateSplineInstance(\n    element: HTMLDivElement,\n    annotation: SplineROIAnnotation\n  ): ISpline {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { data } = annotation;\n    const { type: splineType, instance: spline } = annotation.data.spline;\n    const splineConfig = this._getSplineConfig(splineType);\n    const worldPoints = data.handles.points;\n    const canvasPoints = worldPoints.map(worldToCanvas);\n    const resolution =\n      splineConfig.resolution !== undefined\n        ? parseInt(splineConfig.resolution)\n        : undefined;\n    const scale =\n      splineConfig.scale !== undefined\n        ? parseFloat(splineConfig.scale)\n        : undefined;\n\n    spline.setControlPoints(canvasPoints);\n    spline.closed = !!data.contour.closed;\n\n    // Update spline resolution in case it has changed\n    if (\n      !spline.fixedResolution &&\n      resolution !== undefined &&\n      spline.resolution !== resolution\n    ) {\n      spline.resolution = resolution;\n      annotation.invalidated = true;\n    }\n\n    // Update Cardinal spline scale in case it has changed\n    if (\n      spline instanceof CardinalSpline &&\n      !spline.fixedScale &&\n      scale !== undefined &&\n      spline.scale !== scale\n    ) {\n      spline.scale = scale;\n      annotation.invalidated = true;\n    }\n\n    return spline;\n  }\n\n  private _calculateCachedStats = (\n    annotation: SplineROIAnnotation,\n    element: HTMLDivElement\n  ) => {\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n    const data = annotation.data;\n\n    if (!data.contour.closed) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { cachedStats } = data;\n    const { polyline: points } = data.contour;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const { imageData } = image;\n      const { scale, areaUnits } = getCalibratedLengthUnitsAndScale(\n        image,\n        () => {\n          const {\n            maxX: canvasMaxX,\n            maxY: canvasMaxY,\n            minX: canvasMinX,\n            minY: canvasMinY,\n          } = math.polyline.getAABB(canvasCoordinates);\n\n          const topLeftBBWorld = viewport.canvasToWorld([\n            canvasMinX,\n            canvasMinY,\n          ]);\n\n          const topLeftBBIndex = utilities.transformWorldToIndex(\n            imageData,\n            topLeftBBWorld\n          );\n\n          const bottomRightBBWorld = viewport.canvasToWorld([\n            canvasMaxX,\n            canvasMaxY,\n          ]);\n\n          const bottomRightBBIndex = utilities.transformWorldToIndex(\n            imageData,\n            bottomRightBBWorld\n          );\n\n          return [topLeftBBIndex, bottomRightBBIndex];\n        }\n      );\n      let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        areaUnit: areaUnits,\n      };\n    }\n\n    this.triggerAnnotationModified(\n      annotation,\n      enabledElement,\n      ChangeTypes.StatsUpdated\n    );\n\n    return cachedStats;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n\n    textLines.push(areaLine);\n  }\n\n  return textLines;\n}\n\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  utilities as csUtils,\n  StackViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport { UltrasoundDirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  drawHandle as drawHandleSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { roundNumber } from '../../utilities';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  InteractionTypes,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * The `UltrasoundDirectionalTool` class is a tool for creating directional ultrasound annotations.\n * It allows users to draw lines and measure distances between two points in the image.\n * It automatically calculates the distance based on the relevant unit of measurement.\n */\nclass UltrasoundDirectionalTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  startedDrawing: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        /**\n         * Determines whether both horizontal and vertical distances should be displayed\n         * in the text lines when generating annotations' measurement information.\n         */\n        displayBothAxesDistances: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Ultrasound Directional Tool and store it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): UltrasoundDirectionalAnnotation => {\n    if (this.startedDrawing) {\n      return;\n    }\n\n    this.startedDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error(\n        'UltrasoundDirectionalTool can only be used on a StackViewport'\n      );\n    }\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: UltrasoundDirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    return false;\n  };\n\n  toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void {\n    return;\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: UltrasoundDirectionalAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    let movingTextBox = false;\n    let handleIndex;\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      handleIndex,\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.startedDrawing && data.handles.points.length === 1) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 1;\n      return;\n    }\n\n    this.startedDrawing = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      this.startedDrawing = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as UltrasoundDirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].xValues == null\n      ) {\n        data.cachedStats[targetId] = {\n          xValues: [0, 0],\n          yValues: [0, 0],\n          isHorizontal: false,\n          units: [''],\n          isUnitless: false,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // draw first point\n      let handleGroupUID = '0';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[0],\n        {\n          color,\n        },\n        0\n      );\n\n      renderStatus = true;\n\n      if (canvasCoordinates.length !== 2) {\n        return renderStatus;\n      }\n\n      handleGroupUID = '1';\n      drawHandleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates[1],\n        {\n          color,\n        },\n        1\n      );\n\n      const isUnitless = data.cachedStats[targetId].isUnitless;\n\n      if (!isUnitless) {\n        const canvasPoint1 = canvasCoordinates[0];\n        const canvasPoint2 = canvasCoordinates[1];\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        const isHorizontal = data.cachedStats[targetId].isHorizontal;\n\n        // then for the third point we need to go from first point towards\n        // the second point (it can be left or right in the horizontal orientation)\n        // or up or down in the vertical orientation, and only add\n        // the delta y to the x or y coordinate of the first point\n        let projectedPointCanvas = [0, 0] as Types.Point2;\n        if (isHorizontal) {\n          projectedPointCanvas = [\n            canvasPoint1[0] + canvasDeltaX,\n            canvasPoint1[1],\n          ];\n        } else {\n          projectedPointCanvas = [\n            canvasPoint1[0],\n            canvasPoint1[1] + canvasDeltaY,\n          ];\n        }\n\n        // create a line from the first point to the third point\n        let dataId = `${annotationUID}-line-1`;\n        let lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n\n        // draw another line from first point to the projected one\n        dataId = `${annotationUID}-line-2`;\n        lineUID = '2';\n\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[1],\n          projectedPointCanvas,\n          {\n            color,\n            width: 1,\n            lineDash: [1, 1],\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      } else {\n        // draw straight line between the two points\n        const dataId = `${annotationUID}-line-1`;\n        const lineUID = '1';\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: 1,\n            shadow: this.configuration.shadow,\n          },\n          dataId\n        );\n      }\n\n      // draw another line from first point to the\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(\n        data,\n        targetId,\n        this.configuration\n      );\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { element } = enabledElement.viewport;\n\n    // Until we have all two anchors bail out\n    if (data.handles.points.length !== 2) {\n      return;\n    }\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData } = image;\n\n      const worldPos1 = data.handles.points[0];\n      const worldPos2 = data.handles.points[1];\n\n      const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n      const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n\n      const { values: values1, units: units1 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n      const { values: values2, units: units2 } =\n        getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n\n      let xValues, yValues, units, isHorizontal;\n      let isUnitless = false;\n      if (\n        units1[0] !== units2[0] ||\n        units1[1] !== units2[1] ||\n        (units1[0] === 'raw' && units2[0] === 'raw')\n      ) {\n        // if units are not the same, we cannot calculate the diff\n        // so we just report the px distance\n        const value = distanceToPoint(worldPos1, worldPos2);\n\n        xValues = [value, 0];\n        yValues = [value, 0];\n        units = ['px'];\n        isUnitless = true;\n      } else {\n        const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n        const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n\n        const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n        const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n\n        isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n        xValues = [values1[0], values2[0]];\n        yValues = [values1[1], values2[1]];\n\n        units = [units1[0], units1[1]];\n      }\n\n      cachedStats[targetId] = {\n        xValues,\n        yValues,\n        isHorizontal,\n        units,\n        isUnitless,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId, configuration): string[] {\n  const cachedStats = data.cachedStats[targetId];\n  const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n\n  if (isUnitless) {\n    return [`${roundNumber(xValues[0])} px`];\n  }\n\n  if (configuration.displayBothAxesDistances) {\n    const dist1 = Math.abs(xValues[1] - xValues[0]);\n    const dist2 = Math.abs(yValues[1] - yValues[0]);\n    return [\n      `${roundNumber(dist1)} ${units[0]}`,\n      `${roundNumber(dist2)} ${units[1]}`,\n    ];\n  }\n\n  if (isHorizontal) {\n    const dist = Math.abs(xValues[1] - xValues[0]);\n    return [`${roundNumber(dist)} ${units[0]}`];\n  } else {\n    const dist = Math.abs(yValues[1] - yValues[0]);\n    return [`${roundNumber(dist)} ${units[1]}`];\n  }\n}\n\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\nexport default UltrasoundDirectionalTool;\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = utilities.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import { utilities, BaseVolumeViewport } from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nimport StrategyCallbacks from '../../enums/StrategyCallbacks';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * Applies the active strategy function to the enabled element with the specified\n   * operation data.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * Applies the active strategy, with a given event type being applied.\n   * The event type function is found by indexing it on the active strategy\n   * function.\n   *\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @param callbackType - the type of the callback\n   *\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategyCallback(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown,\n    callbackType: StrategyCallbacks | string\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n\n    if (!strategies[activeStrategy]) {\n      throw new Error(\n        `applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`\n      );\n    }\n\n    return strategies[activeStrategy][callbackType]?.call(\n      this,\n      enabledElement,\n      operationData\n    );\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  protected getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be\n   * * imageId:<imageId>\n   * * volumeId:<volumeId>\n   * * videoId:<basePathForVideo>/frames/<frameSpecifier>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = utilities.getVolumeId(targetId);\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('videoId:')) {\n      // Video id can be multi-valued for the frame information\n      const imageURI = utilities.imageIdToURI(targetId);\n      const viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    const targetId = viewport.getReferenceId?.();\n    if (targetId) {\n      return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getReferenceId method');\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  StackViewport,\n  Types,\n  VolumeViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n  LabelmapSegmentationData,\n} from '../../../types/LabelmapTypes';\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { isVolumeSegmentation } from '../../segmentation/strategies/utils/stackVolumeCheck';\nimport { polySeg } from '../../../stateManagement/segmentation';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\nfunction getRepresentationRenderingConfig() {\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n  ofun.addPoint(0, 0);\n  return {\n    ofun,\n    cfun,\n  };\n}\n\nlet polySegConversionInProgress = false;\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    console.warn('No segmentation found for segmentationId: ', segmentationId);\n    return;\n  }\n\n  let labelmapData = segmentation.representationData[Representations.Labelmap];\n\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n\n  if (\n    !labelmapData &&\n    polySeg.canComputeRequestedRepresentation(segmentationRepresentationUID) &&\n    !polySegConversionInProgress\n  ) {\n    // meaning the requested segmentation representationUID does not have\n    // labelmap data, BUT we might be able to request a conversion from\n    // another representation to labelmap\n    // we need to check if we can request polySEG to convert the other\n    // underlying representations to Surface\n    polySegConversionInProgress = true;\n\n    labelmapData = await polySeg.computeAndAddLabelmapRepresentation(\n      segmentationId,\n      {\n        segmentationRepresentationUID,\n        viewport,\n      }\n    );\n\n    if (!labelmapData) {\n      throw new Error(\n        `No labelmap data found for segmentationId ${segmentationId}.`\n      );\n    }\n\n    polySegConversionInProgress = false;\n  }\n\n  if (!labelmapData) {\n    return;\n  }\n\n  if (isVolumeSegmentation(labelmapData, viewport)) {\n    if (viewport instanceof StackViewport) {\n      return;\n    }\n\n    const { volumeId: labelmapUID } = labelmapData;\n\n    const labelmap = cache.getVolume(labelmapUID);\n\n    if (!labelmap) {\n      throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  } else {\n    if (viewport instanceof VolumeViewport) {\n      return;\n    }\n\n    // stack segmentation\n    const imageId = viewport.getCurrentImageId();\n    const { imageIdReferenceMap } = labelmapData;\n\n    // if the stack labelmap is not built for the current imageId that is\n    // rendered at the viewport then return\n    if (!imageIdReferenceMap.has(imageId)) {\n      return;\n    }\n\n    if (!actorEntry) {\n      // only add the labelmap to ToolGroup viewports if it is not already added\n      await _addLabelmapToViewport(\n        viewport,\n        labelmapData,\n        segmentationRepresentationUID\n      );\n    }\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  const actor = actorEntry.actor as Types.VolumeActor;\n\n  actor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n\n  actor.getProperty().setScalarOpacity(0, ofun);\n  actor.getProperty().setInterpolationTypeToNearest();\n  actor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore - fix type in vtk\n  actor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n\n  const { activeSegmentIndex } = SegmentationState.getSegmentation(\n    segmentationRepresentation.segmentationId\n  );\n\n  // create an array that contains all the segment indices and for the active\n  // segment index, use the activeSegmentOutlineWidthDelta, otherwise use the\n  // outlineWidth\n  // Pre-allocate the array with the required size to avoid dynamic resizing.\n  const outlineWidths = new Array(numColors - 1);\n\n  for (let i = 1; i < numColors; i++) {\n    // Start from 1 to skip the background segment index.\n    const isHidden = segmentsHidden.has(i);\n\n    if (isHidden) {\n      outlineWidths[i - 1] = 0;\n      continue;\n    }\n\n    outlineWidths[i - 1] =\n      i === activeSegmentIndex\n        ? outlineWidth + toolGroupLabelmapConfig.activeSegmentOutlineWidthDelta\n        : outlineWidth;\n  }\n\n  actor.getProperty().setLabelOutlineThickness(outlineWidths);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  actor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport | Types.IStackViewport,\n  labelmapData: LabelmapSegmentationData,\n  segmentationRepresentationUID\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    labelmapData,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n\nexport {\n  getRepresentationRenderingConfig,\n  render,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Types, utilities as coreUtils } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\n\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback, roundNumber } from '../../utilities/';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n        showTextBox: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endCoord = this._getEndCoordinate(\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startCoordinate: startCoord,\n        endCoordinate: endCoord,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n          statistics: [],\n        },\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(\n        annotation,\n        targetId,\n        imageVolume,\n        enabledElement\n      );\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  //Now works for non-acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startCoordinate, endCoordinate } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n    const endIJK = transformWorldToIndex(imageData, points[0]);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // substitute the end slice index 2 with startIJK index 2\n\n    if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n      startWorld[2] = startCoordinate;\n      endWorld[2] = endCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0\n    ) {\n      startWorld[0] = startCoordinate;\n      endWorld[0] = endCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1\n    ) {\n      startWorld[1] = startCoordinate;\n      endWorld[1] = endCoordinate;\n    }\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          //@ts-ignore\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n  }\n\n  //This function return all the points inside the ROI and calculate statistics for every slices between startCoordinate and endCoordinate\n  _computePointsInsideVolume(\n    annotation,\n    targetId,\n    imageVolume,\n    enabledElement\n  ) {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, viewUp } = metadata;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n    const image = this.getTargetIdImage(targetId, renderingEngine);\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n\n    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n      viewPlaneNormal,\n      viewUp,\n      worldPos1,\n      worldPos2\n    );\n    const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n\n    const area =\n      Math.abs(worldWidth * worldHeight) /\n      (measureInfo.scale * measureInfo.scale);\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    const modalityUnit = getModalityUnit(\n      metadata.Modality,\n      annotation.metadata.referencedImageId,\n      modalityUnitOptions\n    );\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      const indexOfProjection =\n        this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      worldPos1Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      worldPos2Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    const stats = this.configuration.statsCalculator.getStatistics();\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n    data.cachedStats.statistics = {\n      Modality: metadata.Modality,\n      area,\n      mean: stats.mean?.value,\n      stdDev: stats.stdDev?.value,\n      max: stats.max?.value,\n      statsArray: stats.array,\n      areaUnit: measureInfo.areaUnits,\n      modalityUnit,\n    };\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    let annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = filterAnnotationsWithinSamePlane(\n      annotations,\n      viewport.getCamera()\n    );\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startCoordinate, endCoordinate } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      const focalPoint = viewport.getCamera().focalPoint;\n      const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n\n      let startCoord: number | vec3 = startCoordinate;\n      let endCoord: number | vec3 = endCoordinate;\n      if (Array.isArray(startCoordinate)) {\n        startCoord = this._getCoordinateForViewplaneNormal(\n          startCoord,\n          viewplaneNormal\n        );\n      }\n\n      if (Array.isArray(endCoordinate)) {\n        endCoord = this._getCoordinateForViewplaneNormal(\n          endCoord,\n          viewplaneNormal\n        );\n      }\n\n      const roundedStartCoord = coreUtils.roundToPrecision(startCoord);\n      const roundedEndCoord = coreUtils.roundToPrecision(endCoord);\n\n      const coord = this._getCoordinateForViewplaneNormal(\n        focalPoint,\n        viewplaneNormal\n      );\n      const roundedCoord = coreUtils.roundToPrecision(coord);\n      // if the focalpoint is outside the start/end coordinates, we don't render\n      if (\n        roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n        roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (\n        roundedCoord === roundedStartCoord ||\n        roundedCoord === roundedEndCoord\n      ) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n\n      if (\n        this.configuration.showTextBox &&\n        this.configuration.calculatePointsInsideVolume\n      ) {\n        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        if (!options.visibility) {\n          data.handles.textBox = {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          };\n          continue;\n        }\n\n        const textLines = this.configuration.getTextLines(data);\n        if (!textLines || textLines.length === 0) {\n          continue;\n        }\n\n        if (!data.handles.textBox.hasMoved) {\n          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n          data.handles.textBox.worldPosition =\n            viewport.canvasToWorld(canvasTextBoxCoords);\n        }\n\n        const textBoxPosition = viewport.worldToCanvas(\n          data.handles.textBox.worldPosition\n        );\n\n        const textBoxUID = '1';\n        const boundingBox = drawLinkedTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textBoxUID,\n          textLines,\n          textBoxPosition,\n          canvasCoordinates,\n          {},\n          options\n        );\n\n        const { x: left, y: top, width, height } = boundingBox;\n\n        data.handles.textBox.worldBoundingBox = {\n          topLeft: viewport.canvasToWorld([left, top]),\n          topRight: viewport.canvasToWorld([left + width, top]),\n          bottomLeft: viewport.canvasToWorld([left, top + height]),\n          bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _getStartCoordinate(\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const startPos = worldPos;\n    const startCoord = this._getCoordinateForViewplaneNormal(\n      startPos,\n      viewPlaneNormal\n    );\n\n    return startCoord;\n  }\n\n  _getEndCoordinate(\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const endCoord = this._getCoordinateForViewplaneNormal(\n      endPos,\n      viewPlaneNormal\n    );\n\n    return endCoord;\n  }\n\n  _getIndexOfCoordinatesForViewplaneNormal(\n    viewPlaneNormal: Types.Point3\n  ): number {\n    const viewplaneNormalAbs = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n    const indexOfDirection = viewplaneNormalAbs.indexOf(\n      Math.max(...viewplaneNormalAbs)\n    );\n\n    return indexOfDirection;\n  }\n\n  _getCoordinateForViewplaneNormal(\n    pos: vec3 | number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const indexOfDirection =\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n    return pos[indexOfDirection];\n  }\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data): string[] {\n  const cachedVolumeStats = data.cachedStats.statistics;\n\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import {\n  utilities as csUtils,\n  cache,\n  getEnabledElement,\n  StackViewport,\n  eventTarget,\n  Enums,\n} from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport {\n  Events,\n  ToolModes,\n  SegmentationRepresentations,\n  StrategyCallbacks,\n} from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport {\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * A type for preview data/information, used to setup previews on hover, or\n * maintain the preview information.\n */\nexport type PreviewData = {\n  /**\n   *  The preview data returned from the strategy\n   */\n  preview: unknown;\n  timer?: number;\n  timerStart: number;\n  startPoint: Types.Point2;\n  element: HTMLDivElement;\n  isDrag: boolean;\n};\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentsLocked: number[]; //\n    segmentationRepresentationUID?: string;\n    imageIdReferenceMap?: Map<string, string>;\n    volumeId?: string;\n    referencedVolumeId?: string;\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  private _previewData?: PreviewData = {\n    preview: null,\n    element: null,\n    timerStart: 0,\n    timer: null,\n    startPoint: [NaN, NaN],\n    isDrag: false,\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        thresholdVolumeId: null,\n        brushSize: 25,\n        preview: {\n          // Have to enable the preview to use this\n          enabled: false,\n          previewColors: {},\n          // The time before showing a preview\n          previewTimeMs: 250,\n          // The distance to move to show a preview before preview time expired\n          previewMoveDistance: 8,\n          // The distance to drag before being considered a drag rather than click\n          dragMoveDistance: 4,\n          // The time to consider a mouse click a drag when moved less than dragMoveDistance\n          dragTimeMs: 500,\n        },\n        actions: {\n          [StrategyCallbacks.AcceptPreview]: {\n            method: StrategyCallbacks.AcceptPreview,\n            bindings: [\n              {\n                key: 'Enter',\n              },\n            ],\n          },\n          [StrategyCallbacks.RejectPreview]: {\n            method: StrategyCallbacks.RejectPreview,\n            bindings: [\n              {\n                key: 'Escape',\n              },\n            ],\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = (evt) => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = (evt) => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n    this.rejectPreview();\n  }\n\n  createEditData(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create a segmentation representation before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type, segmentationRepresentationUID } =\n      activeSegmentationRepresentation;\n\n    if (type === SegmentationRepresentations.Contour) {\n      throw new Error('Not implemented yet');\n    }\n\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n      const actors = viewport.getActors();\n\n      const isStackViewport = viewport instanceof StackViewport;\n\n      if (isStackViewport) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n          detail: {\n            type: 'Segmentation',\n            message: 'Cannot perform brush operation on the selected viewport',\n          },\n          cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n      }\n\n      // we used to take the first actor here but we should take the one that is\n      // probably the same size as the segmentation volume\n      const volumes = actors.map((actorEntry) =>\n        cache.getVolume(actorEntry.referenceId)\n      );\n\n      const segmentationVolume = cache.getVolume(volumeId);\n\n      const referencedVolumeIdToThreshold =\n        volumes.find((volume) =>\n          csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions)\n        )?.volumeId || volumes[0]?.volumeId;\n\n      return {\n        volumeId,\n        referencedVolumeId:\n          this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = viewport.getCurrentImageId();\n\n      if (!imageIdReferenceMap.get(currentImageId)) {\n        // if there is no stack segmentation slice for the current image\n        // we should not allow the user to perform any operation\n        return;\n      }\n\n      // here we should identify if we can perform sphere manipulation\n      // for these stack of images, if the metadata is not present\n      // to create a volume or if there are inconsistencies between\n      // the image metadata we should not allow the sphere manipulation\n      // and should throw an error or maybe simply just allow circle manipulation\n      // and not sphere manipulation\n      if (this.configuration.activeStrategy.includes('SPHERE')) {\n        throw new Error(\n          'Sphere manipulation is not supported for stacks of image segmentations yet'\n        );\n        // Todo: add sphere (volumetric) manipulation support for stacks of images\n        // we should basically check if the stack constructs a valid volume\n        // meaning all the metadata is present and consistent\n        // then we use a VoxelManager mapping to map a volume like appearance\n        // for the stack data.\n        // csUtils.isValidVolume(referencedImageIds\n      }\n\n      return {\n        imageIdReferenceMap,\n        segmentsLocked,\n        segmentationRepresentationUID,\n      };\n    }\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this._editData = this.createEditData(element);\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    // This might be a mouse down\n    this._previewData.isDrag = false;\n    this._previewData.timerStart = Date.now();\n\n    const hoverData = this._hoverData || this.createHoverData(element);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      hoverData.viewportIdsToRender\n    );\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.OnInteractionStart\n    );\n\n    return true;\n  };\n\n  /**\n   * This call will be made when the mouse moves and the tool is active, but\n   * not actually drawing at the moment.\n   * The behavior is:\n   *    1. Update the cursor\n   *    2. Call the active strategy event 'preview' and 'rejectPreview'\n   *       on the mouse cursor position on a periodic basis to create a preview\n   *       when configured to do so.\n   *\n   * The preview will be shown after the mouse has been stationary for 250 ms.\n   * Any preview will be cancelled (immediately) after moving outside the center\n   * distance.\n   * As well, if the mouse moves but stays inside the center area for 250 ms,\n   * then the cancel will happen with a new preview being added.\n   *\n   * See mouse up details for how the preview gets accepted.\n   *\n   * The preview also needs to be cancelled on changing tools.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n      if (!this.configuration.preview.enabled) {\n        return;\n      }\n      const { previewTimeMs, previewMoveDistance, dragMoveDistance } =\n        this.configuration.preview;\n      const { currentPoints, element } = evt.detail;\n      const { canvas } = currentPoints;\n\n      const { preview, startPoint, timer, timerStart, isDrag } =\n        this._previewData;\n      const delta = vec2.distance(canvas, startPoint);\n      const time = Date.now() - timerStart;\n      if (\n        delta > previewMoveDistance ||\n        (time > previewTimeMs && delta > dragMoveDistance)\n      ) {\n        if (timer) {\n          window.clearTimeout(timer);\n          this._previewData.timer = null;\n        }\n        if (preview && !isDrag) {\n          this.rejectPreview(element);\n        }\n      }\n      if (!this._previewData.timer) {\n        const timer = window.setTimeout(this.previewCallback, 250);\n        Object.assign(this._previewData, {\n          timerStart: Date.now(),\n          timer,\n          startPoint: canvas,\n          element,\n        });\n      }\n    }\n  };\n\n  previewCallback = () => {\n    if (this._previewData.preview) {\n      return;\n    }\n    this._previewData.timer = null;\n    this._previewData.preview = this.applyActiveStrategyCallback(\n      getEnabledElement(this._previewData.element),\n      this.getOperationData(this._previewData.element),\n      StrategyCallbacks.Preview\n    );\n  };\n\n  private createHoverData(element, centerCanvas?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const viewportIdsToRender = [viewport.id];\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    } = this.getActiveSegmentationData() || {};\n\n    // Center of circle in canvas Coordinates\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    return {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n  }\n\n  private getActiveSegmentationData() {\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    return {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n    };\n  }\n\n  /**\n   * Updates the cursor position and whether it is showing or not.\n   * Can be over-ridden to add more cursor details or a preview.\n   */\n  protected updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    this._hoverData = this.createHoverData(element, centerCanvas);\n\n    this._calculateCursor(element, centerCanvas);\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    triggerAnnotationRenderForViewportUIDs(\n      getEnabledElement(element).renderingEngine,\n      this._hoverData.viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.updateCursor(evt);\n\n    const { viewportIdsToRender } = this._hoverData;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const delta = vec2.distance(\n      currentPoints.canvas,\n      this._previewData.startPoint\n    );\n    const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n    if (\n      !this._previewData.isDrag &&\n      this._previewData.preview &&\n      Date.now() - this._previewData.timerStart < dragTimeMs &&\n      delta < dragMoveDistance\n    ) {\n      // If we are showing a preview, then don't start dragging quite immediately\n      // so that click up can accept the preview.\n      return;\n    }\n\n    this._previewData.preview = this.applyActiveStrategy(\n      enabledElement,\n      this.getOperationData(element)\n    );\n    this._previewData.element = element;\n    // Add a bit of time to the timer start so small accidental movements dont\n    // cause issues on clicking\n    this._previewData.timerStart = Date.now() + dragTimeMs;\n    this._previewData.isDrag = true;\n    this._previewData.startPoint = currentPoints.canvas;\n  };\n\n  protected getOperationData(element?) {\n    const editData = this._editData || this.createEditData(element);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData || this.createHoverData(element);\n    const { data, metadata = {} } = brushCursor || {};\n    const { viewPlaneNormal, viewUp } = metadata;\n    const operationData = {\n      ...editData,\n      points: data?.handles?.points,\n      segmentIndex,\n      previewColors: this.configuration.preview.enabled\n        ? this.configuration.preview.previewColors\n        : null,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n      // Provide the preview information so that data can be used directly\n      preview: this._previewData?.preview,\n    };\n    return operationData;\n  }\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const strategy = this.configuration.strategies[activeStrategy];\n\n    // Note: i don't think this is the best way to implement this\n    // but don't think we have a better way to do it for now\n    if (typeof strategy.computeInnerCircleRadius === 'function') {\n      strategy.computeInnerCircleRadius({\n        configuration: this.configuration,\n        viewport,\n      });\n    }\n\n    data.invalidated = false;\n  }\n\n  /**\n   * The end callback call is made when the mouse is released.  This will\n   * perform another active strategy render event to render the final position.\n   * As well, the finish strategy callback will be made during this time.\n   */\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = this.getOperationData(element);\n    // Don't re-fill when the preview is showing and the user clicks again\n    // otherwise the new area of hover may get filled, which is unexpected\n    if (!this._previewData.preview && !this._previewData.isDrag) {\n      this.applyActiveStrategy(enabledElement, operationData);\n    }\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    this.updateCursor(evt);\n\n    this._editData = null;\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      operationData,\n      StrategyCallbacks.OnInteractionEnd\n    );\n\n    if (!this._previewData.isDrag) {\n      this.acceptPreview(element);\n    }\n  };\n\n  /**\n   * Cancels any preview view being shown, resetting any segments being shown.\n   */\n  public rejectPreview(element = this._previewData.element) {\n    if (!element || !this._previewData.preview) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.RejectPreview\n    );\n    this._previewData.preview = null;\n    this._previewData.isDrag = false;\n  }\n\n  /**\n   * Accepts a preview, marking it as the active segment.\n   */\n  public acceptPreview(element = this._previewData.element) {\n    if (!element) {\n      return;\n    }\n    const enabledElement = getEnabledElement(element);\n\n    this.applyActiveStrategyCallback(\n      enabledElement,\n      this.getOperationData(element),\n      StrategyCallbacks.AcceptPreview\n    );\n    this._previewData.isDrag = false;\n    this._previewData.preview = null;\n  }\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData === undefined) {\n      return;\n    }\n    const { data } = this._hoverData.brushCursor;\n\n    data.invalidated = true;\n\n    // Todo: figure out if other brush metadata (other than segment color) should get updated\n    // during the brush cursor invalidation\n    const { segmentColor } = this.getActiveSegmentationData() || {};\n    this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    if (!toolMetadata) {\n      return;\n    }\n\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    const activeStrategy = this.configuration.activeStrategy;\n    const { dynamicRadiusInCanvas } = this.configuration\n      .strategySpecificConfiguration[activeStrategy] || {\n      dynamicRadiusInCanvas: 0,\n    };\n\n    if (dynamicRadiusInCanvas) {\n      const circleUID1 = '1';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID1,\n        center as Types.Point2,\n        dynamicRadiusInCanvas,\n        {\n          color,\n        }\n      );\n    }\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import {\n  StackViewport,\n  Types,\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n  utilities as coreUtils,\n} from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  removeAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedAspect,\n} from '../../utilities/getCalibratedUnits';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { pointInShapeCallback, roundNumber } from '../../utilities';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nimport cloneDeep from 'lodash.clonedeep';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\n\nconst { transformWorldToIndex } = csUtils;\n\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        numSlicesToPropagate: 10,\n        calculatePointsInsideVolume: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n        showTextBox: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    const startCoord = this._getStartCoordinate(\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endCoord = this._getEndCoordinate(\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        volumeId,\n        spacingInNormal,\n        enabledElement,\n      },\n      data: {\n        label: '',\n        startCoordinate: startCoord,\n        endCoordinate: endCoord,\n\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          statistics: [],\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(\n        annotation,\n        imageVolume,\n        targetId,\n        enabledElement\n      );\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    let annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = filterAnnotationsWithinSamePlane(\n      annotations,\n      viewport.getCamera()\n    );\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startCoordinate, endCoordinate } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const { centerPointRadius } = this.configuration;\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      const focalPoint = viewport.getCamera().focalPoint;\n      const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n\n      let startCoord: number | vec3 = startCoordinate;\n      let endCoord: number | vec3 = endCoordinate;\n      if (Array.isArray(startCoordinate)) {\n        startCoord = this._getCoordinateForViewplaneNormal(\n          startCoord,\n          viewplaneNormal\n        );\n      }\n      if (Array.isArray(endCoordinate)) {\n        endCoord = this._getCoordinateForViewplaneNormal(\n          endCoord,\n          viewplaneNormal\n        );\n      }\n\n      const roundedStartCoord = coreUtils.roundToPrecision(startCoord);\n      const roundedEndCoord = coreUtils.roundToPrecision(endCoord);\n\n      const coord = this._getCoordinateForViewplaneNormal(\n        focalPoint,\n        viewplaneNormal\n      );\n      const roundedCoord = coreUtils.roundToPrecision(coord);\n\n      // if the focalpoint is outside the start/end coordinates, we don't render\n      if (\n        roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n        roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)\n      ) {\n        continue;\n      }\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      const middleCoord = coreUtils.roundToPrecision(\n        (startCoord + endCoord) / 2\n      );\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n\n      let isMiddleSlice = false;\n      if (roundedCoord === middleCoord) {\n        isMiddleSlice = true;\n      }\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        isMiddleSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineWidthToUse = lineWidth;\n      let lineDashToUse = lineDash;\n\n      if (isMiddleSlice) {\n        lineWidthToUse = lineWidth;\n        lineDashToUse = []; // Use solid line for real line\n      } else {\n        lineDashToUse = [5, 5]; // Use dashed line for projected lines\n      }\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth: lineWidthToUse,\n        }\n      );\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      if (\n        this.configuration.showTextBox == true &&\n        this.configuration.calculatePointsInsideVolume == true\n      ) {\n        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        if (!options.visibility) {\n          data.handles.textBox = {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          };\n          continue;\n        }\n        const textLines = this.configuration.getTextLines(data);\n        if (!textLines || textLines.length === 0) {\n          continue;\n        }\n\n        // Poor man's cached?\n        let canvasTextBoxCoords;\n\n        if (!data.handles.textBox.hasMoved) {\n          canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n          data.handles.textBox.worldPosition =\n            viewport.canvasToWorld(canvasTextBoxCoords);\n        }\n\n        const textBoxPosition = viewport.worldToCanvas(\n          data.handles.textBox.worldPosition\n        );\n\n        const textBoxUID = '1';\n        const boundingBox = drawLinkedTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textBoxUID,\n          textLines,\n          textBoxPosition,\n          canvasCoordinates,\n          {},\n          options\n        );\n\n        const { x: left, y: top, width, height } = boundingBox;\n        data.handles.textBox.worldBoundingBox = {\n          topLeft: viewport.canvasToWorld([left, top]),\n          topRight: viewport.canvasToWorld([left + width, top]),\n          bottomLeft: viewport.canvasToWorld([left, top + height]),\n          bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n      }\n    }\n    return renderStatus;\n  };\n\n  //Now works for axial, sagitall and coronal\n  _computeProjectionPoints(\n    annotation: CircleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startCoordinate, endCoordinate } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n    const endIJK = transformWorldToIndex(imageData, points[0]);\n\n    const handlesToStart = cloneDeep(points);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // substitute the end slice index 2 with startIJK index 2\n\n    if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n      startWorld[2] = startCoordinate;\n      endWorld[2] = endCoordinate;\n      handlesToStart[0][2] = startCoordinate;\n      handlesToStart[1][2] = startCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0\n    ) {\n      startWorld[0] = startCoordinate;\n      endWorld[0] = endCoordinate;\n      handlesToStart[0][0] = startCoordinate;\n      handlesToStart[1][0] = startCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1\n    ) {\n      startWorld[1] = startCoordinate;\n      endWorld[1] = endCoordinate;\n      handlesToStart[0][1] = startCoordinate;\n      handlesToStart[1][1] = startCoordinate;\n    }\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        handlesToStart.map((point) => {\n          const newPoint = vec3.create();\n          //@ts-ignore\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n  }\n\n  _computePointsInsideVolume(\n    annotation,\n    imageVolume,\n    targetId,\n    enabledElement\n  ) {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, viewUp } = metadata;\n    const { viewport, renderingEngine } = enabledElement;\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n\n    const image = this.getTargetIdImage(targetId, renderingEngine);\n\n    const canvasCoordinates = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n    const pos1 = viewport.canvasToWorld(topLeftCanvas);\n    const pos2 = viewport.canvasToWorld(bottomRightCanvas);\n\n    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n      viewPlaneNormal,\n      viewUp,\n      pos1,\n      pos2\n    );\n    const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles);\n    const aspect = getCalibratedAspect(image);\n    const area = Math.abs(\n      Math.PI *\n        (worldWidth / measureInfo.scale / 2) *\n        (worldHeight / aspect / measureInfo.scale / 2)\n    );\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    const modalityUnit = getModalityUnit(\n      metadata.Modality,\n      annotation.metadata.referencedImageId,\n      modalityUnitOptions\n    );\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const centerWorld = projectionPoints[i][0];\n      const canvasCoordinates = projectionPoints[i].map((p) =>\n        viewport.worldToCanvas(p)\n      );\n\n      const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n        getCanvasCircleCorners(canvasCoordinates)\n      );\n\n      const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n      const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n      const worldPos1 = topLeftWorld;\n      const worldPos2 = bottomRightWorld;\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        centerWorld\n      );\n\n      const indexOfProjection =\n        this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      worldPos1Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      worldPos2Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = centerWorld as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          //@ts-ignore\n          (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    const stats = this.configuration.statsCalculator.getStatistics();\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n    data.cachedStats.statistics = {\n      Modality: metadata.Modality,\n      area,\n      mean: stats.mean?.value,\n      stdDev: stats.stdDev?.value,\n      max: stats.max?.value,\n      statsArray: stats.array,\n      areaUnit: measureInfo.areaUnits,\n      modalityUnit,\n    };\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  _getStartCoordinate(\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const startPos = vec3.create();\n    vec3.scaleAndAdd(\n      startPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateFromStart * -spacingInNormal\n    );\n\n    const startCoord = this._getCoordinateForViewplaneNormal(\n      startPos,\n      viewPlaneNormal\n    );\n\n    return startCoord;\n  }\n\n  _getEndCoordinate(\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n    const numSlicesToPropagateToEnd =\n      numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagateToEnd * spacingInNormal\n    );\n\n    const endCoord = this._getCoordinateForViewplaneNormal(\n      endPos,\n      viewPlaneNormal\n    );\n\n    return endCoord;\n  }\n\n  _getIndexOfCoordinatesForViewplaneNormal(\n    viewPlaneNormal: Types.Point3\n  ): number {\n    const viewplaneNormalAbs = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n    const indexOfDirection = viewplaneNormalAbs.indexOf(\n      Math.max(...viewplaneNormalAbs)\n    );\n\n    return indexOfDirection;\n  }\n\n  _getCoordinateForViewplaneNormal(\n    pos: vec3 | number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const indexOfDirection =\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n    return pos[indexOfDirection];\n  }\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data): string[] {\n  const cachedVolumeStats = data.cachedStats.statistics;\n\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n    segmentationRepresentationUID?: string;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const labelmapData = representationData[type];\n\n    if (!labelmapData) {\n      throw new Error(\n        'No labelmap data found for the active segmentation, create one before using scissors tool'\n      );\n    }\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      viewPlaneNormal,\n      viewUp,\n      strategySpecificConfiguration: {},\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    let dimensions: Types.Point3;\n    let direction: Types.Mat3;\n    let scalarData: Types.PixelDataTypedArray;\n    let index: Types.Point3;\n\n    if (isVolumeSegmentation(labelmapData, viewport)) {\n      const { volumeId } = representationData[\n        type\n      ] as LabelmapSegmentationDataVolume;\n\n      const segmentation = cache.getVolume(volumeId);\n      ({ dimensions, direction } = segmentation);\n      scalarData = segmentation.getScalarData();\n\n      index = transformWorldToIndex(segmentation.imageData, worldPos);\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      const currentImageId = enabledElement.viewport.getCurrentImageId();\n      const currentSegmentationImageId =\n        imageIdReferenceMap.get(currentImageId);\n\n      if (!currentSegmentationImageId) {\n        throw new Error(\n          'No active segmentation imageId detected, create one before using scissors tool'\n        );\n      }\n\n      const segmentationImage = cache.getImage(currentSegmentationImageId);\n      scalarData = segmentationImage.getPixelData();\n      const { imageData } = viewport.getImageData();\n      dimensions = imageData.getDimensions();\n      direction = imageData.getDirection();\n      index = transformWorldToIndex(imageData, worldPos);\n    }\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Types.PixelDataTypedArray,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  LabelmapSegmentationDataStack,\n  LabelmapSegmentationDataVolume,\n} from '../../types/LabelmapTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    //\n    imageIdReferenceMap: Map<string, string>;\n    volumeId: string;\n    referencedVolumeId: string;\n    //\n    annotation: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData = representationData[\n      SegmentationRepresentations.Labelmap\n    ] as LabelmapSegmentationData;\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    this.editData = {\n      annotation,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n      segmentationRepresentationUID,\n    } as any;\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, newAnnotation, hasMoved } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  ToolGroupSpecificRepresentation,\n} from '../../types';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentationRepresentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport {\n  getHoveredContourSegmentationAnnotation,\n  getSegmentAtLabelmapBorder,\n  getSegmentAtWorldPoint,\n} from '../../utilities/segmentation';\nimport { state } from '../../store';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\n\n/**\n * Represents a tool used for segment selection. It is used to select a segment\n * by hovering over it.\n *\n */\nclass SegmentSelectTool extends BaseTool {\n  static toolName;\n  private hoverTimer: ReturnType<typeof setTimeout> | null;\n\n  static SelectMode = {\n    Inside: 'Inside',\n    Border: 'Border',\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        hoverTimeout: 100,\n        mode: SegmentSelectTool.SelectMode.Border,\n        searchRadius: 6, // search for border in a 6px radius\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.hoverTimer = null;\n  }\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (this.hoverTimer) {\n      clearTimeout(this.hoverTimer);\n    }\n\n    this.hoverTimer = setTimeout(() => {\n      this._setActiveSegment(evt);\n      this.hoverTimer = null;\n    }, this.configuration.hoverTimeout);\n\n    return true;\n  };\n\n  onSetToolEnabled = (): void => {\n    this.onSetToolActive();\n  };\n\n  onSetToolActive = (): void => {\n    this.hoverTimer = null;\n  };\n\n  onSetToolDisabled = (): void => {\n    this.hoverTimer = null;\n  };\n\n  _setActiveSegment(evt = {} as EventTypes.InteractionEventType): void {\n    if (state.isInteractingWithTool) {\n      return;\n    }\n\n    const { element, currentPoints } = evt.detail;\n\n    const worldPoint = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const activeSegmentationReps = getActiveSegmentationRepresentation(\n      this.toolGroupId\n    );\n\n    if (!activeSegmentationReps) {\n      return;\n    }\n\n    const supportedTypes = [\n      RepresentationTypes.Labelmap,\n      RepresentationTypes.Contour,\n    ];\n\n    if (supportedTypes.includes(activeSegmentationReps.type)) {\n      this._setActiveSegmentForType(\n        activeSegmentationReps,\n        worldPoint,\n        viewport\n      );\n    } else {\n      console.warn(\n        'SegmentSelectTool does not support the current segmentation type.'\n      );\n    }\n  }\n\n  _setActiveSegmentForType(\n    activeSegmentationReps: ToolGroupSpecificRepresentation,\n    worldPoint: Types.Point3,\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const imageDataInfo = viewport.getImageData();\n\n    if (!imageDataInfo) {\n      return;\n    }\n\n    const { segmentationId, type } = activeSegmentationReps;\n\n    let hoveredSegmentIndex;\n\n    if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n      hoveredSegmentIndex = getSegmentAtWorldPoint(segmentationId, worldPoint, {\n        viewport,\n      });\n    } else {\n      switch (type) {\n        case SegmentationRepresentations.Labelmap:\n          hoveredSegmentIndex = getSegmentAtLabelmapBorder(\n            segmentationId,\n            worldPoint,\n            {\n              viewport,\n              searchRadius: this.configuration.searchRadius,\n            }\n          );\n          break;\n\n        case SegmentationRepresentations.Contour:\n          hoveredSegmentIndex =\n            getHoveredContourSegmentationAnnotation(segmentationId);\n          break;\n      }\n    }\n\n    // No need to select background\n    if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n      return;\n    }\n\n    setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n\n    const renderingEngine = viewport.getRenderingEngine();\n    const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n\n    // update states\n    triggerSegmentationModified(segmentationId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  }\n}\n\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { cache, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n  LabelmapSegmentationDataStack,\n} from '../../types/LabelmapTypes';\nimport { isVolumeSegmentation } from './strategies/utils/stackVolumeCheck';\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationRepresentationUID: string;\n    //\n    volumeId: string;\n    referencedVolumeId: string;\n    imageIdReferenceMap: Map<string, string>;\n    //\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n          ERASE_INSIDE: eraseInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    // if we are already drawing, means we have started with a click, and now we\n    // are moving the mouse (not dragging) so the final click should not\n    // be handled by this preMouseDownCallback but rather the endCallback\n    if (this.isDrawing === true) {\n      return;\n    }\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      centerCanvas: canvasPos,\n      segmentationRepresentationUID,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    } as any;\n\n    const { representationData } = getSegmentation(segmentationId);\n    const labelmapData =\n      representationData[SegmentationRepresentations.Labelmap];\n\n    if (\n      isVolumeSegmentation(labelmapData as LabelmapSegmentationData, viewport)\n    ) {\n      const { volumeId } = labelmapData as LabelmapSegmentationDataVolume;\n      const segmentation = cache.getVolume(volumeId);\n\n      this.editData = {\n        ...this.editData,\n        volumeId,\n        referencedVolumeId: segmentation.referencedVolumeId,\n      };\n    } else {\n      const { imageIdReferenceMap } =\n        labelmapData as LabelmapSegmentationDataStack;\n\n      this.editData = {\n        ...this.editData,\n        imageIdReferenceMap,\n      };\n    }\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    const operationData = {\n      ...this.editData,\n      points: data.handles.points,\n      segmentIndex,\n      segmentationRepresentationUID,\n      segmentsLocked,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import {\n  LabelmapSegmentationData,\n  LabelmapSegmentationDataVolume,\n} from '../../../../types/LabelmapTypes';\nimport {\n  LabelmapToolOperationData,\n  LabelmapToolOperationDataStack,\n  LabelmapToolOperationDataVolume,\n} from '../../../../types';\nimport { Types, VolumeViewport } from '@cornerstonejs/core';\n\nfunction isVolumeSegmentation(\n  operationData: LabelmapToolOperationData | LabelmapSegmentationData,\n  viewport?: Types.IViewport\n): operationData is\n  | LabelmapToolOperationDataVolume\n  | LabelmapSegmentationDataVolume {\n  const { imageIdReferenceMap } =\n    operationData as LabelmapToolOperationDataStack;\n  const { volumeId } = operationData as LabelmapToolOperationDataVolume;\n\n  if (volumeId && !imageIdReferenceMap) {\n    return true;\n  }\n\n  if (imageIdReferenceMap && !volumeId) {\n    return false;\n  }\n\n  if (volumeId && imageIdReferenceMap && !viewport) {\n    throw new Error(\n      'isVolumeSegmentation: viewport is required when both volumeId and imageIdReferenceMap are provided'\n    );\n  }\n\n  // we can get the viewport to decide\n  return viewport instanceof VolumeViewport;\n}\n\nexport { isVolumeSegmentation };\n","import type { Types } from '@cornerstonejs/core';\nimport { Annotation } from './AnnotationTypes';\n\n/**\n * Polyline winding direction\n *\n * It is defined as -1 and 1 to make it easier to change its direction multiplying\n * by -1 whenever polyline.reverse() is called instead of using IF/ELSE\n */\nexport enum ContourWindingDirection {\n  CounterClockwise = -1,\n  Unknown = 0,\n  Clockwise = 1,\n}\n\nexport type ContourAnnotationData = {\n  data: {\n    contour: {\n      polyline: Types.Point3[];\n      closed: boolean;\n      windingDirection?: ContourWindingDirection;\n    };\n  };\n  onInterpolationComplete?: () => void;\n};\n\nexport type ContourAnnotation = Annotation & ContourAnnotationData;\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport type { Annotation } from '../types';\n\nconst { isEqual } = csUtils;\n\n/**\n * Finds a all matching viewports in terms of the orientation of the annotation data\n * and the frame of reference. This doesn't mean the annotation IS being displayed\n * on these viewports, just that it could be by navigating the slice, and/or pan/zoom,\n * without changing the orientation.\n *\n * @param annotation - Annotation to find the viewports that it could display in\n * @returns All viewports to display in\n */\nexport default function getViewportsForAnnotation(\n  annotation: Annotation\n): (Types.IStackViewport | Types.IVolumeViewport)[] {\n  const { metadata } = annotation;\n\n  return getEnabledElements()\n    .filter((enabledElement) => {\n      if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n        const viewport = enabledElement.viewport;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        return (\n          isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n          (!metadata.viewUp || isEqual(viewUp, metadata.viewUp))\n        );\n      }\n      return;\n    })\n    .map((enabledElement) => enabledElement.viewport);\n}\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport {\n  annotationHydration,\n  getClosestImageIdForStackViewport,\n} from './annotationHydration';\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n  annotationHydration,\n  getClosestImageIdForStackViewport,\n};\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import { Types, cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';\nimport { SegmentationRepresentations } from '../../enums';\n\nconst segmentIndicesCache = new Map<\n  string,\n  { indices: number[]; isDirty: boolean }\n>();\n\n/**\n * Sets the segmentation as dirty, indicating that it needs to be updated.\n * @param segmentationId - The ID of the segmentation.\n */\nexport const setSegmentationDirty = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = true;\n  }\n};\n\nexport const setSegmentationClean = (segmentationId: string) => {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached) {\n    cached.isDirty = false;\n  }\n};\n\nfunction getCachedSegmentIndices(segmentationId) {\n  const cached = segmentIndicesCache.get(segmentationId);\n  if (cached && !cached.isDirty) {\n    return cached.indices;\n  }\n  return null;\n}\n\n/**\n * Retrieves the unique segment indices from a given segmentation.\n *\n * @param segmentationId - The ID of the segmentation.\n * @returns An array of unique segment indices.\n * @throws If no geometryIds are found for the segmentationId.\n */\nfunction getUniqueSegmentIndices(segmentationId) {\n  // Attempt to fetch from cache first\n  const cachedResult = getCachedSegmentIndices(segmentationId);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  const segmentation = getSegmentation(segmentationId);\n  if (!segmentation) {\n    throw new Error(\n      `No segmentation found for segmentationId ${segmentationId}`\n    );\n  }\n\n  let indices;\n  switch (segmentation.type) {\n    case SegmentationRepresentations.Labelmap:\n      indices = handleLabelmapSegmentation(segmentation, segmentationId);\n      break;\n    case SegmentationRepresentations.Contour:\n      indices = handleContourSegmentation(segmentation);\n      break;\n    case SegmentationRepresentations.Surface:\n      indices = handleSurfaceSegmentation(segmentation);\n      break;\n    default:\n      throw new Error(`Unsupported segmentation type: ${segmentation.type}`);\n  }\n\n  // Update cache\n  segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n  return indices;\n}\n\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n  const labelmapData =\n    segmentation.representationData[SegmentationRepresentations.Labelmap];\n  const keySet = new Set();\n\n  if (isVolumeSegmentation(labelmapData)) {\n    addVolumeSegmentIndices(keySet, segmentationId);\n  } else {\n    addImageSegmentIndices(keySet, labelmapData.imageIdReferenceMap);\n  }\n\n  return Array.from(keySet)\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n  const volume = cache.getVolume(segmentationId);\n  const scalarData = volume.getScalarData();\n  scalarData.forEach((segmentIndex) => {\n    if (segmentIndex !== 0) {\n      keySet.add(segmentIndex);\n    }\n  });\n}\n\nfunction addImageSegmentIndices(keySet, imageIdReferenceMap) {\n  imageIdReferenceMap.forEach((segmentationImageId) => {\n    const image = cache.getImage(segmentationImageId);\n    const scalarData = image.getPixelData();\n    scalarData.forEach((segmentIndex) => {\n      if (segmentIndex !== 0) {\n        keySet.add(segmentIndex);\n      }\n    });\n  });\n}\n\nfunction handleContourSegmentation(segmentation) {\n  const { annotationUIDsMap, geometryIds } =\n    segmentation.representationData.CONTOUR || {};\n  if (!geometryIds) {\n    throw new Error(\n      `No geometryIds found for segmentationId ${segmentation.segmentationId}`\n    );\n  }\n\n  const indices = new Set([...annotationUIDsMap.keys()]);\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n    indices.add((geometry.data as Types.IContourSet).getSegmentIndex());\n  });\n\n  return Array.from(indices).sort((a, b) => a - b);\n}\n\nfunction handleSurfaceSegmentation(segmentation) {\n  const geometryIds =\n    segmentation.representationData.SURFACE?.geometryIds ?? [];\n  return Array.from(geometryIds.keys())\n    .map(Number)\n    .sort((a, b) => a - b);\n}\n\nexport { getUniqueSegmentIndices };\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport { SegmentationDisplayTool } from '../../tools';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n\n    const viewports = viewportsInfo\n      .map(({ viewportId, renderingEngineId }) => {\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n\n        if (!renderingEngine) {\n          console.warn('rendering Engine has been destroyed');\n          return;\n        }\n\n        const viewport = renderingEngine.getViewport(viewportId);\n\n        if (viewport) {\n          return viewport;\n        }\n      })\n      .filter(Boolean);\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          break;\n        }\n      }\n    }\n\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    // Call render again which will use RAF to call this function asynchronously\n    // if there is any viewport that needs to be rendered because when\n    // `triggerRender` is called inside the render loop a listener can flag new\n    // viewports that need to be rendered and some of the viewports that were\n    // already rendered can be added back to `_needsRender`.\n    this._render();\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      // Happens during testing, and isn't an issue as it just means there\n      // is overlap between shutdown and re-render\n      // console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length || !renderingEngine) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n      console.warn(`Viewport not available for ${viewportId}`);\n      return;\n    }\n    const { element } = viewport;\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n"],"names":["BASE","iconContent","iconSize","viewBox","x","y","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Height","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","values","Object","assign","create","registerCursor","toolName","getDefinedSVGCursorDescriptor","name","svgCursorNames","keys","ELEMENT_CURSORS_MAP","Symbol","initElementCursor","element","cursor","_getElementCursors","_setElementCursor","cursors","style","MouseCursor","getDefinedCursor","getStyleProperty","resetElementCursor","hideElementCursor","map","WeakMap","defineProperty","value","get","set","DEFINED_CURSORS","STANDARD_CURSORS","Set","constructor","fallback","this","getName","addFallbackStyleProperty","definedCursors","getDefinedCursors","mouseCursor","has","setDefinedCursor","context","symbol","Map","standardCursorNames","ImageMouseCursor","url","super","getUniqueInstanceName","Number","prefix","utilities","STATE","AnnotationStyleStates","Highlighted","MODE","ToolModes","Active","SVGMouseCursor","pointer","color","urn","type","getCursorURN","descriptor","options","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","bind","replace","match","key","svgSize","Math","max","cursorName","console","log","setElementCursor","CursorNames","annotationUID","drawingElementType","nodeUID","attributes","svgNode","forEach","currentValue","getAttribute","newValue","undefined","removeAttribute","setAttribute","svgDrawingHelper","circleUID","center","radius","dataId","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","existingCircleElement","getSvgNode","cx","cy","r","stroke","setNodeTouched","newCircleElement","document","createElementNS","appendNode","ellipseUID","canvasCoordinates","existingEllipse","bottom","top","left","right","w","hypot","h","angle","atan2","PI","rx","ry","transform","svgEllipseElement","corner1","corner2","handleGroupUID","handle","uniqueIndex","handleRadius","opacity","Error","side","parseFloat","height","existingHandleElement","newHandleElement","handlePoints","i","drawLine","lineUID","start","end","isNaN","shadow","existingLine","dropShadowStyle","svgLayerElement","id","x1","y1","x2","y2","newLine","drawHeight","heightUID","midX","endfirstLine","endsecondLine","firstLine","secondLine","threeLine","drawPolyline","polylineUID","points","length","fillColor","closePath","existingPolyLine","pointsAttribute","point","toFixed","firstPoint","newPolyLine","drawPath","pathUID","pointsArrays","Array","isArray","existingNode","numArrays","numPoints","j","d","newNode","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","querySelector","removeChild","getBBox","insertBefore","firstChild","bBox","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","svgns","existingTextGroup","textElement","textSpans","from","children","textSpan","appendChild","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","linkUID","annotationAnchorPoints","refPoint","boundingBox","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","textBoxUID","textBoxPosition","textBox","mergedOptions","centering","canvasBoundingBox","drawRectByCoordinates","rectangleUID","_width","existingRect","topLeft","topRight","bottomLeft","bottomRight","leftEdgeCenter","svgRectElement","drawRect","drawArrow","arrowUID","cos","sin","drawRedactionRect","tlhc","min","abs","ChangeTypes","Events","SegmentationRepresentations","StrategyCallbacks","Swipe","MouseBindings","KeyboardBindings","onImageRendered","evt","triggerAnnotationRender","detail","enable","addEventListener","Enums","IMAGE_RENDERED","disable","removeEventListener","MOUSE_CLICK","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_DOUBLE_CLICK","MOUSE_DRAG","MOUSE_MOVE","MOUSE_UP","MOUSE_WHEEL","KEY_DOWN","KEY_UP","Passive","Enabled","onCameraModified","getToolsWithModesForMouseEvent","tool","CAMERA_MODIFIED","onImageSpacingCalibrated","IMAGE_SPACING_CALIBRATED","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_PRESS","eventTarget","ANNOTATION_COMPLETED","InterpolationManager","handleAnnotationCompleted","ANNOTATION_MODIFIED","handleAnnotationUpdate","ANNOTATION_REMOVED","handleAnnotationDelete","onCameraReset","onResetCamera","CAMERA_RESET","DEFAULT_CONTOUR_SEG_TOOLNAME","async","contourSegmentationCompletedListener","sourceAnnotation","annotation","viewport","viewports","viewportWithToolRegistered","find","isFreehandContourSegToolRegisteredForViewport","getViewport","contourSegmentationAnnotations","sourceAnnotationUID","getAllAnnotations","filter","targetAnnotation","isReferenceViewable","metadata","getValidContourSegmentationAnnotations","sourcePolyline","convertContourPolylineToCanvasSpace","data","contour","polyline","targetAnnotationInfo","sourceAABB","math","targetPolyline","targetAABB","aabbIntersect","lineSegmentsIntersect","isContourHole","findIntersectingContour","contourHoleProcessingEnabled","createPolylineHole","PlanarFreehandContourSegmentationTool","warn","sourceStartPoint","mergePolylines","contourHolesData","getChildAnnotations","holeAnnotation","getContourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","parentPolyline","holeData","holes","push","delete","newPolylines","mergedPolyline","newPolyline","contourHolesDataArray","contourHoleData","clearParentAnnotation","enabledElement","getEnabledElement","handles","segmentation","removeAnnotation","startPoint","canvasToWorld","endPoint","newAnnotation","originalToolName","cachedStats","closed","spline","highlighted","invalidated","isLocked","isVisible","interpolationUID","interpolationCompleted","targetWindingDirection","Clockwise","addAnnotation","addChildAnnotation","renderingEngine","updatedTtoolNames","viewportIdsToRender","getViewportIdsWithToolToRender","triggerAnnotationRenderForViewportIds","Promise","resolve","window","requestAnimationFrame","updateViewports","combinePolylines","silent","toolGroup","renderingEngineId","errorMessage","hasTool","getToolOptions","projectedPolyline","worldToCanvas","windingDirection","holeWindingDirection","holeContour","holePolyline","updatedToolNames","mouseDoubleClickListener","mouseDownListener","mouseMoveListener","capture","preventGhostClick","touchStartListener","passive","wheelListener","toolGroupId","triggerSegmentationRender","segmentationId","modifiedSlicesToUse","representationData","toolGroupIds","labelmapRepresentationData","segmentationVolume","cache","getVolume","volumeId","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","modified","performVolumeLabelmapUpdate","toolGroupSegmentationRepresentations","viewportsInfo","getToolGroup","getViewportsInfo","representation","viewportId","getEnabledElementByIds","VolumeViewport","actorEntry","getActor","segmentationRepresentationUID","currentImageId","getCurrentImageId","segImageData","actor","getMapper","getInputData","imageIdReferenceMap","currentSegmentationImageId","segmentationImage","getImage","performStackLabelmapUpdate","Labelmap","getToolGroupIdsWithSegmentation","getSegmentationRepresentations","triggerSegmentationRepresentationModified","perToolGroupManualTriggers","_imageChangeEventListener","eventData","getToolGroupForViewport","segmentationRepresentations","LABELMAP","labelmapData","representationList","actors","getActors","includes","uid","segmentationActor","derivedImageId","segmentationImageData","setDerivedImage","scalarArray","numberOfComponents","Uint8Array","getNumberOfPoints","getPointData","setScalars","setInputData","derivedImage","dimensions","spacing","direction","getImageDataMetadata","currentImage","imageId","origin","currentOrigin","originToUse","setOrigin","removeActors","addImages","actorUID","callback","imageActor","getPixelData","setDimensions","setSpacing","setDirection","render","BaseVolumeViewport","STACK_NEW_IMAGE","annotationCompletedListener","contourSegmentationCompleted","removed","getRenderingEngines","viewportIds","getViewports","vp","getRenderingEngine","annotationRemovedListener","removeContourSegmentationAnnotation","csToolsInitialized","init","defaultConfiguration","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","elementDisabledEvent","ELEMENT_DISABLED","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","ANNOTATION_SELECTION_CHANGE","SEGMENTATION_MODIFIED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_REMOVED","destroy","annotationManager","getAnnotationManager","segmentationStateManager","getDefaultSegmentationStateManager","restoreAnnotations","resetState","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","getAnnotation","eventDetail","triggerEvent","findNearby","uids","index","indexOf","add","remove","clear","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","FrameOfReferenceUID","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","annotations","getFramesOfReference","getAnnotations","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","checkAndDefineIsLockedProperty","checkAndDefineIsVisibleProperty","groupAnnotations","toolAnnotations","findIndex","splice","removeAnnotations","removedAnnotations","annotationsForTool","saveAnnotations","state","flat","getNumberOfAllAnnotations","count","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationsSet","setAnnotationLocked","locked","makeEventDetail","lockedAnnotationsSet","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","isAnnotationLocked","getAnnotationsLockedCount","size","getOwnPropertyDescriptor","configurable","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","enumerable","freeze","item","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","setAnnotationSelected","selected","preserveSelected","clearSelectionSet","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","defaultManager","setAnnotationManager","resetAnnotationManager","manager","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","childAnnotation","parentUID","getParentAnnotation","childAnnotationUID","HTMLDivElement","annotationManagerUID","invalidateAnnotation","currAnnotation","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","ANNOTATION_VISIBILITY_CHANGE","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","config","getViewportToolStyles","getToolGroupToolStyles","toolGroups","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","mode","Selected","Locked","autoGenerated","AutoGenerated","Default","alternatives","list","getHierarchalPropertyStyles","triggerAnnotationAddedForElement","eventType","ANNOTATION_ADDED","triggerAnnotationAddedForFOR","getToolGroupsWithToolName","viewportsToRender","viewportInfo","triggerAnnotationRemoved","triggerAnnotationModified","changeType","HandlesUpdated","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","getActiveSegmentationRepresentation","active","getActiveSegmentation","activeRepresentation","getSegmentation","setActiveSegmentationRepresentation","setSegmentationVisibility","visibility","segmentsHidden","indices","getUniqueSegmentIndices","getSegmentationVisibility","indicesSet","segmentIndex","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","getSegmentVisibility","workerManager","getWebWorkerManager","polyDataCache","surfacesAABBCache","triggerWorkerProgress","progress","WEB_WORKER_PROGRESS","WorkerTypes","SURFACE_CLIPPING","clipAndCacheSurfacesForViewport","surfacesInfo","planesInfo","getSlicesClippingPlanes","currentSliceIndex","getSliceIndex","sort","a","b","sliceIndex","surfacesWithoutAABB","surface","surfacesAABB","executeTask","callbacks","aabb","updateSurfacesAABBCache","camera","getCamera","polyDataResults","polyDataResult","surfaceId","cacheId","viewPlaneNormal","pointToString","generateCacheId","lines","numberOfCells","actorCache","updatePolyDataCache","catch","error","getSurfaceActorUID","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","JSON","stringify","segmentationDataUID","segmentationRepresentation","getSegmentationRepresentationByUID","removeSegmentationRepresentation","Contour","_removeSegmentation","segmentationInputArray","segmentationInput","segInput","addSegmentation","getGlobalConfig","setGlobalConfig","segmentationConfig","getGlobalRepresentationConfig","representationType","representations","setGlobalRepresentationConfig","globalConfig","getToolGroupSpecificConfig","setToolGroupSpecificConfig","segmentationRepresentationConfig","getSegmentationRepresentationSpecificConfig","setSegmentationRepresentationSpecificConfig","getSegmentSpecificConfig","setSegmentSpecificConfig","getRepresentationSpecificConfig","representationInput","addSegmentationRepresentation","toolGroupSpecificConfig","colorLUTIndexToUse","colorLUTOrIndexInput","colorLUTOrIndex","nextIndex","getNextColorLUTIndex","colorLUTToAdd","addColorLUT","getColorLUTIndex","toolGroupSpecificRepresentation","colorLUTIndex","segmentationRepresentationSpecificConfig","segmentSpecificConfig","polySeg","currentToolGroupConfig","mergedConfig","renderInactiveSegmentations","representationInputArray","toolGroupSpecificRepresentationConfig","promises","all","Surface","computeVolumeSegmentationFromStack","segmentationImageIds","additionalDetails","volumeLoader","convertStackToVolumeSegmentation","removeOriginal","removeImageLoadObject","addEventListenerOnce","SEGMENTATION_RENDERED","triggerSegmentationDataModified","updateSegmentationState","computeStackSegmentationFromVolume","isAllImagesCached","imageCacheOffsetMap","imageIds","every","volumeUsedInOtherViewports","getVolumeViewports","hasVolumeId","decache","referencedImageIds","startsWith","createImageIdReferenceMap","reverse","referencedVolumeId","referencedVolume","segmentationImageIdsToUse","convertToImageSlicesAndCache","_getImageIdReferenceMapForStackSegmentation","convertVolumeToStackSegmentation","removeVolumeLoadObject","updateStackSegmentationState","isSegmentIndexLocked","segmentsLocked","setSegmentIndexLocked","triggerSegmentationModified","getLockedSegments","colorLUT","unshift","setColorLUT","getColorForSegmentIndex","colorValue","setColorForSegmentIndex","colorReference","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","registerPolySegWorker","debouncedUpdateFunction","event","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","debounce","POLYSEG_CONTOUR_TO_SURFACE","createAndCacheSurfacesFromRaw","rawSurfacesData","findSegmentationRepresentationByUID","geometryIds","rawSurfaceData","slice","closedSurface","polys","geometryId","geometryLoader","SURFACE","geometryData","POLYSEG_LABELMAP_TO_SURFACE","computeSurfaceData","CONTOUR","contourRepresentationData","annotationUIDsMap","polylines","numPointsArray","results","convertContourToSurface","computeSurfaceFromContourSegmentation","computeSurfaceFromLabelmapSegmentation","isVolume","volume","scalarData","getScalarData","convertLabelmapToSurface","surfaces","allSettled","errors","p","status","Boolean","computeAndAddSurfaceRepresentation","surfacesObj","getGeometry","setPoints","setPolys","geometry","updateSurfaceData","POLYSEG_CONTOUR_TO_LABELMAP","convertContourToVolumeLabelmap","segmentationVolumeId","volumeProps","annotationUIDsInSegmentMap","_getAnnotationMapFromSegmentation","newScalarData","getScalars","setData","convertContourToStackLabelmap","getImageIds","getImageLoadObject","imageLoader","segmentationsInfo","segImageId","segImage","imagePlaneModule","metaData","IMAGE_PLANE","columnCosines","rowCosines","rowPixelSpacing","columnPixelSpacing","imagePositionPatient","rowCosineVec","colCosineVec","scanAxisNormal","newSegmentationsScalarData","referencedImageId","segmentationInfo","imageFrame","pixelData","annotationMap","annotationUIDsInSegment","hasChildAnnotations","holesPolyline","POLYSEG_SURFACE_TO_LABELMAP","computeLabelmapData","rawLabelmapData","convertFunction","result","computeLabelmapFromContourSegmentation","segmentsGeometryIds","defaultActor","getDefaultActor","surfaceRepresentationData","segmentsInfo","getPoints","getPolys","convertSurfaceToVolumeLabelmap","computeLabelmapFromSurfaceSegmentation","computeAndAddLabelmapRepresentation","extractContourData","segmentIndexMap","rawResults","intersectionInfo","split","_","_extractLineSegments","contourData","lineSegments","linesNumberOfPoints","pointsInLine","computeContourData","rawContourData","segmentIndexToSurfaceId","surfaceIdToSegmentIndex","computeContourFromSurfaceSegmentation","pointsAndPolys","toString","computeContourFromLabelmapSegmentation","contoursData","line","pointIndex","contourSegmentationAnnotation","getViewReference","currentSet","createAndAddContourSegmentationsFromClippedSurfaces","fillAlpha","computeAndAddContourRepresentation","conversionPaths","canComputeRequestedRepresentation","representationInfo","enabled","existingRepresentationTypes","supportedTypes","representationTypeData","validateFn","getExistingRepresentationTypes","some","existingRepresentationType","fromRepresentationType","toRepresentationType","canConvertFromTo","registered","registerWorker","Worker","maxWorkerInstances","autoTerminateOnIdle","idleTimeThreshold","setActiveSegmentIndex","activeSegmentIndex","invalidateBrushCursor","getActiveSegmentIndex","defaultLabelmapConfig","defaultContourConfig","defaultSurfaceConfig","initialDefaultState","segmentations","defaultSegmentationStateManager","getState","getToolGroups","getColorLUT","lutIndex","toolGroupSegRepresentationsWithConfig","getAllSegmentationRepresentations","toolGroupSegReps","entries","_handleActiveSegmentation","segmentationData","removeSegmentation","segData","removedSegmentationRepresentation","toolGroupSegmentations","toolGroupStateWithConfig","setSegmentationRepresentationConfig","removeColorLUT","recentlyAddedOrRemovedSegmentationRepresentation","isContourRepresentation","segmentLabels","label","getSegmentations","suppressEvents","getSegmentationIdRepresentations","allRepresentations","foundRepresentations","foundRepresentation","allToolGroupRepresentations","foundToolGroupIds","getSegmentSpecificRepresentationConfig","setSegmentSpecificRepresentationConfig","getToolGroupIdFromSegmentationRepresentationUID","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","removeSegmentationRepresentations","SEGMENTATION_REMOVED","segmentationIds","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventName","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","currentTarget","_sourceViewports","s","fireEvent","_enabled","_eventName","_eventHandler","_options","_auxiliaryEventNames","auxiliaryEventNames","isDisabled","_hasSourceElements","setOptions","setEnabled","getOptions","addTarget","addSource","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","t","removeTarget","_getViewportElement","hasSourceViewport","hasTargetViewport","sourceViewport","sourceEvent","targetViewport","ex","then","vp1","vp2","unique","vps","concat","u","_getUniqueViewports","_remove","disableHandler","vUid","synchronizersFilteredByIds","synchronizers","synchronizer","notDisabled","sync","Synchronizer","pop","synchronizerIndex","re","toolGroupFilteredByIds","tg","addTool","ToolClass","toolAlreadyAdded","tools","toolClass","removeTool","addEnabledElement","svgLayer","svgLayerId","classList","pointerEvents","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","svgNodeCache","_setSvgNodeCache","addViewportElement","enabledElements","VIEWPORT_ELEMENT","_removeViewportFromSynchronizers","getSynchronizersForViewport","_removeViewportFromToolGroup","removeViewports","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","removeViewportElement","cancelActiveManipulations","toolsWithData","cancel","defaultState","isInteractingWithTool","isMultiPartToolActive","resetCornerstoneToolsState","resetSvgNodeCache","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setViewPresentation","createPresentationViewSynchronizer","voiSyncCallback","modifiedEvent","range","invertStateChanged","invert","colormap","tProperties","voiRange","syncInvertState","syncColormap","_actors","setProperties","StackViewport","createVOISynchronizer","VOI_MODIFIED","COLORMAP_MODIFIED","zoomPanSyncCallback","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","getSpatialRegistration","targetId","sourceId","imageSliceSyncCallback","disabled","imageId1","sourceImagePositionPatient","targetImageIds","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","areViewportsCoplanar","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","reduce","closestImageIdIndex","distance","Infinity","imageIndexToSet","getCurrentImageIdIndex","jumpToSlice","imageIndex","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","slabThicknessSyncCallback","slabThickness","getSlabThickness","setSlabThickness","createStackImageSynchronizer","AdvancedMagnifyToolActions","AdvancedMagnifyTool","toolProps","defaultToolProps","supportedInteractionTypes","configuration","magnifyingGlass","zoomFactor","zoomFactorList","autoPan","actions","showZoomFactorsList","method","bindings","mouseButton","Secondary","modifierKey","Shift","addNewAnnotation","currentPoints","worldPos","world","canvasPos","canvas","canvasHandlePoints","_getCanvasHandlePoints","viewUp","getReferencedImageId","magnifyViewportId","getToolName","sourceViewportId","isCanvasAnnotation","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","delta","len","preventDefault","onSetToolDisabled","dispose","isPointNearTool","canvasCoords","proximity","canvasTop","canvasBottom","canvasLeft","radiusPoint","toolSelectedCallback","editData","_activateModify","handleSelectedCallback","handleIndex","_endCallback","_deactivateModify","isDrawing","_dragDrawCallback","deltaPoints","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","renderAnnotation","renderStatus","filteredAnnotations","filterInteractableAnnotationsForElement","getStyle","activeHandleCanvasCoords","drawHandles","drawCircle","magnifyViewport","update","canvasCenterPos","canvasRadius","getInstance","Actions","canvasPoint","viewportElement","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","createElement","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","AnnotationEraserTool","preMouseDownCallback","_deleteNearbyAnnotations","preTouchStartCallback","interactionType","_toolInstances","annotationsToRemove","toolInstance","interactableAnnotations","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","viewportIndicatorsConfig","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","mobile","toolCenter","initializeViewport","focalPoint","_getAnnotations","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","normal","clientWidth","clientHeight","_getViewportsInfo","resetCrosshairs","resetPan","resetZoom","resetToCenter","resetRotation","resetCamera","resetSlabThickness","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","jumpWorld","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","getViewportIds","_autoPanViewportIfNecessary","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","canvasDiagonalLength","sqrt","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","referenceColorCoordinates","xOffset","yOffset","circleRadius","_onNewVolume","e","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_applyDeltaShiftToSelectedViewportCameras","_dragCallback","dir1","dir2","centerCanvas","finalPointCanvas","originalPointCanvas","_isClockWise","round","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","lastPoints","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","onSetToolActive","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","onSetToolPassive","onSetToolEnabled","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","VOLUME_VIEWPORT_NEW_VOLUME","toolCenterCanvas","pan","visiblePointCanvas","visiblePointWorld","deltaPointsWorld","updatedPosition","updatedFocalPoint","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","c","_applyDeltaShiftToViewportCamera","newFocalPoint","newPosition","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","getTargetVolumeId","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","_activateDraw","viewportProperties","getProperties","magnifyToolElement","magnifyElement","display","viewportInput","STACK","enableElement","setStack","parallelScale","pow","_dragEndCallback","disableElement","_deactivateDraw","getTargetId","OverlayMarkerType","ANNOTATED_CUBE","AXES","CUSTOM","OrientationMarkerTool","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","resolution","polyDataURL","_resizeObservers","initViewports","_subscribeToViewportEvents","cleanUpData","resize","orientationMarker","orientationMarkers","updateViewport","CUBE","AXIS","VTPFILE","unsubscribe","unobserve","TOOLGROUP_VIEWPORT_ADDED","subscribeToElementResize","resizeObserver","ResizeObserver","setTimeout","observe","offscreenMultiRenderWindow","getRenderWindow","filterViewportsWithToolEnabled","getWidget","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","polyData","shallowCopy","getOutputData","setActiveScalars","mapper","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","EPSILON","OverlayGridTool","sourceImageIds","_init","pointSets","calculateImageIdPointSets","viewportData","rows","columns","pointSet1","pointSet2","imageIdNormal","getImageIdNormal","isParallel","targetViewportPlane","targetData","initializeViewportData","pointSetsToUse","pointSetToUse","topBottomVec","isPerpendicular","lineStartsWorld","lineEndsWorld","lineStartWorld","lineEndWorld","vec1","vec2","dot","imageOrientationPatient","PanTool","touchDragCallback","mouseDragCallback","PlanarRotateTool","startPoints","currentPointWorld","startPointWorld","centerWorld","v1","v2","cross","rotAngle","rotMat","Float32Array","rotatedViewUp","rotation","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","dotProduct","newWorldPos","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","upper","lower","centerSpace","lineLength","plane","currentMousePosition","closestIndex","setImageIdIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","ReferenceLines","showFullDimension","getImageData","sourceViewportCanvasCornersInWorld","onSetToolConfiguration","getEnabledElementByViewportId","sourceViewPlaneNormal","topRightVec","newNormal","handleFullDimension","targetImage","getTargetIdImage","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","indexToWorld","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","offset","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","devicePixelRatio","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","dragCallback","sculpt","registerShapes","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mouseCanvasPoint","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertIndex","insertHandleRadially","last","previousIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","canvasPoints","closest","toolIndex","distanceFromTool","renderShape","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","actorEntries","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","floor","colorToString","getProperty","getColor","StackScrollTool","debounceIfNotLoaded","loop","deltaY","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","scroll","debounceLoading","numberOfSlices","getNumberOfSlices","offsetHeight","StackScrollMouseWheelTool","scrollSlabs","mouseWheelCallback","wheel","TrackballRotateTool","rotateIncrementDegrees","_hasResolutionChanged","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_viewportAddedListener","disconnect","rotateCamera","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","DIRECTIONS","VolumeRotateMouseWheelTool","cz","ax","ay","az","WindowLevelRegionTool","minWindowWidth","applyWindowLevelRegion","bottomLeftCanvas","topRightCanvas","bottomRightCanvas","topLeftCanvas","bottomRightWorld","topLeftWorld","getAnnotationStyle","windowLevel","startCanvas","endCanvas","clip","pixelLuminanceData","minMaxMean","minPixelValue","maxPixelValue","windowWidth","windowCenter","mean","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint16Array","Int16Array","frame","buffer","_getMinMax","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","Modality","scaling","preScale","scaled","scalingParameters","suvbw","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","imageDynamicRange","imageVolume","calculatedDynamicRange","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","getRange","imageDataRange","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","initialMousePosWorld","dirVec","_dragParallelProjection","pinch","deltaDistance","k","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","scale","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","currentPointsList","parallelProjection","_panCallback","AngleTool","getTextLines","defaultGetTextLines","angleStartedNotYetCompleted","movingTextBox","canvasPoint1","canvasPoint2","line1","canvasPoint3","line2","worldPosDelta","_throttledCalculateCachedStats","_calculateCachedStats","getLinkedTextBoxStyle","canvasTextBoxCoords","drawLinkedTextBox","trailing","worldPos1","worldPos2","worldPos3","targetIds","cachedVolumeStats","roundNumber","String","fromCharCode","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedText","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","transformWorldToIndex","BidirectionalTool","distanceToPoint","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","unit","dataId1","dataId2","secondLineUID","getTextBoxCoordsCanvas","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","image","index3","index4","handles1","handles2","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","vector1","vector2","pos1","pos2","dz","CircleROITool","centerPointRadius","statsCalculator","BasicStatsCalculator","dXCanvas","dYCanvas","canvasEnd","canvasCorners","areaUnit","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","area","stdDev","radiusUnit","perimeter","hasPixelSpacing","pos1Index","pos2Index","boundsIJK","ellipseObj","xRadius","yRadius","zRadius","worldWidth","worldHeight","isEmptyArea","areaUnits","getCalibratedLengthUnitsAndScale","aspect","modalityUnitOptions","isSuvScaled","modalityUnit","pointsInShape","pointInShapeCallback","pointLPS","pointInEllipse","fast","statsCallback","stats","getStatistics","statsArray","array","radiusLine","areaLine","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseUpCallback","_mouseDownCallback","_mouseDragCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","dist","DragProbeTool","postMouseDownCallback","postTouchStartCallback","EllipticalROITool","initialRotation","getRotation","getCanvasEllipseCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","newHalfCanvasWidth","canvasRight","newHalfCanvasHeight","centerPoint","_getCanvasEllipseCenter","post2Index","ellipse","normalized","ellipseCanvasPoints","HeightTool","_calculateHeight","KeyImageTool","canvasPosition","createAnnotation","it","LengthTool","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","setupBaseEditData","scissors","nearestEdge","repeatInterpolation","interpolation","originalPoints","worldToSlice","sliceToWorld","handleSmoothing","lastPoint","hIndex","testPoint","startSearch","findPathToPoint","minPoint","findMinNearby","acceptedPath","path","addPoints","updateAnnotation","scissorsNext","InterpolationUpdated","renderAnnotationInstance","renderContext","showInterpolationPolyline","rendered","polylineCanvasPoints","isContourSegmentationTool","LivewireContourTool","contourHoleAdditionModifierKey","snapHandleNearby","decimate","epsilon","undo","proximitySquared","clearAnnotation","clearEditData","Completed","triggerChangeEvent","StatsUpdated","doubleClick","worldPosOriginal","controlPoints","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","pathPoints","prependPath","confirmedPath","getLastPoint","addControlPoint","_mouseMoveCallback","lastCanvasPoint","imgWidth","imgHeight","slicePoint","editHandle","nextPos","viewportImageData","vtkImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","createInstanceFromRawPixelData","currentPathNext","addPoint","confirmedPathNext","numHandles","previousHandle","nextHandle","slicePos","pathPointsLeft","pathPointsRight","appendPath","annotationStyle","canvasHandles","livewirePath","pointArray","imagePoints","updateContourPolyline","allowOpenContours","renderResult","ProbeTool","eventDispatchDetail","samplesPerPixel","yMultiple","zMultiple","baseIndex","imageURI","calibratedResults","hasEnhancedRegionValues","RectangleROITool","rect","_getRectangleImageCoordinates","bottomLeftWorld","topRightWorld","point0","SplineContourSegmentationTool","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","Cardinal","Class","CatmullRom","Linear","BSpline","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","instance","isPointNearCurve","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","worldPoint","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","maxDist","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","throttle","SplineTypes","cancelAnnotation","annotationLocked","childAnnotations","join","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","textbox","createInterpolatedSplineControl","increment","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","parseInt","setControlPoints","fixedResolution","fixedScale","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","values2","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldPos1Index","worldPos2Index","worldToIndexVec3","iMin","iMax","jMin","jMax","kMin","kMax","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex","substring","_getTargetStackUID","AnnotationDisplayTool","frameOfReference","BaseTool","initialProps","strategies","defaultStrategy","activeStrategy","strategyOptions","Disabled","applyActiveStrategy","operationData","call","applyActiveStrategyCallback","callbackType","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getClassName","getReferenceId","MAX_NUMBER_COLORS","labelMapConfigCache","getRepresentationRenderingConfig","cfun","ofun","polySegConversionInProgress","_getLabelmapConfig","toolGroupLabelmapConfig","segmentationRepresentationLabelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","fillAlphaInactive","outlineWidth","outlineWidthActive","outlineWidthInactive","renderFill","renderFillInactive","renderOutline","outlineOpacity","outlineOpacityInactive","_needsTransferFunctionUpdate","segmentColor","cacheUID","oldConfig","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_addLabelmapToViewport","toolGroupConfig","renderingConfig","labelmapUID","defaultActorUID","isSameFrameOfReference","numColors","segmentSpecificLabelmapConfig","addRGBPoint","segmentOpacity","removePoint","addPointLong","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","activeSegmentOutlineWidthDelta","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","renderImmediate","_removeLabelmapFromToolGroupViewports","RectangleROIThresholdTool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","showTextBox","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","projectionPointsImageIds","statistics","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","viewplaneNormal","_getCoordinateForViewplaneNormal","roundedStartCoord","roundedEndCoord","coord","roundedCoord","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","_getIndexOfCoordinatesForViewplaneNormal","newProjectionPoints","newPoint","pointsInsideVolume","getWorldWidthAndHeightFromCorners","measureInfo","habdles","isViewportPreScaled","getModalityUnit","projectionPoint","worldProjectionPointIndex","indexOfProjection","endPos","viewplaneNormalAbs","pos","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","strategySpecificConfiguration","THRESHOLD","threshold","thresholdVolumeId","brushSize","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","AcceptPreview","RejectPreview","_previewData","timerStart","timer","NaN","isDrag","_editData","createEditData","Date","now","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","time","clearTimeout","rejectPreview","previewCallback","Preview","OnInteractionEnd","acceptPreview","activeSegmentationRepresentation","activeSegmentation","segmentLocking","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","volumes","referenceId","referencedVolumeIdToThreshold","getActiveSegmentationData","brushCursor","_calculateCursor","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","strategy","computeInnerCircleRadius","toolMetadata","brushCursorUID","dynamicRadiusInCanvas","circleUID1","CircleROIStartEndThresholdTool","isMiddleSlice","lineWidthToUse","handlesToStart","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","CircleScissorsTool","FILL_INSIDE","ERASE_INSIDE","isEqual","PaintFillTool","getDirection","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataPosition","framesModified","getFramesModified","boundaries","minJ","maxJ","seedIndex3D","getScalarDataPosition","z","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","RectangleScissorsTool","SegmentSelectTool","hoverTimeout","SelectMode","Border","searchRadius","hoverTimer","_setActiveSegment","Inside","activeSegmentationReps","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentAtWorldPoint","getSegmentAtLabelmapBorder","getHoveredContourSegmentationAnnotation","v","SphereScissorsTool","isVolumeSegmentation","ContourWindingDirection","getViewportsForAnnotation","getEnabledElements","sourcePoints","minDistance","MAX_SAFE_INTEGER","sourcePoint","p1","p2","_distanceBetween","segmentIndicesCache","setSegmentationDirty","cached","isDirty","cachedResult","getCachedSegmentIndices","keySet","addVolumeSegmentIndices","segmentationImageId","addImageSegmentIndices","handleLabelmapSegmentation","getSegmentIndex","handleContourSegmentation","handleSurfaceSegmentation","segmentationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedToolGroups","_throwIfDestroyed","_triggerRender","removeToolGroup","_reset","renderToolGroupSegmentations","_setToolGroupSegmentationToBeRenderedNextFrame","hasBeenDestroyed","_render","segmentationDisplayToolInstance","onSegmentationRender","renderSegmentation","cancelAnimationFrame","annotationRenderingEngine","_renderFlaggedViewports","elements","_viewportElements","_setViewportsToBeRenderedNextFrame","_setAllViewportsToBeRenderedNextFrame","elementsEnabled","enabledTools","draw","anyRendered","ANNOTATION_RENDERED"],"sourceRoot":""}