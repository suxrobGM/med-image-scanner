{"version":3,"file":"3117.bundle.a96ddd05a8116eec40ae.js","mappings":"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","sources":["webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/VideoViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addImageSlicesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/addVolumesToViewports.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/colors/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/now.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getVOILut.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/setToPixelCoordinateSystem.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/doesImageNeedToBeRendered.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/initializeRenderCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/saveLastRendered.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/renderColorImage.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/generateColorLUT.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedRGBAPixelDataToCanvasImageData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedColorPixelDataToCanvasImageData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/computeAutoVoi.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/lutMatches.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getLut.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/generateLut.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getModalityLut.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/renderGrayscaleImage.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPET.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataRGBA.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUT.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/storedPixelDataToCanvasImageDataPseudocolorLUTPET.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/renderPseudoColorImage.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/drawImageSync.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/canvasToPixel.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/correctShift.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/setDefaultViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/createViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageFitScale.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getImageSize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/getTransform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/pixelToCanvas.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resetCamera.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/resize.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/fitToWindow.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/transform.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/cpuFallback/rendering/validator.ts","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Volume.js","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/createVolumeActor.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/helpers/setDefaultVolumeVOI.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/RenderingEngine/vtkClasses/vtkSharedVolumeMapper.js","webpack:///../../../node_modules/@cornerstonejs/core/src/cache/cache.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/rendering.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/constants/epsilon.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/RequestType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/ViewportStatus.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/BlendModes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/GeometryType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/DynamicOperatorType.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/enums/CalibrationTypes.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/getEnabledElement.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/Settings.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/imageLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/loaders/volumeLoader.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/metaData.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/imageLoadPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/requestPool/requestPoolManager.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/cacheUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/colormap.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/createLinearRGBTransferFunction.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/getImageSliceDataForVolumeViewport.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transferFunctionUtils.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/transformWorldToIndex.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/utilities/triggerEvent.ts","webpack:///../../../node_modules/@cornerstonejs/core/src/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/src/cursors/SVGCursorDescriptor.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/getSvgDrawingHelper.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/drawingSvg/draw.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/enums/ToolModes.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/ToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/createToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroy.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/destroyToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getAllToolGroups.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroup.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/BidirectionalTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/annotation/PlanarFreehandROITool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/displayTools/SegmentationDisplayTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack:///../../../node_modules/@cornerstonejs/tools/src/utilities/index.ts","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/Camera.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ImageSlice.js","webpack:///../../../node_modules/lodash.get/index.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/bisector.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\nimport {\n  Events as EVENTS,\n  VideoEnums as VideoViewportEnum,\n  MetadataModules,\n} from '../enums';\nimport type {\n  IVideoViewport,\n  VideoViewportProperties,\n  Point3,\n  Point2,\n  ICamera,\n  InternalVideoCamera,\n  VideoViewportInput,\n  VOIRange,\n  ICanvasActor,\n  IImage,\n  ViewReferenceSpecifier,\n  ViewReference,\n  ReferenceCompatibleOptions,\n  ImageSetOptions,\n} from '../types';\nimport * as metaData from '../metaData';\nimport { Transform } from './helpers/cpuFallback/rendering/transform';\nimport { triggerEvent } from '../utilities';\nimport Viewport from './Viewport';\nimport { getOrCreateCanvas } from './helpers';\nimport CanvasActor from './CanvasActor';\nimport cache from '../cache';\n\n/**\n * A data type for the scalar data for video data.\n */\nexport type CanvasScalarData = Uint8ClampedArray & {\n  frameNumber?: number;\n  getRange?: () => [number, number];\n};\n\n/**\n * An object representing a single stack viewport, which is a camera\n * looking into an internal scene, and an associated target output `canvas`.\n */\nclass VideoViewport extends Viewport implements IVideoViewport {\n  public static frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i;\n\n  public modality;\n  // Viewport Data\n  protected imageId: string;\n  readonly uid;\n  readonly renderingEngineId: string;\n  readonly canvasContext: CanvasRenderingContext2D;\n  private videoElement?: HTMLVideoElement;\n  private videoWidth = 0;\n  private videoHeight = 0;\n\n  private loop = true;\n  private mute = true;\n  private isPlaying = false;\n  private scrollSpeed = 1;\n  private playbackRate = 1;\n  private scalarData: CanvasScalarData;\n\n  /**\n   * This is used to pause initially so that we get at least one render to allow\n   * navigating frames.  Otherwise the viewport is blank initially until the user\n   * hits play manually.\n   */\n  private initialRender: () => void;\n\n  /**\n   * The range is the set of frames to play\n   */\n  private frameRange: [number, number] = [0, 0];\n\n  protected metadata;\n\n  /**\n   * The fps, frames per second is used to calculate time/frame mapping values.\n   * It is provided by the CINE Module in the metadata, defaulting to 30 if not\n   * provided.\n   */\n  private fps = 30;\n\n  /** The number of frames in the video */\n  private numberOfFrames: number;\n\n  private videoCamera: InternalVideoCamera = {\n    panWorld: [0, 0],\n    parallelScale: 1,\n  };\n\n  /**\n   * feFilter is an inline string value for the CSS filter on the video\n   * CSS filters can reference SVG filters, so for the typical use case here\n   * the CSS filter is actually an link link to a SVG filter.\n   */\n  private feFilter: string;\n\n  /**\n   * An average white point value, used to color balance the image so that\n   * the given white is mapped to [255,255,255] via multiplication per channel.\n   */\n  private averageWhite: [number, number, number];\n\n  /**\n   * The VOI Range is used to apply contrast/brightness adjustments to the image.\n   */\n  private voiRange: VOIRange = {\n    lower: 0,\n    upper: 255,\n  };\n\n  constructor(props: VideoViewportInput) {\n    super({\n      ...props,\n      canvas: props.canvas || getOrCreateCanvas(props.element),\n    });\n    this.canvasContext = this.canvas.getContext('2d');\n    this.renderingEngineId = props.renderingEngineId;\n\n    this.element.setAttribute('data-viewport-uid', this.id);\n    this.element.setAttribute(\n      'data-rendering-engine-uid',\n      this.renderingEngineId\n    );\n\n    this.videoElement = document.createElement('video');\n    this.videoElement.muted = this.mute;\n    this.videoElement.loop = this.loop;\n    this.videoElement.autoplay = true;\n    this.videoElement.crossOrigin = 'anonymous';\n\n    this.addEventListeners();\n    this.resize();\n  }\n\n  public static get useCustomRenderingPipeline() {\n    return true;\n  }\n\n  private addEventListeners() {\n    this.canvas.addEventListener(\n      EVENTS.ELEMENT_DISABLED,\n      this.elementDisabledHandler\n    );\n  }\n\n  private removeEventListeners() {\n    this.canvas.removeEventListener(\n      EVENTS.ELEMENT_DISABLED,\n      this.elementDisabledHandler\n    );\n  }\n\n  private elementDisabledHandler() {\n    this.removeEventListeners();\n    this.videoElement.remove();\n  }\n\n  public getImageDataMetadata(image: IImage | string) {\n    const imageId = typeof image === 'string' ? image : image.imageId;\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\n\n    let rowCosines = <Point3>imagePlaneModule.rowCosines;\n    let columnCosines = <Point3>imagePlaneModule.columnCosines;\n\n    // if null or undefined\n    if (rowCosines == null || columnCosines == null) {\n      rowCosines = <Point3>[1, 0, 0];\n      columnCosines = <Point3>[0, 1, 0];\n    }\n\n    const rowCosineVec = vec3.fromValues(\n      rowCosines[0],\n      rowCosines[1],\n      rowCosines[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      columnCosines[0],\n      columnCosines[1],\n      columnCosines[2]\n    );\n\n    const { rows, columns } = imagePlaneModule;\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n\n    let origin = imagePlaneModule.imagePositionPatient;\n    // if null or undefined\n    if (origin == null) {\n      origin = [0, 0, 0];\n    }\n\n    const xSpacing = imagePlaneModule.columnPixelSpacing || 1;\n    const ySpacing = imagePlaneModule.rowPixelSpacing || 1;\n    const xVoxels = imagePlaneModule.columns;\n    const yVoxels = imagePlaneModule.rows;\n\n    const zSpacing = 1;\n    const zVoxels = 1;\n\n    this.hasPixelSpacing = !!imagePlaneModule.columnPixelSpacing;\n    return {\n      bitsAllocated: 8,\n      numComps: 3,\n      origin,\n      rows,\n      columns,\n      direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\n      dimensions: [xVoxels, yVoxels, zVoxels],\n      spacing: [xSpacing, ySpacing, zSpacing],\n      hasPixelSpacing: this.hasPixelSpacing,\n      numVoxels: xVoxels * yVoxels * zVoxels,\n      imagePlaneModule,\n    };\n  }\n\n  /**\n   * This is a wrapper for setVideo to allow generic behaviour\n   *\n   * @param _groupId - the id for the overall set of image ids.  Unused for video viewport.\n   * @param imageIds - a singleton list containing the imageId of a video.\n   */\n  public setDataIds(imageIds: string[], options?: ImageSetOptions) {\n    this.setVideo(\n      imageIds[0],\n      (options?.viewReference?.sliceIndex as number) || 1\n    );\n  }\n\n  /**\n   * Sets the video image id to show and hte frame number.\n   * Requirements are to have the imageUrlModule in the metadata\n   * with the rendered endpoint being the raw video in video/mp4 format.\n   */\n  public setVideo(imageId: string, frameNumber?: number): Promise<unknown> {\n    this.imageId = Array.isArray(imageId) ? imageId[0] : imageId;\n    const imageUrlModule = metaData.get(MetadataModules.IMAGE_URL, imageId);\n    if (!imageUrlModule?.rendered) {\n      throw new Error(\n        `Video Image ID ${imageId} does not have a rendered video view`\n      );\n    }\n    const { rendered } = imageUrlModule;\n    const generalSeries = metaData.get(MetadataModules.GENERAL_SERIES, imageId);\n    this.modality = generalSeries?.Modality;\n    this.metadata = this.getImageDataMetadata(imageId);\n    let { cineRate, numberOfFrames } = metaData.get(\n      MetadataModules.CINE,\n      imageId\n    );\n    this.numberOfFrames = numberOfFrames;\n\n    return this.setVideoURL(rendered).then(() => {\n      if (!numberOfFrames || numberOfFrames === 1) {\n        numberOfFrames = Math.round(\n          this.videoElement.duration * (cineRate || 30)\n        );\n      }\n      if (!cineRate) {\n        cineRate = Math.round(numberOfFrames / this.videoElement.duration);\n      }\n      this.fps = cineRate;\n      this.numberOfFrames = numberOfFrames;\n      // 1 based range setting\n      this.setFrameRange([1, numberOfFrames]);\n      // The initial render allows us to set the frame position - rendering needs\n      // to start already playing\n      this.initialRender = () => {\n        this.initialRender = null;\n        this.pause();\n        this.setFrameNumber(frameNumber || 1);\n      };\n\n      // This is ugly, but without it, the video often fails to render initially\n      // so having a play, followed by a pause fixes things.\n      // 25 ms is a tested value that seems to work to prevent exceptions\n      return new Promise((resolve) => {\n        window.setTimeout(() => {\n          this.setFrameNumber(frameNumber || 1);\n          resolve(this);\n        }, 25);\n      });\n    });\n  }\n\n  public async setVideoURL(videoURL: string) {\n    return new Promise((resolve) => {\n      this.videoElement.src = videoURL;\n      this.videoElement.preload = 'auto';\n\n      const loadedMetadataEventHandler = () => {\n        this.videoWidth = this.videoElement.videoWidth;\n        this.videoHeight = this.videoElement.videoHeight;\n        this.videoElement.removeEventListener(\n          'loadedmetadata',\n          loadedMetadataEventHandler\n        );\n\n        this.refreshRenderValues();\n\n        resolve(true);\n      };\n\n      this.videoElement.addEventListener(\n        'loadedmetadata',\n        loadedMetadataEventHandler\n      );\n    });\n  }\n\n  /**\n   * Gets all the image ids associated with this video element.  This will\n   * have # of frames elements.\n   */\n  public getImageIds(): string[] {\n    const imageIds = new Array<string>(this.numberOfFrames);\n    const baseImageId = this.imageId.replace(/[0-9]+$/, '');\n    for (let i = 0; i < this.numberOfFrames; i++) {\n      imageIds[i] = `${baseImageId}${i + 1}`;\n    }\n    return imageIds;\n  }\n\n  public togglePlayPause(): boolean {\n    if (this.isPlaying) {\n      this.pause();\n      return false;\n    } else {\n      this.play();\n      return true;\n    }\n  }\n\n  public async play() {\n    try {\n      if (!this.isPlaying) {\n        this.isPlaying = true;\n        // Play returns a promise that is true when playing completes.\n        await this.videoElement.play();\n        this.renderWhilstPlaying();\n      }\n    } catch (e) {\n      // No-op, an exception sometimes gets thrown on the initial play, not\n      // quite sure why.  Catching it prevents displaying an error\n    }\n  }\n\n  public pause() {\n    try {\n      this.isPlaying = false;\n      this.videoElement.pause();\n    } catch (e) {\n      // No-op - sometimes this happens on startup\n    }\n  }\n\n  public async scroll(delta = 1) {\n    await this.pause();\n\n    const videoElement = this.videoElement;\n    const renderFrame = this.renderFrame;\n\n    const currentTime = videoElement.currentTime;\n    const newTime = currentTime + (delta * this.scrollSpeed) / this.fps;\n\n    videoElement.currentTime = newTime;\n\n    // Need to wait for seek update\n    const seekEventListener = (evt) => {\n      renderFrame();\n\n      videoElement.removeEventListener('seeked', seekEventListener);\n    };\n\n    videoElement.addEventListener('seeked', seekEventListener);\n  }\n\n  public async start() {\n    const videoElement = this.videoElement;\n    const renderFrame = this.renderFrame;\n\n    videoElement.currentTime = 0;\n\n    if (videoElement.paused) {\n      // Need to wait for seek update\n      const seekEventListener = (evt) => {\n        renderFrame();\n\n        videoElement.removeEventListener('seeked', seekEventListener);\n      };\n\n      videoElement.addEventListener('seeked', seekEventListener);\n    }\n  }\n\n  public async end() {\n    const videoElement = this.videoElement;\n    const renderFrame = this.renderFrame;\n\n    videoElement.currentTime = videoElement.duration;\n\n    if (videoElement.paused) {\n      // Need to wait for seek update\n      const seekEventListener = (evt) => {\n        renderFrame();\n\n        videoElement.removeEventListener('seeked', seekEventListener);\n      };\n\n      videoElement.addEventListener('seeked', seekEventListener);\n    }\n  }\n\n  public async setTime(timeInSeconds: number) {\n    const videoElement = this.videoElement;\n    const renderFrame = this.renderFrame;\n\n    videoElement.currentTime = timeInSeconds;\n\n    if (videoElement.paused) {\n      // Need to wait for seek update\n      const seekEventListener = (evt) => {\n        renderFrame();\n\n        videoElement.removeEventListener('seeked', seekEventListener);\n      };\n\n      videoElement.addEventListener('seeked', seekEventListener);\n    }\n  }\n\n  // Sets the frame number - note according to DICOM, this is 1 based\n  public async setFrameNumber(frame: number) {\n    this.setTime((frame - 1) / this.fps);\n  }\n\n  /**\n   * Sets the playback frame range.  The video will play over the given set\n   * of frames (assuming it is playing).\n   *\n   * @param frameRange - the minimum to maximum (inclusive) frames to play over\n   * @returns\n   */\n  public setFrameRange(frameRange: number[]) {\n    if (!frameRange) {\n      this.frameRange = [1, this.numberOfFrames];\n      return;\n    }\n    if (frameRange.length !== 2 || frameRange[0] === frameRange[1]) {\n      return;\n    }\n    this.frameRange = [frameRange[0], frameRange[1]];\n  }\n\n  public getFrameRange(): [number, number] {\n    return this.frameRange;\n  }\n\n  public setProperties(props: VideoViewportProperties) {\n    if (props.loop !== undefined) {\n      this.videoElement.loop = props.loop;\n    }\n\n    if (props.muted !== undefined) {\n      this.videoElement.muted = props.muted;\n    }\n\n    if (props.playbackRate !== undefined) {\n      this.setPlaybackRate(props.playbackRate);\n    }\n\n    if (props.scrollSpeed !== undefined) {\n      this.setScrollSpeed(props.scrollSpeed);\n    }\n\n    if (props.voiRange) {\n      this.setVOI(props.voiRange);\n    }\n  }\n\n  public setPlaybackRate(rate = 1) {\n    this.playbackRate = rate;\n    // Minimum playback speed in chrome is 0.0625 compared to normal\n    if (rate < 0.0625) {\n      this.pause();\n      return;\n    }\n    if (!this.videoElement) {\n      return;\n    }\n    this.videoElement.playbackRate = rate;\n    this.play();\n  }\n\n  public setScrollSpeed(\n    scrollSpeed = 1,\n    unit = VideoViewportEnum.SpeedUnit.FRAME\n  ) {\n    this.scrollSpeed =\n      unit === VideoViewportEnum.SpeedUnit.SECOND\n        ? scrollSpeed * this.fps\n        : scrollSpeed;\n  }\n\n  public getProperties = (): VideoViewportProperties => {\n    return {\n      loop: this.videoElement.loop,\n      muted: this.videoElement.muted,\n      playbackRate: this.playbackRate,\n      scrollSpeed: this.scrollSpeed,\n      voiRange: { ...this.voiRange },\n    };\n  };\n\n  public resetProperties() {\n    this.setProperties({\n      loop: false,\n      muted: true,\n    });\n  }\n\n  protected getScalarData(): CanvasScalarData {\n    if (this.scalarData?.frameNumber === this.getFrameNumber()) {\n      return this.scalarData;\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = this.videoWidth;\n    canvas.height = this.videoHeight;\n    const context = canvas.getContext('2d');\n    context.drawImage(this.videoElement, 0, 0);\n    const canvasData = context.getImageData(\n      0,\n      0,\n      this.videoWidth,\n      this.videoHeight\n    );\n    const scalarData = canvasData.data as CanvasScalarData;\n    scalarData.getRange = () => [0, 255];\n    scalarData.frameNumber = this.getFrameNumber();\n    this.scalarData = scalarData;\n    return scalarData;\n  }\n\n  public getImageData() {\n    const { metadata } = this;\n\n    const spacing = metadata.spacing;\n\n    const imageData = {\n      dimensions: metadata.dimensions,\n      spacing,\n      origin: metadata.origin,\n      direction: metadata.direction,\n      metadata: { Modality: this.modality },\n      getScalarData: () => this.getScalarData(),\n      imageData: {\n        getDirection: () => metadata.direction,\n        getDimensions: () => metadata.dimensions,\n        getRange: () => [0, 255],\n        getScalarData: () => this.getScalarData(),\n        getSpacing: () => metadata.spacing,\n        worldToIndex: (point: Point3) => {\n          const canvasPoint = this.worldToCanvas(point);\n          const pixelCoord = this.canvasToIndex(canvasPoint);\n          return [pixelCoord[0], pixelCoord[1], 0];\n        },\n        indexToWorld: (point: Point2, destPoint?: Point3) => {\n          const canvasPoint = this.indexToCanvas([point[0], point[1]]);\n          return this.canvasToWorld(canvasPoint, destPoint);\n        },\n      },\n      hasPixelSpacing: this.hasPixelSpacing,\n      calibration: this.calibration,\n      preScale: {\n        scaled: false,\n      },\n    };\n    Object.defineProperty(imageData, 'scalarData', {\n      get: () => this.getScalarData(),\n      enumerable: true,\n    });\n    return imageData;\n  }\n\n  /**\n   * Checks to see if the imageURI is currently being displayed.  The imageURI\n   * may contain frame numbers according to the DICOM standard format, which\n   * will be stripped to compare the base image URI, and then the values used\n   * to check if that frame is currently being displayed.\n   *\n   * The DICOM standard allows for comma separated values as well, however,\n   * this is not supported here, with only a single range or single value\n   * being tested.\n   *\n   * For a single value, the time range +/- 5 frames is permitted to allow\n   * the detection to actually succeed when nearby without requiring an exact\n   * time frame to be matched.\n   *\n   * @param imageURI - containing frame number or range.\n   * @returns\n   */\n  public hasImageURI(imageURI: string): boolean {\n    // TODO - move annotationFrameRange into core so it can be used here.\n    const framesMatch = imageURI.match(VideoViewport.frameRangeExtractor);\n    const testURI = framesMatch\n      ? imageURI.substring(0, framesMatch.index)\n      : imageURI;\n    return this.imageId.indexOf(testURI) !== -1;\n  }\n\n  public setVOI(voiRange: VOIRange): void {\n    this.voiRange = voiRange;\n    this.setColorTransform();\n  }\n\n  public setWindowLevel(windowWidth = 256, windowCenter = 128) {\n    const lower = windowCenter - windowWidth / 2;\n    const upper = windowCenter + windowWidth / 2 - 1;\n    this.setVOI({ lower, upper });\n    this.setColorTransform();\n  }\n\n  public setAverageWhite(averageWhite: [number, number, number]) {\n    this.averageWhite = averageWhite;\n    this.setColorTransform();\n  }\n\n  protected setColorTransform() {\n    if (!this.voiRange && !this.averageWhite) {\n      this.feFilter = null;\n      return;\n    }\n    const white = this.averageWhite || [255, 255, 255];\n    const maxWhite = Math.max(...white);\n    const scaleWhite = white.map((c) => maxWhite / c);\n    const { lower = 0, upper = 255 } = this.voiRange || {};\n    const wlScale = (upper - lower + 1) / 255;\n    const wlDelta = lower / 255;\n    this.feFilter = `url('data:image/svg+xml,\\\n      <svg xmlns=\"http://www.w3.org/2000/svg\">\\\n        <filter id=\"colour\" color-interpolation-filters=\"linearRGB\">\\\n        <feColorMatrix type=\"matrix\" \\\n        values=\"\\\n          ${scaleWhite[0] * wlScale} 0 0 0 ${wlDelta} \\\n          0 ${scaleWhite[1] * wlScale} 0 0 ${wlDelta} \\\n          0 0 ${scaleWhite[2] * wlScale} 0 ${wlDelta} \\\n          0 0 0 1 0\" />\\\n        </filter>\\\n      </svg>#colour')`;\n\n    this.canvas.style.filter = this.feFilter;\n  }\n\n  public setCamera(camera: ICamera): void {\n    const { parallelScale, focalPoint } = camera;\n\n    // NOTE: the parallel scale should be done first\n    // because it affects the focal point later\n    if (parallelScale) {\n      this.videoCamera.parallelScale =\n        this.element.clientHeight / 2 / parallelScale;\n    }\n\n    if (focalPoint !== undefined) {\n      const focalPointCanvas = this.worldToCanvas(focalPoint);\n      const canvasCenter: Point2 = [\n        this.element.clientWidth / 2,\n        this.element.clientHeight / 2,\n      ];\n\n      const panWorldDelta: Point2 = [\n        (focalPointCanvas[0] - canvasCenter[0]) /\n          this.videoCamera.parallelScale,\n        (focalPointCanvas[1] - canvasCenter[1]) /\n          this.videoCamera.parallelScale,\n      ];\n\n      this.videoCamera.panWorld = [\n        this.videoCamera.panWorld[0] - panWorldDelta[0],\n        this.videoCamera.panWorld[1] - panWorldDelta[1],\n      ];\n    }\n\n    this.canvasContext.fillStyle = 'rgba(0,0,0,1)';\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    if (this.isPlaying === false) {\n      this.renderFrame();\n    }\n  }\n\n  /**\n   * This function returns the imageID associated with either the current\n   * frame being displayed, or the range of frames being played.  This may not\n   * correspond to any particular imageId that has imageId metadata, as the\n   * format is one of:\n   * `<DICOMweb URI>/frames/<Start Frame>(-<End Frame>)?`\n   * or\n   * `<Other URI>[?&]frameNumber=<Start Frame>(-<EndFrame>)?`\n   * for a URL parameter.\n   *\n   * @returns an imageID for video\n   */\n  public getCurrentImageId() {\n    const current = this.imageId.replace(\n      '/frames/1',\n      this.isPlaying\n        ? `/frames/${this.frameRange[0]}-${this.frameRange[1]}`\n        : `/frames/${this.getFrameNumber()}`\n    );\n    return current;\n  }\n\n  /**\n   *  Gets a target id that can be used to specify how to show this\n   */\n  public getReferenceId(specifier: ViewReferenceSpecifier = {}): string {\n    const { sliceIndex: sliceIndex } = specifier;\n    if (sliceIndex === undefined) {\n      return `videoId:${this.getCurrentImageId()}`;\n    }\n    if (Array.isArray(sliceIndex)) {\n      // Just remove the 1 from the end of the base URL - TODO, handle other types\n      return `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${\n        sliceIndex[0] + 1\n      }-${sliceIndex[1] + 1}`;\n    }\n    const baseTarget = this.imageId.replace(\n      '/frames/1',\n      `/frames/${1 + sliceIndex}`\n    );\n    return `videoId:${baseTarget}`;\n  }\n\n  /**\n   * Figure out if a given view can be shown in the current viewport.\n   */\n  public isReferenceViewable(\n    viewRef: ViewReference,\n    options: ReferenceCompatibleOptions = {}\n  ): boolean {\n    let { imageURI } = options;\n    const { referencedImageId, sliceIndex: sliceIndex } = viewRef;\n    if (!super.isReferenceViewable(viewRef)) {\n      return false;\n    }\n\n    const imageId = this.getCurrentImageId();\n    if (!imageURI) {\n      // Remove the dataLoader scheme and frame number\n      // TODO - handle more imageURI types.\n      const colonIndex = imageId.indexOf(':');\n      imageURI = imageId.substring(colonIndex + 1, imageId.length - 1);\n    }\n\n    if (options.withNavigation) {\n      return true;\n    }\n    const currentIndex = this.getSliceIndex();\n    if (Array.isArray(sliceIndex)) {\n      return currentIndex >= sliceIndex[0] && currentIndex <= sliceIndex[1];\n    }\n    if (sliceIndex !== undefined) {\n      return currentIndex === sliceIndex;\n    }\n    if (!referencedImageId) {\n      return false;\n    }\n    const match = referencedImageId.match(VideoViewport.frameRangeExtractor);\n    if (!match || !match[2]) {\n      return true;\n    }\n    const range = match[2].split('-').map((it) => Number(it));\n    const frame = currentIndex + 1;\n    return range[0] <= frame && frame <= (range[1] ?? range[0]);\n  }\n\n  /**\n   * Navigates the video to the specific view reference\n   */\n  public setViewReference(viewRef: ViewReference): void {\n    if (typeof viewRef.sliceIndex === 'number') {\n      this.setFrameNumber(viewRef.sliceIndex + 1);\n    } else if (Array.isArray(viewRef.sliceIndex)) {\n      this.setFrameRange(viewRef.sliceIndex);\n    }\n  }\n\n  /**\n   * Gets a view target that species what type of view is required to show\n   * the current view, or the one specified in the forTarget modifiers.\n   */\n  public getViewReference(\n    viewRefSpecifier?: ViewReferenceSpecifier\n  ): ViewReference {\n    let sliceIndex = viewRefSpecifier?.sliceIndex;\n    if (!sliceIndex) {\n      sliceIndex = this.isPlaying\n        ? [this.frameRange[0] - 1, this.frameRange[1] - 1]\n        : this.getCurrentImageIdIndex();\n    }\n    return {\n      ...super.getViewReference(viewRefSpecifier),\n      referencedImageId: this.getReferenceId(viewRefSpecifier),\n      sliceIndex: sliceIndex,\n    };\n  }\n\n  /**\n   * Gets the 1 based frame number (ala DICOM value), eg `1+ currentImageIdIndex`\n   */\n  public getFrameNumber() {\n    // Need to round this as the fps/time isn't exact\n    return 1 + this.getCurrentImageIdIndex();\n  }\n\n  public getCurrentImageIdIndex() {\n    return Math.round(this.videoElement.currentTime * this.fps);\n  }\n\n  public getSliceIndex() {\n    return this.getCurrentImageIdIndex() / this.scrollSpeed;\n  }\n\n  public getCamera(): ICamera {\n    const { parallelScale } = this.videoCamera;\n\n    const canvasCenter: Point2 = [\n      this.element.clientWidth / 2,\n      this.element.clientHeight / 2,\n    ];\n\n    // All other viewports have the focal point in canvas coordinates in the center\n    // of the canvas, so to make tools work the same, we need to do the same here\n    // and convert to the world coordinate system since focal point is in world coordinates.\n    const canvasCenterWorld = this.canvasToWorld(canvasCenter);\n\n    return {\n      parallelProjection: true,\n      focalPoint: canvasCenterWorld,\n      position: [0, 0, 0],\n      viewUp: [0, -1, 0],\n      parallelScale: this.element.clientHeight / 2 / parallelScale, // Reverse zoom direction back\n      viewPlaneNormal: [0, 0, 1],\n    };\n  }\n\n  public resetCamera = (): boolean => {\n    this.refreshRenderValues();\n\n    this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    if (this.isPlaying === false) {\n      // If its not replaying, just re-render the frame on move.\n      this.renderFrame();\n    }\n    return true;\n  };\n\n  public getNumberOfSlices = (): number => {\n    const computedSlices = Math.round(\n      (this.videoElement.duration * this.fps) / this.scrollSpeed\n    );\n    return isNaN(computedSlices) ? this.numberOfFrames : computedSlices;\n  };\n\n  public getFrameRate() {\n    return this.fps;\n  }\n\n  public getFrameOfReferenceUID = (): string => {\n    // The video itself is the frame of reference.\n    return this.videoElement.src;\n  };\n\n  public resize = (): void => {\n    const canvas = this.canvas;\n    const { clientWidth, clientHeight } = canvas;\n\n    // Set the canvas to be same resolution as the client.\n    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\n      canvas.width = clientWidth;\n      canvas.height = clientHeight;\n    }\n\n    this.refreshRenderValues();\n\n    if (this.isPlaying === false) {\n      // If its not playing, just re-render on resize.\n      this.renderFrame();\n    }\n  };\n\n  /**\n   * Converts a VideoViewport canvas coordinate to a video coordinate.\n   *\n   * @param canvasPos - to convert to world\n   * @returns World position\n   */\n  public canvasToWorld = (\n    canvasPos: Point2,\n    destPos: Point3 = [0, 0, 0]\n  ): Point3 => {\n    const pan: Point2 = this.videoCamera.panWorld; // In world coordinates\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\n\n    const panOffsetCanvas: Point2 = [\n      pan[0] * worldToCanvasRatio,\n      pan[1] * worldToCanvasRatio,\n    ];\n\n    const subCanvasPos: Point2 = [\n      canvasPos[0] - panOffsetCanvas[0],\n      canvasPos[1] - panOffsetCanvas[1],\n    ];\n\n    // Replace the x,y values only in place in the world position\n    // as the z is unchanging for video display\n    destPos.splice(\n      0,\n      2,\n      subCanvasPos[0] / worldToCanvasRatio,\n      subCanvasPos[1] / worldToCanvasRatio\n    );\n    return destPos;\n  };\n\n  /**\n   * Converts `[x, y, 0]` world video coordinate to canvas CSS coordinates.\n   *\n   * @param  worldPos - world coord to convert to canvas\n   * @returns Canvas position\n   */\n  public worldToCanvas = (worldPos: Point3): Point2 => {\n    const pan: Point2 = this.videoCamera.panWorld;\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\n\n    const canvasPos: Point2 = [\n      (worldPos[0] + pan[0]) * worldToCanvasRatio,\n      (worldPos[1] + pan[1]) * worldToCanvasRatio,\n    ];\n\n    return canvasPos;\n  };\n\n  public getPan(): Point2 {\n    const panWorld = this.videoCamera.panWorld;\n    return [panWorld[0], panWorld[1]];\n  }\n\n  public getRotation = () => 0;\n\n  /**\n   * Uses the transform to convert canvas coordinates into index coordinates.\n   */\n  protected canvasToIndex = (canvasPos: Point2): Point2 => {\n    const transform = this.getTransform();\n    transform.invert();\n\n    return transform.transformPoint(\n      <Point2>canvasPos.map((it) => it * devicePixelRatio)\n    );\n  };\n\n  protected indexToCanvas = (indexPos: Point2): Point2 => {\n    const transform = this.getTransform();\n    return <Point2>(\n      transform.transformPoint(indexPos).map((it) => it / devicePixelRatio)\n    );\n  };\n\n  /**\n   * Sets  initial video camera to center the image area.  The values\n   * are set in canvas CSS pixel units and NOT in canvas index units.\n   */\n  private refreshRenderValues() {\n    // this means that each unit (pixel) in the world (video) would be\n    // represented by n pixels in the canvas, measured in css pixels\n    let worldToCanvasRatio = this.canvas.offsetWidth / this.videoWidth;\n\n    if (this.videoHeight * worldToCanvasRatio > this.canvas.height) {\n      // If by fitting the width, we exceed the height of the viewport, then we need to decrease the\n      // size of the viewport further by considering its verticality.\n      worldToCanvasRatio = this.canvas.offsetHeight / this.videoHeight;\n    }\n\n    // Set the width as big as possible, this is the portion of the canvas\n    // that the video will occupy.\n    const drawWidth = Math.floor(this.videoWidth * worldToCanvasRatio);\n    const drawHeight = Math.floor(this.videoHeight * worldToCanvasRatio);\n\n    // calculate x and y offset in order to center the image\n    const xOffsetCanvas = (this.canvas.offsetWidth - drawWidth) / 2;\n    const yOffsetCanvas = (this.canvas.offsetHeight - drawHeight) / 2;\n\n    const xOffsetWorld = xOffsetCanvas / worldToCanvasRatio;\n    const yOffsetWorld = yOffsetCanvas / worldToCanvasRatio;\n\n    this.videoCamera.panWorld = [xOffsetWorld, yOffsetWorld];\n    this.videoCamera.parallelScale = worldToCanvasRatio;\n  }\n\n  private getWorldToCanvasRatio() {\n    return this.videoCamera.parallelScale;\n  }\n\n  private getCanvasToWorldRatio() {\n    return 1.0 / this.videoCamera.parallelScale;\n  }\n\n  public customRenderViewportToCanvas = () => {\n    this.renderFrame();\n  };\n\n  /**\n   * Creates a transform from video index coordinates to canvas coordinates.\n   */\n  protected getTransform() {\n    const panWorld: Point2 = this.videoCamera.panWorld;\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const worldToCanvasRatio: number = this.getWorldToCanvasRatio();\n    const canvasToWorldRatio: number = this.getCanvasToWorldRatio();\n    const halfCanvas = [\n      this.canvas.offsetWidth / 2,\n      this.canvas.offsetHeight / 2,\n    ];\n    const halfCanvasWorldCoordinates = [\n      halfCanvas[0] * canvasToWorldRatio,\n      halfCanvas[1] * canvasToWorldRatio,\n    ];\n    const transform = new Transform();\n\n    // Start by converting into canvas index coordinates FROM canvas css pixel coordinates\n    transform.scale(devicePixelRatio, devicePixelRatio);\n\n    // Translate to the center of the canvas (move origin of the transform\n    // to the center of the canvas)\n    transform.translate(halfCanvas[0], halfCanvas[1]);\n\n    // Scale\n    transform.scale(worldToCanvasRatio, worldToCanvasRatio);\n\n    // Apply the translation\n    transform.translate(panWorld[0], panWorld[1]);\n\n    // Translate back\n    transform.translate(\n      -halfCanvasWorldCoordinates[0],\n      -halfCanvasWorldCoordinates[1]\n    );\n    return transform;\n  }\n\n  /**\n   * Nothing to do for the clipping planes for video as they don't exist.\n   */\n  public updateCameraClippingPlanesAndRange() {\n    // No-op\n  }\n\n  public addImages(stackInputs: Array<any>) {\n    const actors = this.getActors();\n    stackInputs.forEach((stackInput) => {\n      const image = cache.getImage(stackInput.imageId);\n\n      const imageActor = this.createActorMapper(image);\n      if (imageActor) {\n        actors.push({ uid: stackInput.actorUID, actor: imageActor });\n        if (stackInput.callback) {\n          stackInput.callback({ imageActor, imageId: stackInput.imageId });\n        }\n      }\n    });\n    this.setActors(actors);\n  }\n\n  protected createActorMapper(image) {\n    return new CanvasActor(this, image);\n  }\n\n  /**\n   * Renders the video frame to the viewport.\n   */\n  private renderFrame = () => {\n    const transform = this.getTransform();\n    const transformationMatrix: number[] = transform.getMatrix();\n\n    const ctx = this.canvasContext;\n\n    ctx.resetTransform();\n\n    // Need to correct the transform for device pixel ratio scaling.\n    ctx.transform(\n      transformationMatrix[0],\n      transformationMatrix[1],\n      transformationMatrix[2],\n      transformationMatrix[3],\n      transformationMatrix[4],\n      transformationMatrix[5]\n    );\n\n    ctx.drawImage(\n      this.videoElement,\n      0,\n      0,\n      this.videoWidth || 1024,\n      this.videoHeight || 1024\n    );\n\n    for (const actor of this.getActors()) {\n      (actor.actor as ICanvasActor).render(this, this.canvasContext);\n    }\n    this.canvasContext.resetTransform();\n\n    // This is stack new image to agree with stack/non-volume viewports\n    triggerEvent(this.element, EVENTS.STACK_NEW_IMAGE, {\n      element: this.element,\n      viewportId: this.id,\n      viewport: this,\n      renderingEngineId: this.renderingEngineId,\n      time: this.videoElement.currentTime,\n      duration: this.videoElement.duration,\n    });\n    triggerEvent(this.element, EVENTS.IMAGE_RENDERED, {\n      element: this.element,\n      viewportId: this.id,\n      viewport: this,\n      imageIndex: this.getCurrentImageIdIndex(),\n      numberOfSlices: this.numberOfFrames,\n      renderingEngineId: this.renderingEngineId,\n      time: this.videoElement.currentTime,\n      duration: this.videoElement.duration,\n    });\n\n    this.initialRender?.();\n\n    const frame = this.getFrameNumber();\n    if (this.isPlaying) {\n      if (frame < this.frameRange[0]) {\n        this.setFrameNumber(this.frameRange[0]);\n      } else if (frame > this.frameRange[1]) {\n        if (this.loop) {\n          this.setFrameNumber(this.frameRange[0]);\n        } else {\n          this.pause();\n        }\n      }\n    }\n  };\n\n  private renderWhilstPlaying = () => {\n    this.renderFrame();\n\n    //wait approximately 16ms and run again\n    if (this.isPlaying) {\n      requestAnimationFrame(this.renderWhilstPlaying);\n    }\n  };\n}\n\nexport default VideoViewport;\n","import type {\n  IStackViewport,\n  IStackInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addImageSlicesToViewports(\n  renderingEngine: IRenderingEngine,\n  stackInputs: Array<IStackInput>,\n  viewportIds: Array<string>\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport as IStackViewport).addImages) {\n      console.warn(\n        `Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addStackPromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IStackViewport;\n\n    return viewport.addImages(stackInputs);\n  });\n\n  await Promise.all(addStackPromises);\n}\n\nexport default addImageSlicesToViewports;\n","import BaseVolumeViewport from '../BaseVolumeViewport';\nimport type {\n  IVolumeViewport,\n  IVolumeInput,\n  IRenderingEngine,\n} from '../../types';\n\n/**\n * For each provided viewport it adds a volume to the viewport using the\n * provided renderingEngine\n *\n *\n * @param renderingEngine - The rendering engine to use to get viewports from\n * @param volumeInputs - Array of volume inputs including volumeId. Other properties\n * such as visibility, callback, blendMode, slabThickness are optional\n * @param viewportIds - Array of viewport IDs to add the volume to\n * @param immediateRender - If true, the volumes will be rendered immediately\n * @returns A promise that resolves when all volumes have been added\n */\nasync function addVolumesToViewports(\n  renderingEngine: IRenderingEngine,\n  volumeInputs: Array<IVolumeInput>,\n  viewportIds: Array<string>,\n  immediateRender = false,\n  suppressEvents = false\n): Promise<void> {\n  // Check if all viewports are volumeViewports\n  for (const viewportId of viewportIds) {\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (!viewport) {\n      throw new Error(`Viewport with Id ${viewportId} does not exist`);\n    }\n\n    // if not instance of BaseVolumeViewport, throw\n    if (!(viewport instanceof BaseVolumeViewport)) {\n      console.warn(\n        `Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`\n      );\n\n      return;\n    }\n  }\n\n  const addVolumePromises = viewportIds.map(async (viewportId) => {\n    const viewport = renderingEngine.getViewport(viewportId) as IVolumeViewport;\n\n    await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\n  });\n\n  await Promise.all(addVolumePromises);\n  return;\n}\n\nexport default addVolumesToViewports;\n","import LookupTable from './lookupTable';\nimport CPU_COLORMAPS from '../../../../constants/cpuColormaps';\nimport {\n  CPUFallbackColormap,\n  CPUFallbackColormapData,\n  Point4,\n} from '../../../../types';\n\nconst COLOR_TRANSPARENT: Point4 = [0, 0, 0, 0];\n\n/**\n *  Generate linearly spaced vectors\n *  http://cens.ioc.ee/local/man/matlab/techdoc/ref/linspace.html\n * @param {Number} a A number representing the first vector\n * @param {Number} b A number representing the second vector\n * @param {Number} n The number of linear spaced vectors to generate\n * @returns {Array} An array of points representing linear spaced vectors.\n * @memberof Colors\n */\nfunction linspace(a: number, b: number, n: number): number[] {\n  n = n === null ? 100 : n;\n\n  const increment = (b - a) / (n - 1);\n  const vector = [];\n\n  while (n-- > 0) {\n    vector.push(a);\n    a += increment;\n  }\n\n  // Make sure the last item will always be \"b\" because most of the\n  // Time we'll get numbers like 1.0000000000000002 instead of 1.\n  vector[vector.length - 1] = b;\n\n  return vector;\n}\n\n/**\n * Returns the \"rank/index\" of the element in a sorted array if found or the highest index if not. Uses (binary search)\n * @param {Array} array A sorted array to search in\n * @param {any} elem the element in the array to search for\n * @returns {number} The rank/index of the element in the given array\n * @memberof Colors\n */\nfunction getRank(array, elem) {\n  let left = 0;\n  let right = array.length - 1;\n\n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2);\n    const midElem = array[mid];\n\n    if (midElem === elem) {\n      return mid;\n    } else if (elem < midElem) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  return left;\n}\n\n/**\n * Find the indices into a sorted array a such that, if the corresponding elements\n * In v were inserted before the indices, the order of a would be preserved.\n *  http://lagrange.univ-lyon1.fr/docs/numpy/1.11.0/reference/generated/numpy.searchsorted.html\n * @param {Array} inputArray The array where the values will be inserted\n * @param {Array} values An array of the values to be inserted into the inputArray\n * @returns {Array} The indices where elements should be inserted to maintain order.\n * @memberof Colors\n */\nfunction searchSorted(inputArray, values) {\n  let i;\n  const indexes = [];\n  const len = values.length;\n\n  inputArray.sort(function (a, b) {\n    return a - b;\n  });\n\n  for (i = 0; i < len; i++) {\n    indexes[i] = getRank(inputArray, values[i]);\n  }\n\n  return indexes;\n}\n\n/**\n * Creates an *N* -element 1-d lookup table\n * @param {Number} N The number of elements in the result lookup table\n * @param {Array} data represented by a list of x,y0,y1 mapping correspondences. Each element in this\n * List represents how a value between 0 and 1 (inclusive) represented by x is mapped to\n * A corresponding value between 0 and 1 (inclusive). The two values of y are to allow for\n * Discontinuous mapping functions (say as might be found in a sawtooth) where y0 represents\n * The value of y for values of x <= to that given, and y1 is the value to be used for x >\n * Than that given). The list must start with x=0, end with x=1, and all values of x must be\n * In increasing order. Values between the given mapping points are determined by simple linear\n * Interpolation.\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\n * at the bottom and top of the map.\n * @returns {any[]} an array \"result\" where result[x*(N-1)] gives the closest value for\n * Values of x between 0 and 1.\n * @memberof Colors\n */\nfunction makeMappingArray(N, data, gamma) {\n  let i;\n  const x = [];\n  const y0 = [];\n  const y1 = [];\n  const lut = [];\n\n  gamma = gamma === null ? 1 : gamma;\n\n  for (i = 0; i < data.length; i++) {\n    const element = data[i];\n\n    x.push((N - 1) * element[0]);\n    y0.push(element[1]);\n    y1.push(element[1]);\n  }\n\n  const xLinSpace = linspace(0, 1, N);\n\n  for (i = 0; i < N; i++) {\n    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);\n  }\n\n  const xLinSpaceIndexes = searchSorted(x, xLinSpace);\n\n  for (i = 1; i < N - 1; i++) {\n    const index = xLinSpaceIndexes[i];\n    const colorPercent =\n      (xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]);\n    const colorDelta = y0[index] - y1[index - 1];\n\n    lut[i] = colorPercent * colorDelta + y1[index - 1];\n  }\n\n  lut[0] = y1[0];\n  lut[N - 1] = y0[data.length - 1];\n\n  return lut;\n}\n\n/**\n * Creates a Colormap based on lookup tables using linear segments.\n * @param {{red:Array, green:Array, blue:Array}} segmentedData An object with a red, green and blue entries.\n * Each entry should be a list of x, y0, y1 tuples, forming rows in a table.\n * @param {Number} N The number of elements in the result Colormap\n * @param {any} gamma value denotes a \"gamma curve\" value which adjusts the brightness\n * at the bottom and top of the Colormap.\n * @returns {Array} The created Colormap object\n * @description The lookup table is generated using linear interpolation for each\n *  Primary color, with the 0-1 domain divided into any number of\n * Segments.\n * https://github.com/stefanv/matplotlib/blob/3f1a23755e86fef97d51e30e106195f34425c9e3/lib/matplotlib/colors.py#L663\n * @memberof Colors\n */\nfunction createLinearSegmentedColormap(segmentedData, N, gamma) {\n  let i;\n  const lut = [];\n\n  N = N === null ? 256 : N;\n  gamma = gamma === null ? 1 : gamma;\n\n  const redLut = makeMappingArray(N, segmentedData.red, gamma);\n  const greenLut = makeMappingArray(N, segmentedData.green, gamma);\n  const blueLut = makeMappingArray(N, segmentedData.blue, gamma);\n\n  for (i = 0; i < N; i++) {\n    const red = Math.round(redLut[i] * 255);\n    const green = Math.round(greenLut[i] * 255);\n    const blue = Math.round(blueLut[i] * 255);\n    const rgba = [red, green, blue, 255];\n\n    lut.push(rgba);\n  }\n\n  return lut;\n}\n\n/**\n * Return all available colormaps (id and name)\n * @returns {Array<{id,key}>} An array of colormaps with an object containing the \"id\" and display \"name\"\n * @memberof Colors\n */\nexport function getColormapsList() {\n  const colormaps = [];\n  const keys = Object.keys(CPU_COLORMAPS);\n\n  keys.forEach(function (key) {\n    if (CPU_COLORMAPS.hasOwnProperty(key)) {\n      const colormap = CPU_COLORMAPS[key];\n\n      colormaps.push({\n        id: key,\n        name: colormap.name,\n      });\n    }\n  });\n\n  colormaps.sort(function (a, b) {\n    const aName = a.name.toLowerCase();\n    const bName = b.name.toLowerCase();\n\n    if (aName === bName) {\n      return 0;\n    }\n\n    return aName < bName ? -1 : 1;\n  });\n\n  return colormaps;\n}\n\n/**\n * Return a colorMap object with the provided id and colormapData\n * if the Id matches existent colorMap objects (check colormapsData) the colormapData is ignored.\n * if the colormapData is not empty, the colorMap will be added to the colormapsData list. Otherwise, an empty colorMap object is returned.\n * @param {string} id The ID of the colormap\n * @param {Object} colormapData - An object that can contain a name, numColors, gama, segmentedData and/or colors\n * @returns {*} The Colormap Object\n * @memberof Colors\n */\nexport function getColormap(\n  id: string,\n  colormapData?: CPUFallbackColormapData\n): CPUFallbackColormap {\n  let colormap = CPU_COLORMAPS[id];\n\n  if (!colormap) {\n    colormap = CPU_COLORMAPS[id] = colormapData || {\n      name: '',\n      colors: [],\n    };\n  }\n\n  if (!colormap.colors && colormap.segmentedData) {\n    colormap.colors = createLinearSegmentedColormap(\n      colormap.segmentedData,\n      colormap.numColors,\n      colormap.gamma\n    );\n  }\n\n  const cpuFallbackColormap: CPUFallbackColormap = {\n    getId() {\n      return id;\n    },\n\n    getColorSchemeName() {\n      return colormap.name;\n    },\n\n    setColorSchemeName(name) {\n      colormap.name = name;\n    },\n\n    getNumberOfColors() {\n      return colormap.colors.length;\n    },\n\n    setNumberOfColors(numColors) {\n      while (colormap.colors.length < numColors) {\n        colormap.colors.push(COLOR_TRANSPARENT);\n      }\n\n      colormap.colors.length = numColors;\n    },\n\n    getColor(index) {\n      if (this.isValidIndex(index)) {\n        return colormap.colors[index];\n      }\n\n      return COLOR_TRANSPARENT;\n    },\n\n    getColorRepeating(index) {\n      const numColors = colormap.colors.length;\n\n      index = numColors ? index % numColors : 0;\n\n      return this.getColor(index);\n    },\n\n    setColor(index, rgba) {\n      if (this.isValidIndex(index)) {\n        colormap.colors[index] = rgba;\n      }\n    },\n\n    addColor(rgba) {\n      colormap.colors.push(rgba);\n    },\n\n    insertColor(index, rgba) {\n      if (this.isValidIndex(index)) {\n        colormap.colors.splice(index, 1, rgba);\n      }\n    },\n\n    removeColor(index) {\n      if (this.isValidIndex(index)) {\n        colormap.colors.splice(index, 1);\n      }\n    },\n\n    clearColors() {\n      colormap.colors = [];\n    },\n\n    buildLookupTable(lut) {\n      if (!lut) {\n        return;\n      }\n\n      const numColors = colormap.colors.length;\n\n      lut.setNumberOfTableValues(numColors);\n\n      for (let i = 0; i < numColors; i++) {\n        lut.setTableValue(i, colormap.colors[i]);\n      }\n    },\n\n    createLookupTable() {\n      const lut = new LookupTable();\n\n      this.buildLookupTable(lut);\n\n      return lut;\n    },\n\n    isValidIndex(index) {\n      return index >= 0 && index < colormap.colors.length;\n    },\n  };\n\n  return cpuFallbackColormap;\n}\n","/**\n * Use the performance.now() method if possible, and if not, use Date.now()\n *\n * @return {number} Time elapsed since the time origin\n * @memberof Polyfills\n */\nexport default function (): number {\n  if (window.performance) {\n    return performance.now();\n  }\n\n  return Date.now();\n}\n","/* eslint no-bitwise: 0 */\n\n/**\n * Volume of Interest Lookup Table Function\n *\n * @typedef {Function} VOILUTFunction\n *\n * @param {Number} modalityLutValue\n * @returns {Number} transformed value\n * @memberof Objects\n */\n\n/**\n * @module: VOILUT\n */\n\n/**\n * Generates the linear VOI LUT function.\n * From the DICOM standard:\n * https://dicom.nema.org/medical/dicom/current/output/html/part03.html#sect_C.11.2.1.2.1\n * ((x - (c - 0.5)) / (w-1) + 0.5) * (ymax- ymin) + ymin\n * clipped to the ymin...ymax range\n *\n * @param {Number} windowWidth Window Width\n * @param {Number} windowCenter Window Center\n * @returns {VOILUTFunction} VOI LUT mapping function\n * @memberof VOILUT\n */\nfunction generateLinearVOILUT(windowWidth: number, windowCenter: number) {\n  return function (modalityLutValue) {\n    const value =\n      ((modalityLutValue - (windowCenter - 0.5)) / (windowWidth - 1) + 0.5) *\n      255.0;\n    return Math.min(Math.max(value, 0), 255);\n  };\n}\n\n/**\n * Generate a non-linear volume of interest lookup table\n *\n * @param {LUT} voiLUT Volume of Interest Lookup Table Object\n *\n * @returns {VOILUTFunction} VOI LUT mapping function\n * @memberof VOILUT\n */\nfunction generateNonLinearVOILUT(voiLUT) {\n  // We don't trust the voiLUT.numBitsPerEntry, mainly thanks to Agfa!\n  const bitsPerEntry = Math.max(...voiLUT.lut).toString(2).length;\n  const shift = bitsPerEntry - 8;\n  const minValue = voiLUT.lut[0] >> shift;\n  const maxValue = voiLUT.lut[voiLUT.lut.length - 1] >> shift;\n  const maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;\n\n  return function (modalityLutValue) {\n    if (modalityLutValue < voiLUT.firstValueMapped) {\n      return minValue;\n    } else if (modalityLutValue >= maxValueMapped) {\n      return maxValue;\n    }\n\n    return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;\n  };\n}\n\n/**\n * Retrieve a VOI LUT mapping function given the current windowing settings\n * and the VOI LUT for the image\n *\n * @param {Number} windowWidth Window Width\n * @param {Number} windowCenter Window Center\n * @param {LUT} [voiLUT] Volume of Interest Lookup Table Object\n *\n * @return {VOILUTFunction} VOI LUT mapping function\n * @memberof VOILUT\n */\nexport default function (windowWidth: number, windowCenter: number, voiLUT) {\n  if (voiLUT) {\n    return generateNonLinearVOILUT(voiLUT);\n  }\n\n  return generateLinearVOILUT(windowWidth, windowCenter);\n}\n","import calculateTransform from './calculateTransform';\nimport { CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * Sets the canvas context transformation matrix to the pixel coordinate system.  This allows\n * geometry to be driven using the canvas context using coordinates in the pixel coordinate system\n * @param {EnabledElement} enabledElement The\n * @param {CanvasRenderingContext2D} context The CanvasRenderingContext2D for the enabledElement's Canvas\n * @param {Number} [scale] Optional scale to apply\n * @returns {void}\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  context: CanvasRenderingContext2D,\n  scale?: number\n): void {\n  if (enabledElement === undefined) {\n    throw new Error(\n      'setToPixelCoordinateSystem: parameter enabledElement must not be undefined'\n    );\n  }\n  if (context === undefined) {\n    throw new Error(\n      'setToPixelCoordinateSystem: parameter context must not be undefined'\n    );\n  }\n\n  const transform = calculateTransform(enabledElement, scale);\n  const m = transform.getMatrix();\n\n  context.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n}\n","import { CPUFallbackEnabledElement, IImage } from '../../../../types';\n\n/**\n * Determine whether or not an Enabled Element needs to be re-rendered.\n *\n * If the imageId has changed, or if any of the last rendered viewport\n * parameters have changed, this function will return true.\n *\n * @param enabledElement - An Enabled Element\n * @param image - An Image\n * @returns Whether - or not the Enabled Element needs to re-render its image\n */\nexport default function doesImageNeedToBeRendered(\n  enabledElement: CPUFallbackEnabledElement,\n  image: IImage\n): boolean {\n  const lastRenderedImageId = enabledElement.renderingTools.lastRenderedImageId;\n  const lastRenderedViewport =\n    enabledElement.renderingTools.lastRenderedViewport;\n\n  return (\n    image.imageId !== lastRenderedImageId ||\n    !lastRenderedViewport ||\n    lastRenderedViewport.windowCenter !==\n      enabledElement.viewport.voi.windowCenter ||\n    lastRenderedViewport.windowWidth !==\n      enabledElement.viewport.voi.windowWidth ||\n    lastRenderedViewport.invert !== enabledElement.viewport.invert ||\n    lastRenderedViewport.rotation !== enabledElement.viewport.rotation ||\n    lastRenderedViewport.hflip !== enabledElement.viewport.hflip ||\n    lastRenderedViewport.vflip !== enabledElement.viewport.vflip ||\n    lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT ||\n    lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT ||\n    lastRenderedViewport.colormap !== enabledElement.viewport.colormap\n  );\n}\n","import { CPUFallbackEnabledElement, IImage } from '../../../../types';\n\n/**\n * Sets size and clears canvas\n *\n * @param {Object} enabledElement Cornerstone Enabled Element\n * @param {Object} image Image to be rendered\n * @returns {void}\n * @memberof rendering\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  image: IImage\n): void {\n  const renderCanvas = enabledElement.renderingTools.renderCanvas;\n\n  // Resize the canvas\n  renderCanvas.width = image.width;\n  renderCanvas.height = image.height;\n\n  const canvasContext = renderCanvas.getContext('2d');\n\n  // NOTE - we need to fill the render canvas with white pixels since we\n  // control the luminance using the alpha channel to improve rendering performance.\n  canvasContext.fillStyle = 'white';\n  canvasContext.fillRect(0, 0, renderCanvas.width, renderCanvas.height);\n\n  const renderCanvasData = canvasContext.getImageData(\n    0,\n    0,\n    image.width,\n    image.height\n  );\n\n  enabledElement.renderingTools.renderCanvasContext = canvasContext;\n  enabledElement.renderingTools.renderCanvasData = renderCanvasData;\n}\n","import {\n  CPUFallbackEnabledElement,\n  CPUFallbackRenderingTools,\n} from '../../../../types';\n\n/**\n * Saves the parameters of the last render into renderingTools, used later to decide if data can be reused.\n *\n * @param {Object} enabledElement Cornerstone EnabledElement\n * @returns {Object} enabledElement.renderingTools\n * @memberof rendering\n */\n\nexport default function (\n  enabledElement: CPUFallbackEnabledElement\n): CPUFallbackRenderingTools {\n  const imageId = enabledElement.image.imageId;\n  const viewport = enabledElement.viewport;\n  const isColor = enabledElement.image.color;\n\n  enabledElement.renderingTools.lastRenderedImageId = imageId;\n  enabledElement.renderingTools.lastRenderedIsColor = isColor;\n  enabledElement.renderingTools.lastRenderedViewport = {\n    windowCenter: viewport.voi.windowCenter,\n    windowWidth: viewport.voi.windowWidth,\n    invert: viewport.invert,\n    rotation: viewport.rotation,\n    hflip: viewport.hflip,\n    vflip: viewport.vflip,\n    modalityLUT: viewport.modalityLUT,\n    voiLUT: viewport.voiLUT,\n    colormap: viewport.colormap,\n  };\n\n  return enabledElement.renderingTools;\n}\n","import now from './now';\nimport generateColorLUT from './generateColorLUT';\nimport storedColorPixelDataToCanvasImageData from './storedColorPixelDataToCanvasImageData';\nimport storedRGBAPixelDataToCanvasImageData from './storedRGBAPixelDataToCanvasImageData';\nimport setToPixelCoordinateSystem from './setToPixelCoordinateSystem';\nimport doesImageNeedToBeRendered from './doesImageNeedToBeRendered';\nimport initializeRenderCanvas from './initializeRenderCanvas';\nimport saveLastRendered from './saveLastRendered';\nimport {\n  IImage,\n  CPUFallbackViewport,\n  CPUFallbackEnabledElement,\n} from '../../../../types';\n\n/**\n * Generates an appropriate Look Up Table to render the given image with the given window width and level (specified in the viewport)\n * Uses an internal cache for performance\n *\n * @param {Object} image  The image to be rendered\n * @param {Object} viewport The viewport values used for rendering\n * @returns {Uint8ClampedArray} Look Up Table array.\n * @memberof rendering\n */\nfunction getLut(image: IImage, viewport: CPUFallbackViewport) {\n  // If we have a cached lut and it has the right values, return it immediately\n  if (\n    image.cachedLut !== undefined &&\n    image.cachedLut.windowCenter === viewport.voi.windowCenter &&\n    image.cachedLut.windowWidth === viewport.voi.windowWidth &&\n    image.cachedLut.invert === viewport.invert\n  ) {\n    return image.cachedLut.lutArray;\n  }\n\n  // Lut is invalid or not present, regenerate it and cache it\n  generateColorLUT(\n    image,\n    viewport.voi.windowWidth,\n    viewport.voi.windowCenter,\n    viewport.invert\n  );\n  image.cachedLut.windowWidth = viewport.voi.windowWidth;\n  image.cachedLut.windowCenter = viewport.voi.windowCenter;\n  image.cachedLut.invert = viewport.invert;\n\n  return image.cachedLut.lutArray;\n}\n\n/**\n * Returns an appropriate canvas to render the Image. If the canvas available in the cache is appropriate\n * it is returned, otherwise adjustments are made. It also sets the color transfer functions.\n *\n * @param enabledElement - The cornerstone enabled element\n * @param image - The image to be rendered\n * @param invalidated - Is pixel data valid\n * @returns An appropriate canvas for rendering the image\n * @memberof rendering\n */\nfunction getRenderCanvas(\n  enabledElement: CPUFallbackEnabledElement,\n  image: IImage,\n  invalidated: boolean\n): HTMLCanvasElement {\n  const canvasWasColor =\n    enabledElement.renderingTools.lastRenderedIsColor === true;\n\n  if (!enabledElement.renderingTools.renderCanvas || !canvasWasColor) {\n    enabledElement.renderingTools.renderCanvas =\n      document.createElement('canvas');\n  }\n\n  const renderCanvas = enabledElement.renderingTools.renderCanvas;\n\n  // The ww/wc is identity and not inverted - get a canvas with the image rendered into it for\n  // Fast drawing.  Note that this is 256/128, and NOT 255/127, per the DICOM\n  // standard, but allow either.\n  const { windowWidth, windowCenter } = enabledElement.viewport.voi;\n  if (\n    (windowWidth === 256 || windowWidth === 255) &&\n    (windowCenter === 128 || windowCenter === 127) &&\n    enabledElement.viewport.invert === false &&\n    image.getCanvas &&\n    image.getCanvas()\n  ) {\n    return image.getCanvas();\n  }\n\n  // Apply the lut to the stored pixel data onto the render canvas\n  if (\n    doesImageNeedToBeRendered(enabledElement, image) === false &&\n    invalidated !== true\n  ) {\n    return renderCanvas;\n  }\n\n  // If our render canvas does not match the size of this image reset it\n  // NOTE: This might be inefficient if we are updating multiple images of different\n  // Sizes frequently.\n  if (\n    renderCanvas.width !== image.width ||\n    renderCanvas.height !== image.height\n  ) {\n    initializeRenderCanvas(enabledElement, image);\n  }\n\n  // Get the lut to use\n  let start = now();\n  const colorLUT = getLut(image, enabledElement.viewport);\n\n  image.stats = image.stats || {};\n  image.stats.lastLutGenerateTime = now() - start;\n\n  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;\n  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;\n\n  // The color image voi/invert has been modified - apply the lut to the underlying\n  // Pixel data and put it into the renderCanvas\n  if (image.rgba) {\n    storedRGBAPixelDataToCanvasImageData(\n      image,\n      colorLUT,\n      renderCanvasData.data\n    );\n  } else {\n    storedColorPixelDataToCanvasImageData(\n      image,\n      colorLUT,\n      renderCanvasData.data\n    );\n  }\n\n  start = now();\n  renderCanvasContext.putImageData(renderCanvasData, 0, 0);\n  image.stats.lastPutImageDataTime = now() - start;\n\n  return renderCanvas;\n}\n\n/**\n * API function to render a color image to an enabled element\n *\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw\n * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used\n * @returns {void}\n * @memberof rendering\n */\nexport function renderColorImage(\n  enabledElement: CPUFallbackEnabledElement,\n  invalidated: boolean\n): void {\n  if (enabledElement === undefined) {\n    throw new Error(\n      'renderColorImage: enabledElement parameter must not be undefined'\n    );\n  }\n\n  const image = enabledElement.image;\n\n  if (image === undefined) {\n    throw new Error(\n      'renderColorImage: image must be loaded before it can be drawn'\n    );\n  }\n\n  // Get the canvas context and reset the transform\n  const context = enabledElement.canvas.getContext('2d');\n\n  context.setTransform(1, 0, 0, 1, 0, 0);\n\n  // Clear the canvas\n  context.fillStyle = 'black';\n  context.fillRect(\n    0,\n    0,\n    enabledElement.canvas.width,\n    enabledElement.canvas.height\n  );\n\n  // Turn off image smooth/interpolation if pixelReplication is set in the viewport\n  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;\n\n  // Save the canvas context state and apply the viewport properties\n  setToPixelCoordinateSystem(enabledElement, context);\n\n  const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);\n\n  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;\n  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;\n  const width = enabledElement.viewport.displayedArea.brhc.x - sx;\n  const height = enabledElement.viewport.displayedArea.brhc.y - sy;\n\n  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);\n\n  enabledElement.renderingTools = saveLastRendered(enabledElement);\n}\n","import getVOILUT from './getVOILut';\nimport { IImage, CPUFallbackLUT } from '../../../../types';\n\n/**\n * Creates a LUT used while rendering to convert stored pixel values to\n * display pixels\n *\n * @param image - A Cornerstone Image Object\n * @param windowWidth - The Window Width\n * @param windowCenter - The Window Center\n * @param invert - A boolean describing whether or not the image has been inverted\n * @param voiLUT- A Volume of Interest Lookup Table\n *\n * @returns A lookup table to apply to the image\n */\nexport default function generateColorLUT(\n  image: IImage,\n  windowWidth: number | number[],\n  windowCenter: number | number[],\n  invert: boolean,\n  voiLUT?: CPUFallbackLUT\n) {\n  const maxPixelValue = image.maxPixelValue;\n  const minPixelValue = image.minPixelValue;\n  const offset = Math.min(minPixelValue, 0);\n\n  if (image.cachedLut === undefined) {\n    const length = maxPixelValue - offset + 1;\n\n    image.cachedLut = {};\n    image.cachedLut.lutArray = new Uint8ClampedArray(length);\n  }\n\n  const lut = image.cachedLut.lutArray;\n  const vlutfn = getVOILUT(\n    Array.isArray(windowWidth) ? windowWidth[0] : windowWidth,\n    Array.isArray(windowCenter) ? windowCenter[0] : windowCenter,\n    voiLUT\n  );\n\n  if (invert === true) {\n    for (\n      let storedValue = minPixelValue;\n      storedValue <= maxPixelValue;\n      storedValue++\n    ) {\n      lut[storedValue + -offset] = 255 - vlutfn(storedValue);\n    }\n  } else {\n    for (\n      let storedValue = minPixelValue;\n      storedValue <= maxPixelValue;\n      storedValue++\n    ) {\n      lut[storedValue + -offset] = vlutfn(storedValue);\n    }\n  }\n\n  return lut;\n}\n","import now from './now';\nimport { IImage } from '../../../../types';\n\n/**\n * Converts stored RGBA color pixel values to display pixel values using a LUT.\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} lut Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  lut: Uint8ClampedArray,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  const numPixels = pixelData.length;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n  start = now();\n  if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Red\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Green\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Blue\n      canvasImageDataData[canvasImageDataIndex++] =\n        pixelData[storedPixelDataIndex++];\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++]]; // Red\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++]]; // Green\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++]]; // Blue\n      canvasImageDataData[canvasImageDataIndex++] =\n        pixelData[storedPixelDataIndex++];\n    }\n  }\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n","import now from './now';\nimport { IImage } from '../../../../types';\n\n/**\n * Converts stored color pixel values to display pixel values using a LUT.\n *\n * Note: Skips alpha value for any input image pixel data.\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} lut Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  lut: Uint8ClampedArray,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  const numPixels = pixelData.length;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n  start = now();\n  if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Red\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Green\n      canvasImageDataData[canvasImageDataIndex] =\n        lut[pixelData[storedPixelDataIndex] + -minPixelValue]; // Blue\n      storedPixelDataIndex += 2;\n      canvasImageDataIndex += 2;\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++]]; // Red\n      canvasImageDataData[canvasImageDataIndex++] =\n        lut[pixelData[storedPixelDataIndex++]]; // Green\n      canvasImageDataData[canvasImageDataIndex] =\n        lut[pixelData[storedPixelDataIndex]]; // Blue\n      storedPixelDataIndex += 2;\n      canvasImageDataIndex += 2;\n    }\n  }\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n","import type { IImage, CPUFallbackViewport } from '../../../../types';\n\n/**\n * Computes the VOI to display all the pixels if no VOI LUT data (Window Width/Window Center or voiLUT) exists on the viewport object.\n *\n * @param viewport - Object containing the viewport properties\n * @param image - An Image loaded by a Cornerstone Image Loader\n */\nexport default function computeAutoVoi(\n  viewport: CPUFallbackViewport,\n  image: IImage\n): void {\n  if (hasVoi(viewport)) {\n    return;\n  }\n\n  const maxVoi = image.maxPixelValue * image.slope + image.intercept;\n  const minVoi = image.minPixelValue * image.slope + image.intercept;\n  const ww = maxVoi - minVoi;\n  const wc = (maxVoi + minVoi) / 2;\n\n  if (viewport.voi === undefined) {\n    viewport.voi = {\n      windowWidth: ww,\n      windowCenter: wc,\n    };\n  } else {\n    viewport.voi.windowWidth = ww;\n    viewport.voi.windowCenter = wc;\n  }\n}\n\n/**\n * Check if viewport has voi LUT data\n * @param viewport - The viewport to check for voi LUT data\n * @returns true viewport has LUT data (Window Width/Window Center or voiLUT). Otherwise, false.\n */\nfunction hasVoi(viewport: CPUFallbackViewport): boolean {\n  const hasLut =\n    viewport.voiLUT && viewport.voiLUT.lut && viewport.voiLUT.lut.length > 0;\n\n  return (\n    hasLut ||\n    (viewport.voi.windowWidth !== undefined &&\n      viewport.voi.windowCenter !== undefined)\n  );\n}\n","/**\n * Check if two lookup tables match\n *\n * @param {LUT} a A lookup table function\n * @param {LUT} b Another lookup table function\n * @return {boolean} Whether or not they match\n * @memberof rendering\n */\nexport default function (a: any, b: any) {\n  // If undefined, they are equal\n  if (!a && !b) {\n    return true;\n  }\n  // If one is undefined, not equal\n  if (!a || !b) {\n    return false;\n  }\n\n  // Check the unique ids\n  return a.id === b.id;\n}\n","import computeAutoVoi from './computeAutoVoi';\nimport lutMatches from './lutMatches';\nimport generateLut from './generateLut';\nimport { IImage, CPUFallbackViewport } from '../../../../types';\n\n/**\n * Retrieve or generate a LUT Array for an Image and Viewport\n *\n * @param {Image} image An Image Object\n * @param {Viewport} viewport An Viewport Object\n * @param {Boolean} invalidated Whether or not the LUT data has been invalidated\n * (e.g. by a change to the windowWidth, windowCenter, or invert viewport parameters).\n * @return {Uint8ClampedArray} LUT Array\n * @memberof rendering\n */\nexport default function (\n  image: IImage,\n  viewport: CPUFallbackViewport,\n  invalidated: boolean\n): Uint8ClampedArray {\n  // If we have a cached lut and it has the right values, return it immediately\n  if (\n    image.cachedLut !== undefined &&\n    image.cachedLut.windowCenter === viewport.voi.windowCenter &&\n    image.cachedLut.windowWidth === viewport.voi.windowWidth &&\n    lutMatches(image.cachedLut.modalityLUT, viewport.modalityLUT) &&\n    lutMatches(image.cachedLut.voiLUT, viewport.voiLUT) &&\n    image.cachedLut.invert === viewport.invert &&\n    invalidated !== true\n  ) {\n    return image.cachedLut.lutArray;\n  }\n\n  computeAutoVoi(viewport, image);\n\n  // Lut is invalid or not present, regenerate it and cache it\n  generateLut(\n    image,\n    viewport.voi.windowWidth,\n    viewport.voi.windowCenter,\n    viewport.invert,\n    viewport.modalityLUT,\n    viewport.voiLUT\n  );\n\n  image.cachedLut.windowWidth = viewport.voi.windowWidth;\n  image.cachedLut.windowCenter = viewport.voi.windowCenter;\n  image.cachedLut.invert = viewport.invert;\n  image.cachedLut.voiLUT = viewport.voiLUT;\n  image.cachedLut.modalityLUT = viewport.modalityLUT;\n\n  return image.cachedLut.lutArray;\n}\n","import getModalityLut from './getModalityLut';\nimport getVOILUT from './getVOILut';\nimport { IImage, CPUFallbackLUT } from '../../../../types';\n\n/**\n * Creates a LUT used while rendering to convert stored pixel values to\n * display pixels\n *\n * @param image - A Cornerstone Image Object\n * @param windowWidth - The Window Width\n * @param windowCenter - The Window Center\n * @param invert - A boolean describing whether or not the image has been inverted\n * @param modalityLUT - A modality Lookup Table\n * @param voiLUT - A Volume of Interest Lookup Table\n *\n * @returns A lookup table to apply to the image\n */\nexport default function (\n  image: IImage,\n  windowWidth: number,\n  windowCenter: number,\n  invert: boolean,\n  modalityLUT: CPUFallbackLUT,\n  voiLUT: CPUFallbackLUT\n): Uint8ClampedArray {\n  const maxPixelValue = image.maxPixelValue;\n  const minPixelValue = image.minPixelValue;\n  const offset = Math.min(minPixelValue, 0);\n\n  if (image.cachedLut === undefined) {\n    const length = maxPixelValue - offset + 1;\n\n    image.cachedLut = {};\n    image.cachedLut.lutArray = new Uint8ClampedArray(length);\n  }\n\n  const lut = image.cachedLut.lutArray;\n\n  const mlutfn = getModalityLut(image.slope, image.intercept, modalityLUT);\n  const vlutfn = getVOILUT(windowWidth, windowCenter, voiLUT);\n\n  if (image.isPreScaled) {\n    // if the image is already preScaled, it means that the slop and the intercept\n    // are applied and there is no need for a modalityLut\n    if (invert === true) {\n      for (\n        let storedValue = minPixelValue;\n        storedValue <= maxPixelValue;\n        storedValue++\n      ) {\n        lut[storedValue + -offset] = 255 - vlutfn(storedValue);\n      }\n    } else {\n      for (\n        let storedValue = minPixelValue;\n        storedValue <= maxPixelValue;\n        storedValue++\n      ) {\n        lut[storedValue + -offset] = vlutfn(storedValue);\n      }\n    }\n  } else {\n    if (invert === true) {\n      for (\n        let storedValue = minPixelValue;\n        storedValue <= maxPixelValue;\n        storedValue++\n      ) {\n        lut[storedValue + -offset] = 255 - vlutfn(mlutfn(storedValue));\n      }\n    } else {\n      for (\n        let storedValue = minPixelValue;\n        storedValue <= maxPixelValue;\n        storedValue++\n      ) {\n        lut[storedValue + -offset] = vlutfn(mlutfn(storedValue));\n      }\n    }\n  }\n\n  return lut;\n}\n","/**\n * Generates a linear modality transformation function\n *\n * See DICOM PS3.3 C.11.1 Modality LUT Module\n *\n * http://dicom.nema.org/medical/Dicom/current/output/chtml/part03/sect_C.11.html\n *\n * @param {Number} slope m in the equation specified by Rescale Intercept (0028,1052).\n * @param {Number} intercept The value b in relationship between stored values (SV) and the output units specified in Rescale Type (0028,1054).\n\n Output units = m*SV + b.\n * @return {function(*): *} A linear modality LUT function. Given a stored pixel it returns the modality pixel value\n * @memberof Internal\n */\nfunction generateLinearModalityLUT(slope, intercept) {\n  return (storedPixelValue) => storedPixelValue * slope + intercept;\n}\n\nfunction generateNonLinearModalityLUT(modalityLUT) {\n  const minValue = modalityLUT.lut[0];\n  const maxValue = modalityLUT.lut[modalityLUT.lut.length - 1];\n  const maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;\n\n  return (storedPixelValue) => {\n    if (storedPixelValue < modalityLUT.firstValueMapped) {\n      return minValue;\n    } else if (storedPixelValue >= maxValueMapped) {\n      return maxValue;\n    }\n\n    return modalityLUT.lut[storedPixelValue];\n  };\n}\n\n/**\n * Get the appropriate Modality LUT for the current situation.\n *\n * @param {Number} [slope] m in the equation specified by Rescale Intercept (0028,1052).\n * @param {Number} [intercept] The value b in relationship between stored values (SV) and the output units specified in Rescale Type (0028,1054).\n * @param {Function} [modalityLUT] A modality LUT function. Given a stored pixel it returns the modality pixel value.\n *\n * @return {function(*): *} A modality LUT function. Given a stored pixel it returns the modality pixel value.\n * @memberof Internal\n */\nexport default function (\n  slope: number,\n  intercept: number,\n  modalityLUT: unknown\n) {\n  if (modalityLUT) {\n    return generateNonLinearModalityLUT(modalityLUT);\n  }\n\n  return generateLinearModalityLUT(slope, intercept);\n}\n","import storedPixelDataToCanvasImageData from './storedPixelDataToCanvasImageData';\nimport storedPixelDataToCanvasImageDataPET from './storedPixelDataToCanvasImageDataPET';\nimport storedPixelDataToCanvasImageDataRGBA from './storedPixelDataToCanvasImageDataRGBA';\nimport setToPixelCoordinateSystem from './setToPixelCoordinateSystem';\nimport now from './now';\nimport getLut from './getLut';\nimport doesImageNeedToBeRendered from './doesImageNeedToBeRendered';\nimport initializeRenderCanvas from './initializeRenderCanvas';\nimport saveLastRendered from './saveLastRendered';\nimport { IImage, CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * Returns an appropriate canvas to render the Image. If the canvas available in the cache is appropriate\n * it is returned, otherwise adjustments are made. It also sets the color transfer functions.\n *\n * @param {Object} enabledElement The cornerstone enabled element\n * @param {Object} image The image to be rendered\n * @param {Boolean} invalidated Is pixel data valid\n * @param {Boolean} [useAlphaChannel = true] Will an alpha channel be used\n * @returns {HTMLCanvasElement} An appropriate canvas for rendering the image\n * @memberof rendering\n */\nfunction getRenderCanvas(\n  enabledElement: CPUFallbackEnabledElement,\n  image: IImage,\n  invalidated: boolean,\n  useAlphaChannel = true\n): HTMLCanvasElement {\n  const canvasWasColor =\n    enabledElement.renderingTools.lastRenderedIsColor === true;\n\n  if (!enabledElement.renderingTools.renderCanvas || canvasWasColor) {\n    enabledElement.renderingTools.renderCanvas =\n      document.createElement('canvas');\n    initializeRenderCanvas(enabledElement, image);\n  }\n\n  const renderCanvas = enabledElement.renderingTools.renderCanvas;\n\n  if (\n    doesImageNeedToBeRendered(enabledElement, image) === false &&\n    invalidated !== true\n  ) {\n    return renderCanvas;\n  }\n\n  // If our render canvas does not match the size of this image reset it\n  // NOTE: This might be inefficient if we are updating multiple images of different\n  // Sizes frequently.\n  if (\n    renderCanvas.width !== image.width ||\n    renderCanvas.height !== image.height\n  ) {\n    initializeRenderCanvas(enabledElement, image);\n  }\n\n  image.stats = image.stats || {};\n\n  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;\n  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;\n\n  let start = now();\n  image.stats.lastLutGenerateTime = now() - start;\n\n  const { viewport } = enabledElement;\n\n  // If modality is 'PT' and the image is scaled then the results are floating points,\n  // and we cannot create a lut for it (cannot have float indices). Therefore,\n  // we use a mapping function to get the voiLUT from the values by applying\n  // the windowLevel and windowWidth.\n  if (viewport.modality === 'PT' && image.isPreScaled) {\n    const { windowWidth, windowCenter } = viewport.voi;\n    const minimum = windowCenter - windowWidth / 2;\n    const maximum = windowCenter + windowWidth / 2;\n    const range = maximum - minimum;\n    const collectedMultiplierTerms = 255.0 / range;\n\n    let petVOILutFunction;\n\n    if (viewport.invert) {\n      petVOILutFunction = (value) =>\n        255 - (value - minimum) * collectedMultiplierTerms;\n    } else {\n      // Note, don't need to math.floor, that is dealt with by setting the value in the Uint8Array.\n      petVOILutFunction = (value) =>\n        (value - minimum) * collectedMultiplierTerms;\n    }\n\n    storedPixelDataToCanvasImageDataPET(\n      image,\n      petVOILutFunction,\n      renderCanvasData.data\n    );\n  } else {\n    // Get the lut to use\n    const lut = getLut(image, viewport, invalidated);\n\n    if (useAlphaChannel) {\n      storedPixelDataToCanvasImageData(image, lut, renderCanvasData.data);\n    } else {\n      storedPixelDataToCanvasImageDataRGBA(image, lut, renderCanvasData.data);\n    }\n  }\n\n  start = now();\n  renderCanvasContext.putImageData(renderCanvasData, 0, 0);\n  image.stats.lastPutImageDataTime = now() - start;\n\n  return renderCanvas;\n}\n\n/**\n * API function to draw a grayscale image to a given enabledElement\n *\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw\n * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used\n * @returns {void}\n * @memberof rendering\n */\nexport function renderGrayscaleImage(\n  enabledElement: CPUFallbackEnabledElement,\n  invalidated: boolean\n): void {\n  if (enabledElement === undefined) {\n    throw new Error(\n      'drawImage: enabledElement parameter must not be undefined'\n    );\n  }\n\n  const image = enabledElement.image;\n\n  if (image === undefined) {\n    throw new Error('drawImage: image must be loaded before it can be drawn');\n  }\n\n  // Get the canvas context and reset the transform\n  const context = enabledElement.canvas.getContext('2d');\n\n  context.setTransform(1, 0, 0, 1, 0, 0);\n\n  // Clear the canvas\n  context.fillStyle = 'black';\n  context.fillRect(\n    0,\n    0,\n    enabledElement.canvas.width,\n    enabledElement.canvas.height\n  );\n\n  // Turn off image smooth/interpolation if pixelReplication is set in the viewport\n  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;\n\n  // Save the canvas context state and apply the viewport properties\n  setToPixelCoordinateSystem(enabledElement, context);\n\n  const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);\n\n  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;\n  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;\n  const width = enabledElement.viewport.displayedArea.brhc.x - sx;\n  const height = enabledElement.viewport.displayedArea.brhc.y - sy;\n\n  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);\n\n  enabledElement.renderingTools = saveLastRendered(enabledElement);\n}\n","import now from './now';\nimport { IImage } from '../../../../types';\n\n/**\n * This function transforms stored pixel values into a canvas image data buffer\n * by using a LUT.  This is the most performance sensitive code in cornerstone and\n * we use a special trick to make this go as fast as possible.  Specifically we\n * use the alpha channel only to control the luminance rather than the red, green and\n * blue channels which makes it over 3x faster. The canvasImageDataData buffer needs\n * to be previously filled with white pixels.\n *\n * NOTE: Attribution would be appreciated if you use this technique!\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} lut Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  lutFunction: (value: number) => number,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const numPixels = pixelData.length;\n  // const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 3;\n  let storedPixelDataIndex = 0;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n\n  // Added two paths (Int16Array, Uint16Array) to avoid polymorphic deoptimization in chrome.\n  start = now();\n\n  while (storedPixelDataIndex < numPixels) {\n    canvasImageDataData[canvasImageDataIndex] = lutFunction(\n      pixelData[storedPixelDataIndex++]\n    ); // Alpha\n    canvasImageDataIndex += 4;\n  }\n\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n","import now from './now';\nimport { IImage } from '../../../../types';\n\n/**\n * This function transforms stored pixel values into a canvas image data buffer\n * by using a LUT.  This is the most performance sensitive code in cornerstone and\n * we use a special trick to make this go as fast as possible.  Specifically we\n * use the alpha channel only to control the luminance rather than the red, green and\n * blue channels which makes it over 3x faster. The canvasImageDataData buffer needs\n * to be previously filled with white pixels.\n *\n * NOTE: Attribution would be appreciated if you use this technique!\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} lut Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  lut: Uint8ClampedArray,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const numPixels = pixelData.length;\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 3;\n  let storedPixelDataIndex = 0;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n\n  // Added two paths (Int16Array, Uint16Array) to avoid polymorphic deoptimization in chrome.\n  start = now();\n  if (pixelData instanceof Int16Array) {\n    if (minPixelValue < 0) {\n      while (storedPixelDataIndex < numPixels) {\n        canvasImageDataData[canvasImageDataIndex] =\n          lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Alpha\n        canvasImageDataIndex += 4;\n      }\n    } else {\n      while (storedPixelDataIndex < numPixels) {\n        canvasImageDataData[canvasImageDataIndex] =\n          lut[pixelData[storedPixelDataIndex++]]; // Alpha\n        canvasImageDataIndex += 4;\n      }\n    }\n  } else if (pixelData instanceof Uint16Array) {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex] =\n        lut[pixelData[storedPixelDataIndex++]]; // Alpha\n      canvasImageDataIndex += 4;\n    }\n  } else if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex] =\n        lut[pixelData[storedPixelDataIndex++] + -minPixelValue]; // Alpha\n      canvasImageDataIndex += 4;\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      canvasImageDataData[canvasImageDataIndex] =\n        lut[pixelData[storedPixelDataIndex++]]; // Alpha\n      canvasImageDataIndex += 4;\n    }\n  }\n\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n","import now from './now';\nimport { IImage } from '../../../../types';\n\n/**\n * This function transforms stored pixel values into a canvas image data buffer\n * by using a LUT.\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} lut Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  lut: Uint8ClampedArray,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const numPixels = pixelData.length;\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  let pixelValue;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n\n  // Added two paths (Int16Array, Uint16Array) to avoid polymorphic deoptimization in chrome.\n  start = now();\n  if (pixelData instanceof Int16Array) {\n    if (minPixelValue < 0) {\n      while (storedPixelDataIndex < numPixels) {\n        pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha\n      }\n    } else {\n      while (storedPixelDataIndex < numPixels) {\n        pixelValue = lut[pixelData[storedPixelDataIndex++]];\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n        canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha\n      }\n    }\n  } else if (pixelData instanceof Uint16Array) {\n    while (storedPixelDataIndex < numPixels) {\n      pixelValue = lut[pixelData[storedPixelDataIndex++]];\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha\n    }\n  } else if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      pixelValue = lut[pixelData[storedPixelDataIndex++] + -minPixelValue];\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      pixelValue = lut[pixelData[storedPixelDataIndex++]];\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = pixelValue;\n      canvasImageDataData[canvasImageDataIndex++] = 255; // Alpha\n    }\n  }\n\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n","import * as colors from '../colors/index';\nimport now from './now';\nimport type { IImage, CPUFallbackLookupTable } from '../../../../types';\n\n/**\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} grayscaleLut Lookup table array\n * @param {LookupTable|Array} colorLUT Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nfunction storedPixelDataToCanvasImageDataPseudocolorLUT(\n  image: IImage,\n  grayscaleLut: Uint8ClampedArray,\n  colorLUT: CPUFallbackLookupTable,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const numPixels = pixelData.length;\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  let grayscale;\n  let rgba;\n  let clut;\n\n  start = now();\n\n  if (colorLUT instanceof colors.LookupTable) {\n    clut = colorLUT.Table;\n  } else {\n    clut = colorLUT;\n  }\n\n  if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      grayscale =\n        grayscaleLut[pixelData[storedPixelDataIndex++] + -minPixelValue];\n      rgba = clut[grayscale];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[0];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[1];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[2];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[3];\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      grayscale = grayscaleLut[pixelData[storedPixelDataIndex++]];\n      rgba = clut[grayscale];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[0];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[1];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[2];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[3];\n    }\n  }\n\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n\nexport default storedPixelDataToCanvasImageDataPseudocolorLUT;\n","import * as colors from '../colors/index';\nimport now from './now';\nimport type { IImage, CPUFallbackLookupTable } from '../../../../types';\n\n/**\n *\n * @param {Image} image A Cornerstone Image Object\n * @param {Array} grayscaleLut Lookup table array\n * @param {LookupTable|Array} colorLUT Lookup table array\n * @param {Uint8ClampedArray} canvasImageDataData canvasImageData.data buffer filled with white pixels\n *\n * @returns {void}\n * @memberof Internal\n */\nfunction storedPixelDataToCanvasImageDataPseudocolorLUTPET(\n  image: IImage,\n  lutFunction: (value: number) => number,\n  colorLUT: CPUFallbackLookupTable,\n  canvasImageDataData: Uint8ClampedArray\n): void {\n  let start = now();\n  const pixelData = image.getPixelData();\n\n  image.stats.lastGetPixelDataTime = now() - start;\n\n  const numPixels = pixelData.length;\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  let grayscale;\n  let rgba;\n  let clut;\n\n  start = now();\n\n  if (colorLUT instanceof colors.LookupTable) {\n    clut = colorLUT.Table;\n  } else {\n    clut = colorLUT;\n  }\n\n  if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numPixels) {\n      grayscale = lutFunction(\n        pixelData[storedPixelDataIndex++] + -minPixelValue\n      );\n\n      rgba = clut[grayscale];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[0];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[1];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[2];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[3];\n    }\n  } else {\n    while (storedPixelDataIndex < numPixels) {\n      grayscale = lutFunction(pixelData[storedPixelDataIndex++]);\n      rgba = clut[grayscale];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[0];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[1];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[2];\n      canvasImageDataData[canvasImageDataIndex++] = rgba[3];\n    }\n  }\n\n  image.stats.lastStoredPixelDataToCanvasImageDataTime = now() - start;\n}\n\nexport default storedPixelDataToCanvasImageDataPseudocolorLUTPET;\n","import setToPixelCoordinateSystem from './setToPixelCoordinateSystem';\nimport now from './now';\nimport initializeRenderCanvas from './initializeRenderCanvas';\nimport getLut from './getLut';\nimport saveLastRendered from './saveLastRendered';\nimport doesImageNeedToBeRendered from './doesImageNeedToBeRendered';\nimport storedPixelDataToCanvasImageDataPseudocolorLUT from './storedPixelDataToCanvasImageDataPseudocolorLUT';\nimport storedPixelDataToCanvasImageDataPseudocolorLUTPET from './storedPixelDataToCanvasImageDataPseudocolorLUTPET';\nimport * as colors from '../colors/index';\nimport type { IImage, CPUFallbackEnabledElement } from '../../../../types';\nimport { clamp } from '../../../../utilities';\n\n/**\n * Returns an appropriate canvas to render the Image. If the canvas available in the cache is appropriate\n * it is returned, otherwise adjustments are made. It also sets the color transfer functions.\n *\n * @param {Object} enabledElement The cornerstone enabled element\n * @param {Object} image The image to be rendered\n * @param {Boolean} invalidated Is pixel data valid\n * @returns {HTMLCanvasElement} An appropriate canvas for rendering the image\n * @memberof rendering\n */\nfunction getRenderCanvas(\n  enabledElement: CPUFallbackEnabledElement,\n  image: IImage,\n  invalidated: boolean\n): HTMLCanvasElement {\n  if (!enabledElement.renderingTools.renderCanvas) {\n    enabledElement.renderingTools.renderCanvas =\n      document.createElement('canvas');\n  }\n\n  const renderCanvas = enabledElement.renderingTools.renderCanvas;\n\n  let colormap =\n    enabledElement.viewport.colormap || enabledElement.options.colormap;\n\n  if (enabledElement.options && enabledElement.options.colormap) {\n    console.warn(\n      'enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead'\n    );\n  }\n  if (colormap && typeof colormap === 'string') {\n    colormap = colors.getColormap(colormap);\n  }\n\n  if (!colormap) {\n    throw new Error('renderPseudoColorImage: colormap not found.');\n  }\n\n  const colormapId = colormap.getId();\n\n  if (\n    doesImageNeedToBeRendered(enabledElement, image) === false &&\n    invalidated !== true &&\n    enabledElement.renderingTools.colormapId === colormapId\n  ) {\n    return renderCanvas;\n  }\n\n  // If our render canvas does not match the size of this image reset it\n  // NOTE: This might be inefficient if we are updating multiple images of different\n  // Sizes frequently.\n  if (\n    renderCanvas.width !== image.width ||\n    renderCanvas.height !== image.height\n  ) {\n    initializeRenderCanvas(enabledElement, image);\n  }\n\n  // Get the lut to use\n  let start = now();\n\n  if (\n    !enabledElement.renderingTools.colorLUT ||\n    invalidated ||\n    enabledElement.renderingTools.colormapId !== colormapId\n  ) {\n    colormap.setNumberOfColors(256);\n    enabledElement.renderingTools.colorLUT = colormap.createLookupTable();\n    enabledElement.renderingTools.colormapId = colormapId;\n  }\n\n  const renderCanvasData = enabledElement.renderingTools.renderCanvasData;\n  const renderCanvasContext = enabledElement.renderingTools.renderCanvasContext;\n  const { viewport } = enabledElement;\n  const colorLUT = enabledElement.renderingTools.colorLUT;\n\n  if (viewport.modality === 'PT') {\n    const { windowWidth, windowCenter } = viewport.voi;\n    const minimum = windowCenter - windowWidth / 2;\n    const maximum = windowCenter + windowWidth / 2;\n    const range = maximum - minimum;\n    const collectedMultiplierTerms = 255.0 / range;\n\n    let petVOILutFunction;\n\n    if (viewport.invert) {\n      petVOILutFunction = (value) => {\n        return clamp(\n          Math.floor(255 - (value - minimum) * collectedMultiplierTerms),\n          0,\n          255\n        );\n      };\n    } else {\n      petVOILutFunction = (value) => {\n        return clamp(\n          Math.floor((value - minimum) * collectedMultiplierTerms),\n          0,\n          255\n        );\n      };\n    }\n\n    storedPixelDataToCanvasImageDataPseudocolorLUTPET(\n      image,\n      petVOILutFunction,\n      colorLUT,\n      renderCanvasData.data\n    );\n  } else {\n    const lut = getLut(image, enabledElement.viewport, invalidated);\n\n    image.stats = image.stats || {};\n    image.stats.lastLutGenerateTime = now() - start;\n\n    storedPixelDataToCanvasImageDataPseudocolorLUT(\n      image,\n      lut,\n      colorLUT,\n      renderCanvasData.data\n    );\n  }\n\n  start = now();\n  renderCanvasContext.putImageData(renderCanvasData, 0, 0);\n  image.stats.lastPutImageDataTime = now() - start;\n\n  return renderCanvas;\n}\n\n/**\n * API function to draw a pseudo-color image to a given enabledElement\n *\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element to redraw\n * @param {Boolean} invalidated - true if pixel data has been invalidated and cached rendering should not be used\n * @returns {void}\n * @memberof rendering\n */\nexport function renderPseudoColorImage(\n  enabledElement: CPUFallbackEnabledElement,\n  invalidated: boolean\n): void {\n  if (enabledElement === undefined) {\n    throw new Error(\n      'drawImage: enabledElement parameter must not be undefined'\n    );\n  }\n\n  const image = enabledElement.image;\n\n  if (image === undefined) {\n    throw new Error('drawImage: image must be loaded before it can be drawn');\n  }\n\n  // Get the canvas context and reset the transform\n  const context = enabledElement.canvas.getContext('2d');\n\n  context.setTransform(1, 0, 0, 1, 0, 0);\n\n  // Clear the canvas\n  context.fillStyle = 'black';\n  context.fillRect(\n    0,\n    0,\n    enabledElement.canvas.width,\n    enabledElement.canvas.height\n  );\n\n  // Turn off image smooth/interpolation if pixelReplication is set in the viewport\n  context.imageSmoothingEnabled = !enabledElement.viewport.pixelReplication;\n\n  // Save the canvas context state and apply the viewport properties\n  setToPixelCoordinateSystem(enabledElement, context);\n\n  // If no options are set we will retrieve the renderCanvas through the\n  // Normal Canvas rendering path\n  // TODO: Add WebGL support for pseudocolor pipeline\n  const renderCanvas = getRenderCanvas(enabledElement, image, invalidated);\n\n  const sx = enabledElement.viewport.displayedArea.tlhc.x - 1;\n  const sy = enabledElement.viewport.displayedArea.tlhc.y - 1;\n  const width = enabledElement.viewport.displayedArea.brhc.x - sx;\n  const height = enabledElement.viewport.displayedArea.brhc.y - sy;\n\n  context.drawImage(renderCanvas, sx, sy, width, height, 0, 0, width, height);\n\n  enabledElement.renderingTools = saveLastRendered(enabledElement);\n}\n","import now from './rendering/now';\nimport { renderColorImage } from './rendering/renderColorImage';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\nimport { CPUFallbackEnabledElement } from '../../../types';\n\n/**\n * Draw an image to a given enabled element synchronously\n *\n * @param enabledElement - An enabled element to draw into\n * @param invalidated - true if pixel data has been invalidated and cached rendering should not be used\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  invalidated: boolean\n): void {\n  const image = enabledElement.image;\n\n  // Check if enabledElement can be redrawn\n  if (!enabledElement.canvas || !enabledElement.image) {\n    return;\n  }\n\n  // Start measuring the time needed to draw the image.\n  const start = now();\n\n  image.stats = {\n    lastGetPixelDataTime: -1.0,\n    lastStoredPixelDataToCanvasImageDataTime: -1.0,\n    lastPutImageDataTime: -1.0,\n    lastRenderTime: -1.0,\n    lastLutGenerateTime: -1.0,\n  };\n\n  if (image) {\n    let render = image.render;\n\n    if (!render) {\n      if (enabledElement.viewport.colormap) {\n        render = renderPseudoColorImage;\n      } else if (image.color) {\n        render = renderColorImage;\n      } else {\n        render = renderGrayscaleImage;\n      }\n    }\n\n    render(enabledElement, invalidated);\n  }\n\n  // Calculate how long it took to draw the image/layers\n  const renderTimeInMs = now() - start;\n\n  image.stats.lastRenderTime = renderTimeInMs;\n\n  enabledElement.invalid = false;\n  enabledElement.needsRedraw = false;\n}\n","import { Transform } from './transform';\nimport {\n  CPUFallbackEnabledElement,\n  CPUFallbackTransform,\n} from '../../../../types';\n\n/**\n * Calculate the transform for a Cornerstone enabled element\n *\n * @param enabledElement - The Cornerstone Enabled Element\n * @param scale - The viewport scale\n * @returns The current transform\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  scale?: number\n): CPUFallbackTransform {\n  const transform = new Transform();\n\n  if (!enabledElement.viewport.displayedArea) {\n    return transform;\n  }\n\n  // Move to center of canvas\n  transform.translate(\n    enabledElement.canvas.width / 2,\n    enabledElement.canvas.height / 2\n  );\n\n  // Apply the rotation before scaling for non square pixels\n  const angle = enabledElement.viewport.rotation;\n\n  if (angle !== 0) {\n    transform.rotate((angle * Math.PI) / 180);\n  }\n\n  // Apply the scale\n  let widthScale = enabledElement.viewport.scale;\n  let heightScale = enabledElement.viewport.scale;\n\n  const width =\n    enabledElement.viewport.displayedArea.brhc.x -\n    (enabledElement.viewport.displayedArea.tlhc.x - 1);\n  const height =\n    enabledElement.viewport.displayedArea.brhc.y -\n    (enabledElement.viewport.displayedArea.tlhc.y - 1);\n\n  if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\n    if (\n      enabledElement.image.rowPixelSpacing <\n      enabledElement.image.columnPixelSpacing\n    ) {\n      widthScale *=\n        enabledElement.image.columnPixelSpacing /\n        enabledElement.image.rowPixelSpacing;\n    } else if (\n      enabledElement.image.columnPixelSpacing <\n      enabledElement.image.rowPixelSpacing\n    ) {\n      heightScale *=\n        enabledElement.image.rowPixelSpacing /\n        enabledElement.image.columnPixelSpacing;\n    }\n  } else {\n    // These should be good for \"TRUE SIZE\" and \"MAGNIFY\"\n    widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\n    heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\n\n    if (\n      enabledElement.viewport.displayedArea.presentationSizeMode ===\n      'SCALE TO FIT'\n    ) {\n      // Fit TRUE IMAGE image (width/height) to window\n      const verticalScale =\n        enabledElement.canvas.height / (height * heightScale);\n      const horizontalScale =\n        enabledElement.canvas.width / (width * widthScale);\n\n      // Apply new scale\n      widthScale = heightScale = Math.min(horizontalScale, verticalScale);\n\n      if (\n        enabledElement.viewport.displayedArea.rowPixelSpacing <\n        enabledElement.viewport.displayedArea.columnPixelSpacing\n      ) {\n        widthScale *=\n          enabledElement.viewport.displayedArea.columnPixelSpacing /\n          enabledElement.viewport.displayedArea.rowPixelSpacing;\n      } else if (\n        enabledElement.viewport.displayedArea.columnPixelSpacing <\n        enabledElement.viewport.displayedArea.rowPixelSpacing\n      ) {\n        heightScale *=\n          enabledElement.viewport.displayedArea.rowPixelSpacing /\n          enabledElement.viewport.displayedArea.columnPixelSpacing;\n      }\n    }\n  }\n\n  transform.scale(widthScale, heightScale);\n\n  // Unrotate to so we can translate unrotated\n  if (angle !== 0) {\n    transform.rotate((-angle * Math.PI) / 180);\n  }\n\n  // Apply the pan offset\n  transform.translate(\n    enabledElement.viewport.translation.x,\n    enabledElement.viewport.translation.y\n  );\n\n  // Rotate again so we can apply general scale\n  if (angle !== 0) {\n    transform.rotate((angle * Math.PI) / 180);\n  }\n\n  if (scale !== undefined) {\n    // Apply the font scale\n    transform.scale(scale, scale);\n  }\n\n  // Apply Flip if required\n  if (enabledElement.viewport.hflip) {\n    transform.scale(-1, 1);\n  }\n\n  if (enabledElement.viewport.vflip) {\n    transform.scale(1, -1);\n  }\n\n  // Move back from center of image\n  transform.translate(-width / 2, -height / 2);\n\n  return transform;\n}\n","import getTransform from './getTransform';\n\nimport { Point2, CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * Converts a point in the canvas coordinate system to the pixel coordinate system\n * system.  This can be used to reset tools' image coordinates after modifications\n * have been made in canvas space (e.g. moving a tool by a few cm, independent of\n * image resolution).\n *\n * @param element - The Cornerstone element within which the input point lies\n * @param pt - The input point in the canvas coordinate system\n *\n * @returns The transformed point in the pixel coordinate system\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  pt: Point2\n): Point2 {\n  const transform = getTransform(enabledElement);\n\n  transform.invert();\n\n  return transform.transformPoint(pt);\n}\n","import { CPUFallbackViewport, Point2 } from '../../../../types';\n\ntype Shift = {\n  x: number;\n  y: number;\n};\n/**\n * Corrects the shift by accounting for viewport rotation and flips.\n *\n * @param shift - The shift to correct.\n * @param viewportOrientation - Object containing information on the viewport orientation.\n */\nexport default function (\n  shift: Shift,\n  viewportOrientation: CPUFallbackViewport\n): Shift {\n  const { hflip, vflip, rotation } = viewportOrientation;\n\n  // Apply Flips\n  shift.x *= hflip ? -1 : 1;\n  shift.y *= vflip ? -1 : 1;\n\n  // Apply rotations\n  if (rotation !== 0) {\n    const angle = (rotation * Math.PI) / 180;\n\n    const cosA = Math.cos(angle);\n    const sinA = Math.sin(angle);\n\n    const newX = shift.x * cosA - shift.y * sinA;\n    const newY = shift.x * sinA + shift.y * cosA;\n\n    shift.x = newX;\n    shift.y = newY;\n  }\n\n  return shift;\n}\n","import { CPUFallbackViewport } from '../../../../types';\n\nconst state = {\n  viewport: {},\n};\n\n/**\n * Sets new default values for `getDefaultViewport`\n *\n * @param {Object} viewport - Object that sets new default values for getDefaultViewport\n * @returns {undefined}\n */\nexport default function (viewport: CPUFallbackViewport): void {\n  state.viewport = viewport || {};\n}\n\nexport { state };\n","import createViewport from './createViewport';\nimport getImageFitScale from './getImageFitScale';\nimport {\n  IImage,\n  CPUFallbackColormap,\n  CPUFallbackViewport,\n} from '../../../../types';\n\n/**\n * Creates a new viewport object containing default values for the image and canvas\n *\n * @param canvas - A Canvas DOM element\n * @param image - A Cornerstone Image Object\n * @returns viewport - object\n */\nexport default function (\n  canvas: HTMLCanvasElement,\n  image: IImage,\n  modality?: string,\n  colormap?: CPUFallbackColormap\n): CPUFallbackViewport {\n  if (canvas === undefined) {\n    throw new Error(\n      'getDefaultViewport: parameter canvas must not be undefined'\n    );\n  }\n\n  if (image === undefined) {\n    return createViewport();\n  }\n\n  // Fit image to window\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n\n  let voi;\n\n  if (modality === 'PT' && image.isPreScaled) {\n    voi = {\n      windowWidth: 5,\n      windowCenter: 2.5,\n    };\n  } else if (\n    image.windowWidth !== undefined &&\n    image.windowCenter !== undefined\n  ) {\n    voi = {\n      windowWidth: Array.isArray(image.windowWidth)\n        ? image.windowWidth[0]\n        : image.windowWidth,\n      windowCenter: Array.isArray(image.windowCenter)\n        ? image.windowCenter[0]\n        : image.windowCenter,\n    };\n  }\n\n  return {\n    scale,\n    translation: {\n      x: 0,\n      y: 0,\n    },\n    voi,\n    invert: image.invert,\n    pixelReplication: false,\n    rotation: 0,\n    hflip: false,\n    vflip: false,\n    modalityLUT: image.modalityLUT,\n    modality,\n    voiLUT: image.voiLUT,\n    colormap: colormap !== undefined ? colormap : image.colormap,\n    displayedArea: {\n      tlhc: {\n        x: 1,\n        y: 1,\n      },\n      brhc: {\n        x: image.columns,\n        y: image.rows,\n      },\n      rowPixelSpacing:\n        image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\n      columnPixelSpacing:\n        image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\n      presentationSizeMode: 'NONE',\n    },\n  };\n}\n","import { state } from './setDefaultViewport';\nimport {\n  CPUFallbackViewportDisplayedArea,\n  CPUFallbackViewport,\n} from '../../../../types';\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Creates the default displayed area.\n * C.10.4 Displayed Area Module: This Module describes Attributes required to define a Specified Displayed Area space.\n *\n * @returns {tlhc: {x,y}, brhc: {x, y},rowPixelSpacing: Number, columnPixelSpacing: Number, presentationSizeMode: Number} displayedArea object\n * @memberof Internal\n */\nfunction createDefaultDisplayedArea(): CPUFallbackViewportDisplayedArea {\n  return {\n    // Top Left Hand Corner\n    tlhc: {\n      x: 1,\n      y: 1,\n    },\n    // Bottom Right Hand Corner\n    brhc: {\n      x: 1,\n      y: 1,\n    },\n    rowPixelSpacing: 1,\n    columnPixelSpacing: 1,\n    presentationSizeMode: 'NONE',\n  };\n}\n\n/**\n * Creates a new viewport object containing default values\n *\n * @returns {Viewport} viewport object\n * @memberof Internal\n */\nexport default function createViewport(): CPUFallbackViewport {\n  const displayedArea = createDefaultDisplayedArea();\n  const initialDefaultViewport = {\n    scale: 1,\n    translation: {\n      x: 0,\n      y: 0,\n    },\n    voi: {\n      windowWidth: undefined,\n      windowCenter: undefined,\n    },\n    invert: false,\n    pixelReplication: false,\n    rotation: 0,\n    hflip: false,\n    vflip: false,\n    modalityLUT: undefined,\n    voiLUT: undefined,\n    colormap: undefined,\n    labelmap: false,\n    displayedArea,\n  };\n\n  return Object.assign({}, initialDefaultViewport, state.viewport);\n}\n","import { validateParameterUndefinedOrNull } from './validator';\nimport getImageSize from './getImageSize';\nimport { IImage } from '../../../../types';\n\n/**\n * Calculates the horizontal, vertical and minimum scale factor for an image\n   @param canvas - The window size where the image is displayed. This can be any HTML element or structure with a width, height fields (e.g. canvas).\n * @param image - The cornerstone image object\n * @param rotation - The rotation angle of the image.\n * @returns The calculated horizontal, vertical and minimum scale factor\n */\nexport default function (\n  canvas: HTMLCanvasElement,\n  image: IImage,\n  rotation: number | null = null\n): {\n  verticalScale: number;\n  horizontalScale: number;\n  scaleFactor: number;\n} {\n  validateParameterUndefinedOrNull(\n    canvas,\n    'getImageScale: parameter canvas must not be undefined'\n  );\n  validateParameterUndefinedOrNull(\n    image,\n    'getImageScale: parameter image must not be undefined'\n  );\n\n  const imageSize = getImageSize(image, rotation);\n  const rowPixelSpacing = image.rowPixelSpacing || 1;\n  const columnPixelSpacing = image.columnPixelSpacing || 1;\n  let verticalRatio = 1;\n  let horizontalRatio = 1;\n\n  if (rowPixelSpacing < columnPixelSpacing) {\n    horizontalRatio = columnPixelSpacing / rowPixelSpacing;\n  } else {\n    // even if they are equal we want to calculate this ratio (the ration might be 0.5)\n    verticalRatio = rowPixelSpacing / columnPixelSpacing;\n  }\n\n  const verticalScale = canvas.height / imageSize.height / verticalRatio;\n  const horizontalScale = canvas.width / imageSize.width / horizontalRatio;\n\n  // Fit image to window\n  return {\n    verticalScale,\n    horizontalScale,\n    scaleFactor: Math.min(horizontalScale, verticalScale),\n  };\n}\n","import { validateParameterUndefinedOrNull } from './validator';\nimport { IImage } from '../../../../types';\n\n/**\n * Check if the angle is rotated\n * @param {Number} rotation the rotation angle\n * @returns {Boolean} true if the angle is rotated; Otherwise, false.\n * @memberof Internal\n */\nfunction isRotated(rotation?: number | null): boolean {\n  return !(\n    rotation === null ||\n    rotation === undefined ||\n    rotation === 0 ||\n    rotation === 180\n  );\n}\n\n/**\n * Retrieves the current image dimensions given an enabled element\n *\n * @param {any} image The Cornerstone image.\n * @param {Number} rotation Optional. The rotation angle of the image.\n * @return {{width:Number, height:Number}} The Image dimensions\n * @memberof Internal\n */\nexport default function (\n  image: IImage,\n  rotation = null\n): { height: number; width: number } {\n  validateParameterUndefinedOrNull(\n    image,\n    'getImageSize: parameter image must not be undefined'\n  );\n  validateParameterUndefinedOrNull(\n    image.width,\n    'getImageSize: parameter image must have width'\n  );\n  validateParameterUndefinedOrNull(\n    image.height,\n    'getImageSize: parameter image must have height'\n  );\n\n  if (isRotated(rotation)) {\n    return {\n      height: image.width,\n      width: image.height,\n    };\n  }\n\n  return {\n    width: image.width,\n    height: image.height,\n  };\n}\n","import calculateTransform from './calculateTransform';\nimport {\n  CPUFallbackEnabledElement,\n  CPUFallbackTransform,\n} from '../../../../types';\n\nexport default function (\n  enabledElement: CPUFallbackEnabledElement\n): CPUFallbackTransform {\n  // Todo: for some reason using the cached transfer after the first call\n  // does not give correct transform.\n  // if (enabledElement.transform) {\n  //   return enabledElement.transform;\n  // }\n\n  return calculateTransform(enabledElement);\n}\n","import getTransform from './getTransform';\nimport { CPUFallbackEnabledElement, Point2 } from '../../../../types';\n\n/**\n * Converts a point in the pixel coordinate system to the canvas coordinate system\n * system.  This can be used to render using canvas context without having the weird\n * side effects that come from scaling and non square pixels\n *\n * @param {HTMLDivElement} element An HTML Element enabled for Cornerstone\n * @param {{x: Number, y: Number}} pt The transformed point in the pixel coordinate system\n *\n * @returns {{x: Number, y: Number}} The input point in the canvas coordinate system\n * @memberof PixelCoordinateSystem\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  pt: Point2\n): Point2 {\n  const transform = getTransform(enabledElement);\n\n  return transform.transformPoint(pt);\n}\n","import getImageFitScale from './getImageFitScale';\nimport { CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * Resets the camera to the default position. which would be the center of the image.\n * with no translation, no flipping, no zoom and proper scale.\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  resetPan = true,\n  resetZoom = true\n): void {\n  const { canvas, image, viewport } = enabledElement;\n  const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n\n  viewport.vflip = false;\n  viewport.hflip = false;\n\n  if (resetPan) {\n    viewport.translation.x = 0;\n    viewport.translation.y = 0;\n  }\n\n  if (resetZoom) {\n    viewport.displayedArea.tlhc.x = 1;\n    viewport.displayedArea.tlhc.y = 1;\n    viewport.displayedArea.brhc.x = image.columns;\n    viewport.displayedArea.brhc.y = image.rows;\n\n    viewport.scale = scale;\n  }\n}\n","import fitToWindow from './fitToWindow';\nimport getImageSize from './getImageSize';\nimport { CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * This module is responsible for enabling an element to display images with cornerstone\n *\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\n * @param {HTMLDivElement} canvas The Canvas DOM element within the DOM element enabled for Cornerstone\n * @returns {void}\n */\nfunction setCanvasSize(enabledElement: CPUFallbackEnabledElement) {\n  const { canvas } = enabledElement;\n  const { clientWidth, clientHeight } = canvas;\n\n  // Set the canvas to be same resolution as the client.\n  if (canvas.width !== clientWidth || canvas.height !== clientHeight) {\n    canvas.width = clientWidth;\n    canvas.height = clientHeight;\n  }\n}\n\n/**\n * Checks if the image of a given enabled element fitted the window\n * before the resize\n *\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\n * @param {number} oldCanvasWidth The width of the canvas before the resize\n * @param {number} oldCanvasHeight The height of the canvas before the resize\n * @return {Boolean} true if it fitted the windows, false otherwise\n */\nfunction wasFitToWindow(\n  enabledElement: CPUFallbackEnabledElement,\n  oldCanvasWidth: number,\n  oldCanvasHeight: number\n): boolean {\n  const scale = enabledElement.viewport.scale;\n  const imageSize = getImageSize(\n    enabledElement.image,\n    enabledElement.viewport.rotation\n  );\n  const imageWidth = Math.round(imageSize.width * scale);\n  const imageHeight = Math.round(imageSize.height * scale);\n  const x = enabledElement.viewport.translation.x;\n  const y = enabledElement.viewport.translation.y;\n\n  return (\n    (imageWidth === oldCanvasWidth && imageHeight <= oldCanvasHeight) ||\n    (imageWidth <= oldCanvasWidth &&\n      imageHeight === oldCanvasHeight &&\n      x === 0 &&\n      y === 0)\n  );\n}\n\n/**\n * Rescale the image relative to the changed size of the canvas\n *\n * @param {EnabledElement} enabledElement The Cornerstone Enabled Element\n * @param {number} oldCanvasWidth The width of the canvas before the resize\n * @param {number} oldCanvasHeight The height of the canvas before the resize\n * @return {void}\n */\nfunction relativeRescale(\n  enabledElement: CPUFallbackEnabledElement,\n  oldCanvasWidth: number,\n  oldCanvasHeight: number\n): void {\n  const scale = enabledElement.viewport.scale;\n  const canvasWidth = enabledElement.canvas.width;\n  const canvasHeight = enabledElement.canvas.height;\n  const relWidthChange = canvasWidth / oldCanvasWidth;\n  const relHeightChange = canvasHeight / oldCanvasHeight;\n  const relChange = Math.sqrt(relWidthChange * relHeightChange);\n\n  enabledElement.viewport.scale = relChange * scale;\n}\n\n/**\n * Resizes an enabled element and optionally fits the image to window\n *\n * @param {HTMLDivElement} element The DOM element enabled for Cornerstone\n * @param {Boolean} forceFitToWindow true to to force a refit, false to rescale accordingly\n * @returns {void}\n */\nexport default function (\n  enabledElement: CPUFallbackEnabledElement,\n  forceFitToWindow = false\n): void {\n  const oldCanvasWidth = enabledElement.canvas.width;\n  const oldCanvasHeight = enabledElement.canvas.height;\n\n  setCanvasSize(enabledElement);\n\n  if (enabledElement.image === undefined) {\n    return;\n  }\n\n  if (\n    forceFitToWindow ||\n    wasFitToWindow(enabledElement, oldCanvasWidth, oldCanvasHeight)\n  ) {\n    // Fit the image to the window again if it fitted before the resize\n    fitToWindow(enabledElement);\n  } else {\n    // Adapt the scale of a zoomed or panned image relative to the size change\n    relativeRescale(enabledElement, oldCanvasWidth, oldCanvasHeight);\n  }\n}\n","import getImageFitScale from './getImageFitScale';\nimport { CPUFallbackEnabledElement } from '../../../../types';\n\n/**\n * Adjusts an image's scale and translation so the image is centered and all pixels\n * in the image are viewable.\n *\n * @param element - The Cornerstone element to update\n */\nexport default function (enabledElement: CPUFallbackEnabledElement): void {\n  const { image } = enabledElement;\n\n  // The new scale is the minimum of the horizontal and vertical scale values\n  enabledElement.viewport.scale = getImageFitScale(\n    enabledElement.canvas,\n    image,\n    enabledElement.viewport.rotation\n  ).scaleFactor;\n\n  enabledElement.viewport.translation.x = 0;\n  enabledElement.viewport.translation.y = 0;\n}\n","import {\n  CPUFallbackTransform,\n  Point2,\n  TransformMatrix2D,\n} from '../../../../types';\n\n// By Simon Sarris\n// Www.simonsarris.com\n// Sarris@acm.org\n//\n// Free to use and distribute at will\n// So long as you are nice to people, etc\n\n// Simple class for keeping track of the current transformation matrix\n\n// For instance:\n//    Var t = new Transform();\n//    T.rotate(5);\n//    Var m = t.m;\n//    Ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n// Is equivalent to:\n//    Ctx.rotate(5);\n\n// But now you can retrieve it :)\n\n// Remember that this does not account for any CSS transforms applied to the canvas\nexport class Transform implements CPUFallbackTransform {\n  private m: TransformMatrix2D;\n\n  constructor() {\n    this.reset();\n  }\n\n  getMatrix(): TransformMatrix2D {\n    return this.m;\n  }\n\n  reset(): void {\n    this.m = [1, 0, 0, 1, 0, 0];\n  }\n\n  clone(): CPUFallbackTransform {\n    const transform = new Transform();\n\n    transform.m[0] = this.m[0];\n    transform.m[1] = this.m[1];\n    transform.m[2] = this.m[2];\n    transform.m[3] = this.m[3];\n    transform.m[4] = this.m[4];\n    transform.m[5] = this.m[5];\n\n    return transform;\n  }\n\n  multiply(matrix: TransformMatrix2D): void {\n    const m11 = this.m[0] * matrix[0] + this.m[2] * matrix[1];\n    const m12 = this.m[1] * matrix[0] + this.m[3] * matrix[1];\n\n    const m21 = this.m[0] * matrix[2] + this.m[2] * matrix[3];\n    const m22 = this.m[1] * matrix[2] + this.m[3] * matrix[3];\n\n    const dx = this.m[0] * matrix[4] + this.m[2] * matrix[5] + this.m[4];\n    const dy = this.m[1] * matrix[4] + this.m[3] * matrix[5] + this.m[5];\n\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    this.m[4] = dx;\n    this.m[5] = dy;\n  }\n\n  invert(): void {\n    const d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);\n    const m0 = this.m[3] * d;\n    const m1 = -this.m[1] * d;\n    const m2 = -this.m[2] * d;\n    const m3 = this.m[0] * d;\n    const m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);\n    const m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);\n\n    this.m[0] = m0;\n    this.m[1] = m1;\n    this.m[2] = m2;\n    this.m[3] = m3;\n    this.m[4] = m4;\n    this.m[5] = m5;\n  }\n\n  rotate(rad: number): void {\n    const c = Math.cos(rad);\n    const s = Math.sin(rad);\n    const m11 = this.m[0] * c + this.m[2] * s;\n    const m12 = this.m[1] * c + this.m[3] * s;\n    const m21 = this.m[0] * -s + this.m[2] * c;\n    const m22 = this.m[1] * -s + this.m[3] * c;\n\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n  }\n\n  translate(x: number, y: number): void {\n    this.m[4] += this.m[0] * x + this.m[2] * y;\n    this.m[5] += this.m[1] * x + this.m[3] * y;\n  }\n\n  scale(sx: number, sy: number) {\n    this.m[0] *= sx;\n    this.m[1] *= sx;\n    this.m[2] *= sy;\n    this.m[3] *= sy;\n  }\n\n  transformPoint(point: Point2): Point2 {\n    const x = point[0];\n    const y = point[1];\n\n    return [\n      x * this.m[0] + y * this.m[2] + this.m[4],\n      x * this.m[1] + y * this.m[3] + this.m[5],\n    ];\n  }\n}\n","/**\n * Check if the supplied parameter is undefined and throws and error\n * @param {any} checkParam the parameter to validate for undefined\n * @param {any} errorMsg the error message to be thrown\n * @returns {void}\n * @memberof internal\n */\nexport function validateParameterUndefined(\n  checkParam: any | undefined,\n  errorMsg: string\n): void {\n  if (checkParam === undefined) {\n    throw new Error(errorMsg);\n  }\n}\n\n/**\n * Check if the supplied parameter is undefined or null and throws and error\n * @param {any} checkParam the parameter to validate for undefined\n * @param {any} errorMsg the error message to be thrown\n * @returns {void}\n * @memberof internal\n */\nexport function validateParameterUndefinedOrNull(\n  checkParam: any | null | undefined,\n  errorMsg: string\n): void {\n  if (checkParam === undefined || checkParam === null) {\n    throw new Error(errorMsg);\n  }\n}\n","import { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkVolumeProperty from './VolumeProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkVolume methods\n// ----------------------------------------------------------------------------\n\nfunction vtkVolume(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkVolume');\n  publicAPI.getVolumes = () => publicAPI;\n  publicAPI.makeProperty = vtkVolumeProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      const bbox = [];\n      vtkBoundingBox.getCorners(bds, bbox);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      bbox.forEach(pt => vec3.transformMat4(pt, pt, tmp4));\n\n      /* eslint-disable no-multi-assign */\n      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;\n      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;\n      /* eslint-enable no-multi-assign */\n      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkVolume(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkVolume');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVolume$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkVolume$1 as default, extend, newInstance };\n","import vtkVolume from '@kitware/vtk.js/Rendering/Core/Volume';\n\nimport { VolumeActor } from './../../types/IActor';\nimport { VoiModifiedEventDetail } from './../../types/EventTypes';\nimport { loadVolume } from '../../loaders/volumeLoader';\nimport createVolumeMapper from './createVolumeMapper';\nimport BlendModes from '../../enums/BlendModes';\nimport { triggerEvent } from '../../utilities';\nimport { Events } from '../../enums';\nimport setDefaultVolumeVOI from './setDefaultVolumeVOI';\n\ninterface createVolumeActorInterface {\n  volumeId: string;\n  callback?: ({\n    volumeActor,\n    volumeId,\n  }: {\n    volumeActor: VolumeActor;\n    volumeId: string;\n  }) => void;\n  blendMode?: BlendModes;\n}\n\n/**\n * Given a volumeId, it creates a vtk volume actor and returns it. If\n * callback is provided, it will be called with the volume actor and the\n * volumeId. If blendMode is provided, it will be set on the volume actor.\n *\n * @param props - createVolumeActorInterface\n * @returns A promise that resolves to a VolumeActor.\n */\nasync function createVolumeActor(\n  props: createVolumeActorInterface,\n  element: HTMLDivElement,\n  viewportId: string,\n  suppressEvents = false,\n  useNativeDataType = false\n): Promise<VolumeActor> {\n  const { volumeId, callback, blendMode } = props;\n\n  const imageVolume = await loadVolume(volumeId);\n\n  if (!imageVolume) {\n    throw new Error(\n      `imageVolume with id: ${imageVolume.volumeId} does not exist`\n    );\n  }\n\n  const { imageData, vtkOpenGLTexture } = imageVolume;\n\n  const volumeMapper = createVolumeMapper(imageData, vtkOpenGLTexture);\n\n  if (blendMode) {\n    volumeMapper.setBlendMode(blendMode);\n  }\n\n  const volumeActor = vtkVolume.newInstance();\n  volumeActor.setMapper(volumeMapper);\n\n  const numberOfComponents = imageData\n    .getPointData()\n    .getScalars()\n    .getNumberOfComponents();\n\n  if (numberOfComponents === 3) {\n    volumeActor.getProperty().setIndependentComponents(false);\n  }\n\n  await setDefaultVolumeVOI(volumeActor, imageVolume, useNativeDataType);\n\n  if (callback) {\n    callback({ volumeActor, volumeId });\n  }\n\n  if (!suppressEvents) {\n    triggerVOIModified(element, viewportId, volumeActor, volumeId);\n  }\n\n  return volumeActor;\n}\n\nfunction triggerVOIModified(\n  element: HTMLDivElement,\n  viewportId: string,\n  volumeActor: VolumeActor,\n  volumeId: string\n) {\n  const voiRange = volumeActor\n    .getProperty()\n    .getRGBTransferFunction(0)\n    .getRange();\n\n  const voiModifiedEventDetail: VoiModifiedEventDetail = {\n    viewportId,\n    range: {\n      lower: voiRange[0],\n      upper: voiRange[1],\n    },\n    volumeId,\n  };\n\n  triggerEvent(element, Events.VOI_MODIFIED, voiModifiedEventDetail);\n}\n\nexport default createVolumeActor;\n","import {\n  VolumeActor,\n  IImageVolume,\n  VOIRange,\n  ScalingParameters,\n} from '../../types';\nimport { loadAndCacheImage } from '../../loaders/imageLoader';\nimport * as metaData from '../../metaData';\nimport { getMinMax, windowLevel } from '../../utilities';\nimport { RequestType } from '../../enums';\nimport cache from '../../cache';\n\nconst PRIORITY = 0;\nconst REQUEST_TYPE = RequestType.Prefetch;\n\n/**\n * It sets the default window level of an image volume based on the VOI.\n * It first look for the VOI in the metadata and if it is not found, it\n * loads the middle slice image (middle imageId) and based on its min\n * and max pixel values, it calculates the VOI.\n * Finally it sets the VOI on the volumeActor transferFunction\n * @param volumeActor - The volume actor\n * @param imageVolume - The image volume that we want to set the VOI for.\n * @param useNativeDataType -  The image data type is native or Float32Array\n */\nasync function setDefaultVolumeVOI(\n  volumeActor: VolumeActor,\n  imageVolume: IImageVolume,\n  useNativeDataType: boolean\n): Promise<void> {\n  let voi = getVOIFromMetadata(imageVolume);\n\n  if (!voi && imageVolume?.imageIds?.length) {\n    voi = await getVOIFromMinMax(imageVolume, useNativeDataType);\n    voi = handlePreScaledVolume(imageVolume, voi);\n  }\n  // if (!voi || voi.lower === undefined || voi.upper === undefined) {\n  //   throw new Error(\n  //     'Could not get VOI from metadata, nor from the min max of the image middle slice'\n  //   );\n  // }\n  if (\n    (voi?.lower === 0 && voi?.upper === 0) ||\n    voi?.lower === undefined ||\n    voi?.upper === undefined\n  ) {\n    return;\n  }\n\n  volumeActor\n    .getProperty()\n    .getRGBTransferFunction(0)\n    .setMappingRange(voi.lower, voi.upper);\n}\n\nfunction handlePreScaledVolume(imageVolume: IImageVolume, voi: VOIRange) {\n  const imageIds = imageVolume.imageIds;\n  const imageIdIndex = Math.floor(imageIds.length / 2);\n  const imageId = imageIds[imageIdIndex];\n\n  const generalSeriesModule =\n    metaData.get('generalSeriesModule', imageId) || {};\n\n  /**\n   * If the volume is prescaled and the modality is PT Sometimes you get super high\n   * values at the peak and it skews the min/max so nothing useful is displayed\n   * Therefore, we follow the majority of other viewers and we set the min/max\n   * for the scaled PT to be 0, 5\n   */\n  if (_isCurrentImagePTPrescaled(generalSeriesModule.modality, imageVolume)) {\n    return {\n      lower: 0,\n      upper: 5,\n    };\n  }\n\n  return voi;\n}\n\n/**\n * Get the VOI from the metadata of the middle slice of the image volume or the metadata of the image volume\n * It checks the metadata for the VOI and if it is not found, it returns null\n *\n * @param imageVolume - The image volume that we want to get the VOI from.\n * @returns VOIRange with lower and upper values\n */\nfunction getVOIFromMetadata(imageVolume: IImageVolume): VOIRange {\n  const { imageIds, metadata } = imageVolume;\n  let voi;\n  if (imageIds.length) {\n    const imageIdIndex = Math.floor(imageIds.length / 2);\n    const imageId = imageIds[imageIdIndex];\n    const voiLutModule = metaData.get('voiLutModule', imageId);\n    if (voiLutModule && voiLutModule.windowWidth && voiLutModule.windowCenter) {\n      const { windowWidth, windowCenter } = voiLutModule;\n      voi = {\n        windowWidth: Array.isArray(windowWidth) ? windowWidth[0] : windowWidth,\n        windowCenter: Array.isArray(windowCenter)\n          ? windowCenter[0]\n          : windowCenter,\n      };\n    }\n  } else {\n    voi = metadata?.voiLut?.[0];\n  }\n  if (voi) {\n    const { lower, upper } = windowLevel.toLowHighRange(\n      Number(voi.windowWidth),\n      Number(voi.windowCenter)\n    );\n    return {\n      lower,\n      upper,\n    };\n  }\n}\n\n/**\n * It loads the middle slice image (middle imageId) and based on its min\n * and max pixel values, it calculates the VOI.\n *\n * @param imageVolume - The image volume that we want to get the VOI from.\n * @param useNativeDataType -  The image data type is native or Float32Array\n * @returns The VOIRange with lower and upper values\n */\nasync function getVOIFromMinMax(\n  imageVolume: IImageVolume,\n  useNativeDataType: boolean\n): Promise<VOIRange> {\n  const { imageIds } = imageVolume;\n  const scalarData = imageVolume.getScalarData();\n\n  // Get the middle image from the list of imageIds\n  const imageIdIndex = Math.floor(imageIds.length / 2);\n  const imageId = imageVolume.imageIds[imageIdIndex];\n  const generalSeriesModule =\n    metaData.get('generalSeriesModule', imageId) || {};\n  const { modality } = generalSeriesModule;\n  const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\n\n  const numImages = imageIds.length;\n  const bytesPerImage = scalarData.byteLength / numImages;\n  const voxelsPerImage = scalarData.length / numImages;\n  const bytePerPixel = scalarData.BYTES_PER_ELEMENT;\n\n  const scalingParameters: ScalingParameters = {\n    rescaleSlope: modalityLutModule.rescaleSlope,\n    rescaleIntercept: modalityLutModule.rescaleIntercept,\n    modality,\n  };\n\n  let scalingParametersToUse;\n  if (modality === 'PT') {\n    const suvFactor = metaData.get('scalingModule', imageId);\n\n    if (suvFactor) {\n      scalingParametersToUse = {\n        ...scalingParameters,\n        suvbw: suvFactor.suvbw,\n      };\n    }\n  }\n\n  const byteOffset = imageIdIndex * bytesPerImage;\n\n  const options = {\n    targetBuffer: {\n      type: useNativeDataType ? undefined : 'Float32Array',\n    },\n    priority: PRIORITY,\n    requestType: REQUEST_TYPE,\n    useNativeDataType,\n    preScale: {\n      enabled: true,\n      scalingParameters: scalingParametersToUse,\n    },\n  };\n\n  // Loading the middle slice image for a volume has two scenarios, the first one is that\n  // uses the same volumeLoader which might not resolve to an image (since for performance\n  // reasons volumes' pixelData is set via offset and length on the volume arrayBuffer\n  // when each slice is loaded). The second scenario is that the image might not reach\n  // to the volumeLoader, and an already cached image (with Image object) is used\n  // instead. For the first scenario, we use the arrayBuffer of the volume to get the correct\n  // slice for the imageScalarData, and for the second scenario we use the getPixelData\n  // on the Cornerstone IImage object to get the pixel data.\n  // Note: we don't want to use the derived or generated images for setting the\n  // default VOI, because they are not the original. This is ugly but don't\n  // know how to do it better.\n  let image = cache.getImage(imageId);\n\n  if (!imageVolume.referencedImageIds?.length) {\n    // we should ignore the cache here,\n    // since we want to load the image from with the most\n    // recent prescale settings\n    image = await loadAndCacheImage(imageId, { ...options, ignoreCache: true });\n  }\n\n  const imageScalarData = image\n    ? image.getPixelData()\n    : _getImageScalarDataFromImageVolume(\n        imageVolume,\n        byteOffset,\n        bytePerPixel,\n        voxelsPerImage\n      );\n\n  // Get the min and max pixel values of the middle slice\n  const { min, max } = getMinMax(imageScalarData);\n\n  return {\n    lower: min,\n    upper: max,\n  };\n}\n\nfunction _getImageScalarDataFromImageVolume(\n  imageVolume,\n  byteOffset,\n  bytePerPixel,\n  voxelsPerImage\n) {\n  const { scalarData } = imageVolume;\n  const { buffer } = scalarData;\n  if (scalarData.BYTES_PER_ELEMENT !== bytePerPixel) {\n    byteOffset *= scalarData.BYTES_PER_ELEMENT / bytePerPixel;\n  }\n\n  const TypedArray = scalarData.constructor;\n  const imageScalarData = new TypedArray(voxelsPerImage);\n\n  const volumeBufferView = new TypedArray(buffer, byteOffset, voxelsPerImage);\n\n  imageScalarData.set(volumeBufferView);\n\n  return imageScalarData;\n}\n\nfunction _isCurrentImagePTPrescaled(modality, imageVolume) {\n  if (modality !== 'PT' || !imageVolume.isPreScaled) {\n    return false;\n  }\n\n  if (!imageVolume.scaling?.PT.suvbw) {\n    return false;\n  }\n\n  return true;\n}\n\nexport default setDefaultVolumeVOI;\n","import macro from '@kitware/vtk.js/macros';\nimport vtkVolumeMapper from '@kitware/vtk.js/Rendering/Core/VolumeMapper';\n\n/**\n * vtkSharedVolumeMapper - A derived class of the core vtkVolumeMapper class\n * the scalar texture in as an argument. This is so we can share the same texture\n * memory across different mappers/actors, so we don't duplicate memory usage.\n *\n *\n *\n * @param {*} publicAPI The public API to extend\n * @param {*} model The private model to extend.\n * @hidden\n */\nfunction vtkSharedVolumeMapper(publicAPI, model) {\n  model.classHierarchy.push('vtkSharedVolumeMapper');\n\n  const superDelete = publicAPI.delete;\n  publicAPI.delete = () => {\n    model.scalarTexture = null;\n    superDelete();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  scalarTexture: null,\n};\n\nexport function extend(publicAPI, model, initialValues = {}) {\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  vtkVolumeMapper.extend(publicAPI, model, initialValues);\n\n  macro.setGet(publicAPI, model, ['scalarTexture']);\n\n  // Object methods\n  vtkSharedVolumeMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nexport const newInstance = macro.newInstance(extend, 'vtkSharedVolumeMapper');\n\n// ----------------------------------------------------------------------------\n\nexport default { newInstance, extend };\n","import {\n  ICache,\n  IImage,\n  IGeometry,\n  IImageLoadObject,\n  IVolumeLoadObject,\n  IGeometryLoadObject,\n  ICachedImage,\n  ICachedVolume,\n  ICachedGeometry,\n  EventTypes,\n  IImageVolume,\n} from '../types';\nimport { triggerEvent, imageIdToURI } from '../utilities';\nimport eventTarget from '../eventTarget';\nimport Events from '../enums/Events';\nimport { ImageVolume } from './classes/ImageVolume';\n\nconst ONE_GB = 1073741824;\n\n/**\n * Stores images, volumes and geometry.\n * There are two sizes - the max cache size, that controls the overal maximum\n * size, and the instance size, which controls how big any single object can\n * be.  Defaults are 3 GB and 2 GB - 8 bytes (just enough to allow allocating it\n * without crashing).\n * The 3 gb is tuned to the chromium garbage collection cycle to allow image volumes\n * to be used/discarded.\n */\nclass Cache implements ICache {\n  // used to store image data (2d)\n  private readonly _imageCache = new Map<string, ICachedImage>(); // volatile space\n  // used to store volume data (3d)\n  private readonly _volumeCache = new Map<string, ICachedVolume>(); // non-volatile space\n  // Todo: contour for now, but will be used for surface, etc.\n  private readonly _geometryCache: Map<string, ICachedGeometry>;\n\n  private _imageCacheSize = 0;\n  private _volumeCacheSize = 0;\n  private _maxCacheSize = 3 * ONE_GB;\n  private _maxInstanceSize = 4 * ONE_GB - 8;\n\n  constructor() {\n    // used to store object data (contour, surface, etc.)\n    this._geometryCache = new Map();\n  }\n\n  /**\n   * Set the maximum cache Size\n   *\n   * Maximum cache size should be set before adding the data.  If set after,\n   * and it is smaller than the current size, will cause issues.\n   *\n   * @param newMaxCacheSize -  new maximum cache size\n   *\n   */\n  public setMaxCacheSize = (newMaxCacheSize: number): void => {\n    if (!newMaxCacheSize || typeof newMaxCacheSize !== 'number') {\n      const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;\n      throw new Error(errorMessage);\n    }\n\n    this._maxCacheSize = newMaxCacheSize;\n  };\n\n  /**\n   * Checks if there is enough space in the cache for requested byte size\n   *\n   * It returns false, if the sum of volatile (image) cache and unallocated cache\n   * is less than the requested byteLength\n   *\n   * @param byteLength - byte length of requested byte size\n   *\n   * @returns - boolean indicating if there is enough space in the cache\n   */\n  public isCacheable = (byteLength: number): boolean => {\n    if (byteLength > this._maxInstanceSize) {\n      return false;\n    }\n    const unallocatedSpace = this.getBytesAvailable();\n    const imageCacheSize = this._imageCacheSize;\n    const availableSpace = unallocatedSpace + imageCacheSize;\n\n    return availableSpace > byteLength;\n  };\n\n  /**\n   * Returns maximum CacheSize allowed\n   *\n   * @returns maximum allowed cache size\n   */\n  public getMaxCacheSize = (): number => this._maxCacheSize;\n\n  /**\n   * Returns maximum size of a single instance (volume or single image)\n   *\n   * @returns maximum instance size\n   */\n  public getMaxInstanceSize = (): number => this._maxInstanceSize;\n\n  /**\n   * Returns current size of the cache\n   *\n   * @returns current size of the cache\n   */\n  public getCacheSize = (): number =>\n    this._imageCacheSize + this._volumeCacheSize;\n\n  /**\n   * Returns the unallocated size of the cache\n   *\n   */\n  public getBytesAvailable(): number {\n    return this.getMaxCacheSize() - this.getCacheSize();\n  }\n\n  /**\n   * Deletes the imageId from the image cache\n   *\n   * @param imageId - imageId\n   *\n   */\n  private _decacheImage = (imageId: string) => {\n    const cachedImage = this._imageCache.get(imageId);\n\n    if (!cachedImage) {\n      return;\n    }\n\n    const { imageLoadObject } = cachedImage;\n\n    // Cancel any in-progress loading\n    if (imageLoadObject.cancelFn) {\n      imageLoadObject.cancelFn();\n    }\n\n    if (imageLoadObject.decache) {\n      imageLoadObject.decache();\n    }\n\n    this._imageCache.delete(imageId);\n  };\n\n  /**\n   * Deletes the volumeId from the volume cache\n   *\n   * @param volumeId - volumeId\n   *\n   */\n  private _decacheVolume = (volumeId: string) => {\n    const cachedVolume = this._volumeCache.get(volumeId);\n\n    if (!cachedVolume) {\n      return;\n    }\n\n    const { volumeLoadObject, volume } = cachedVolume;\n\n    if (!volume) {\n      return;\n    }\n\n    if (volume.cancelLoading) {\n      volume.cancelLoading();\n    }\n\n    if (volume.imageData) {\n      volume.imageData.delete();\n    }\n\n    // if we had views for the images of the volume, we need to restore them\n    // to avoid memory leaks\n    this._restoreImagesFromBuffer(volume);\n\n    if (volumeLoadObject.cancelFn) {\n      // Cancel any in-progress loading\n      volumeLoadObject.cancelFn();\n    }\n\n    if (volumeLoadObject.decache) {\n      volumeLoadObject.decache();\n    }\n\n    this._volumeCache.delete(volumeId);\n  };\n\n  /**\n   * Deletes all the images and volumes in the cache\n   *\n   * Relevant events are fired for each decached image (IMAGE_CACHE_IMAGE_REMOVED) and\n   * the decached volume (VOLUME_CACHE_VOLUME_REMOVED).\n   *\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\n   *\n   */\n  public purgeCache = (): void => {\n    const imageIterator = this._imageCache.keys();\n\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      const { value: imageId, done } = imageIterator.next();\n\n      if (done) {\n        break;\n      }\n\n      this.removeImageLoadObject(imageId);\n\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n    }\n\n    this.purgeVolumeCache();\n  };\n\n  /**\n   * Deletes all the volumes in the cache\n   */\n  public purgeVolumeCache = (): void => {\n    const volumeIterator = this._volumeCache.keys();\n\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      const { value: volumeId, done } = volumeIterator.next();\n\n      if (done) {\n        break;\n      }\n\n      this.removeVolumeLoadObject(volumeId);\n\n      triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, {\n        volumeId,\n      });\n    }\n  };\n\n  /**\n   * Purges the cache if necessary based on the requested number of bytes\n   *\n   * 1) it sorts the volatile (image) cache based on the most recent used images\n   * and starts purging from the oldest ones.\n   * Note: for a volume, if the volume-related image Ids is provided, it starts\n   * by purging the none-related image Ids (those that are not related to the\n   * current volume)\n   * 2) For a volume, if we purge all images that won't be included in this volume and still\n   * don't have enough unallocated space, purge images that will be included\n   * in this volume until we have enough space. These will need to be\n   * re-fetched, but we must do this not to straddle over the given memory\n   * limit, even for a short time, as this may crash the application.\n   *\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\n   *\n   * @param numBytes - Number of bytes for the image/volume that is\n   * going to be stored inside the cache\n   * @param volumeImageIds - list of imageIds that correspond to the\n   * volume whose numberOfBytes we want to store in the cache.\n   * @returns bytesAvailable or undefined in purging cache\n   * does not successfully make enough space for the requested number of bytes\n   */\n  public decacheIfNecessaryUntilBytesAvailable(\n    numBytes: number,\n    volumeImageIds?: Array<string>\n  ): number | undefined {\n    let bytesAvailable = this.getBytesAvailable();\n\n    // If max cache size has not been exceeded, do nothing\n    if (bytesAvailable >= numBytes) {\n      return bytesAvailable;\n    }\n\n    let cachedImages = Array.from(this._imageCache.values());\n\n    // Cache size has been exceeded, create list of images sorted by timeStamp\n    // So we can purge the least recently used image\n    function compare(a, b) {\n      if (a.timeStamp > b.timeStamp) {\n        return 1;\n      }\n      if (a.timeStamp < b.timeStamp) {\n        return -1;\n      }\n\n      return 0;\n    }\n\n    cachedImages.sort(compare);\n    let cachedImageIds = cachedImages.map((im) => im.imageId);\n\n    let imageIdsToPurge = cachedImageIds;\n\n    // if we are making space for a volume, we start by purging the imageIds\n    // that are not related to the volume\n    if (volumeImageIds) {\n      imageIdsToPurge = cachedImageIds.filter(\n        (id) => !volumeImageIds.includes(id)\n      );\n    }\n\n    // Remove images (that are not related to the volume) from volatile cache\n    // until the requested number of bytes become available\n    for (const imageId of imageIdsToPurge) {\n      this.removeImageLoadObject(imageId);\n\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n\n      bytesAvailable = this.getBytesAvailable();\n      if (bytesAvailable >= numBytes) {\n        return bytesAvailable;\n      }\n    }\n\n    // Remove the imageIds (both volume related and not related)\n    cachedImages = Array.from(this._imageCache.values());\n    cachedImageIds = cachedImages.map((im) => im.imageId);\n\n    // Remove volume-image Ids from volatile cache until the requested number of bytes\n    // become available\n    for (const imageId of cachedImageIds) {\n      this.removeImageLoadObject(imageId);\n\n      triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, { imageId });\n\n      bytesAvailable = this.getBytesAvailable();\n      if (bytesAvailable >= numBytes) {\n        return bytesAvailable;\n      }\n    }\n\n    // Technically we should not reach here, since isCacheable will throw an\n    // error if unallocated + volatile (image) cache cannot fit the upcoming\n    // number of bytes\n  }\n\n  /**\n   * Puts a new image load object into the cache\n   *\n   * First, it creates a CachedImage object and put it inside the imageCache for\n   * the imageId. After the imageLoadObject promise resolves to an image,\n   * it: 1) adds the image into the correct CachedImage object 2) increments the\n   * cache size, 3) triggers IMAGE_CACHE_IMAGE_ADDED  4) Purge the cache if\n   * necessary -- if the cache size is greater than the maximum cache size, it\n   * iterates over the imageCache and decache them one by one until the cache\n   * size becomes less than the maximum allowed cache size\n   *\n   * @fires Events.IMAGE_CACHE_IMAGE_ADDED\n   * @fires Events.CACHE_SIZE_EXCEEDED if the cache size exceeds the maximum\n   *\n   * @param imageId - ImageId for the image\n   * @param imageLoadObject - The object that is loading or loaded the image\n   */\n  public putImageLoadObject(\n    imageId: string,\n    imageLoadObject: IImageLoadObject\n  ): Promise<any> {\n    if (imageId === undefined) {\n      throw new Error('putImageLoadObject: imageId must not be undefined');\n    }\n\n    if (imageLoadObject.promise === undefined) {\n      throw new Error(\n        'putImageLoadObject: imageLoadObject.promise must not be undefined'\n      );\n    }\n\n    if (this._imageCache.has(imageId)) {\n      throw new Error('putImageLoadObject: imageId already in cache');\n    }\n\n    if (\n      imageLoadObject.cancelFn &&\n      typeof imageLoadObject.cancelFn !== 'function'\n    ) {\n      throw new Error(\n        'putImageLoadObject: imageLoadObject.cancel must be a function'\n      );\n    }\n\n    const cachedImage: ICachedImage = {\n      loaded: false,\n      imageId,\n      sharedCacheKey: undefined, // The sharedCacheKey for this imageId.  undefined by default\n      imageLoadObject,\n      timeStamp: Date.now(),\n      sizeInBytes: 0,\n    };\n\n    this._imageCache.set(imageId, cachedImage);\n\n    return imageLoadObject.promise\n      .then((image: IImage) => {\n        if (!this._imageCache.get(imageId)) {\n          // If the image has been purged before being loaded, we stop here.\n          console.warn(\n            'The image was purged from the cache before it completed loading.'\n          );\n          return;\n        }\n\n        if (\n          image.sizeInBytes === undefined ||\n          Number.isNaN(image.sizeInBytes)\n        ) {\n          throw new Error(\n            'putImageLoadObject: image.sizeInBytes must not be undefined'\n          );\n        }\n        if (image.sizeInBytes.toFixed === undefined) {\n          throw new Error(\n            'putImageLoadObject: image.sizeInBytes is not a number'\n          );\n        }\n\n        // check if there is enough space in unallocated + image Cache\n        if (!this.isCacheable(image.sizeInBytes)) {\n          throw new Error(Events.CACHE_SIZE_EXCEEDED);\n        }\n\n        // if there is, decache if necessary\n        this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);\n\n        cachedImage.loaded = true;\n        cachedImage.image = image;\n        cachedImage.sizeInBytes = image.sizeInBytes;\n        this.incrementImageCacheSize(cachedImage.sizeInBytes);\n        const eventDetails: EventTypes.ImageCacheImageAddedEventDetail = {\n          image: cachedImage,\n        };\n\n        triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_ADDED, eventDetails);\n\n        cachedImage.sharedCacheKey = image.sharedCacheKey;\n      })\n      .catch((error) => {\n        // console.warn(error)\n        this._imageCache.delete(imageId);\n        throw error;\n      });\n  }\n\n  /**\n   * Returns the object that is loading a given imageId\n   *\n   * @param imageId - Image ID\n   * @returns IImageLoadObject\n   */\n  public getImageLoadObject(imageId: string): IImageLoadObject | undefined {\n    if (imageId === undefined) {\n      throw new Error('getImageLoadObject: imageId must not be undefined');\n    }\n\n    const cachedImage = this._imageCache.get(imageId);\n\n    if (!cachedImage) {\n      return;\n    }\n\n    // Bump time stamp for cached image\n    cachedImage.timeStamp = Date.now();\n\n    return cachedImage.imageLoadObject;\n  }\n\n  /**\n   * It checks the imageCache for the provided imageId, and returns true\n   * if the image is loaded, false otherwise. Note, this only checks the imageCache\n   * and does not check the volume cache.\n   * @param imageId - image Id to check\n   * @returns boolean\n   */\n  public isLoaded(imageId: string): boolean {\n    const cachedImage = this._imageCache.get(imageId);\n\n    if (!cachedImage) {\n      return false;\n    }\n\n    return cachedImage.loaded;\n  }\n\n  /**\n   * Returns the volume that contains the requested imageId. It will check the\n   * imageIds inside the volume to find a match.\n   *\n   * @param imageId - ImageId\n   * @returns - Volume object\n   */\n  public getVolumeContainingImageId(imageId: string):\n    | {\n        volume: IImageVolume;\n        imageIdIndex: number;\n      }\n    | undefined {\n    const volumeIds = Array.from(this._volumeCache.keys());\n    const imageIdToUse = imageIdToURI(imageId);\n\n    for (const volumeId of volumeIds) {\n      const cachedVolume = this._volumeCache.get(volumeId);\n\n      if (!cachedVolume) {\n        return;\n      }\n\n      const { volume } = cachedVolume;\n\n      if (!volume?.imageIds?.length) {\n        return;\n      }\n\n      const imageIdIndex = volume.getImageURIIndex(imageIdToUse);\n\n      if (imageIdIndex > -1) {\n        return { volume, imageIdIndex };\n      }\n    }\n  }\n\n  /**\n   * Returns the cached image from the imageCache for the requested imageId.\n   * It first strips the imageId to remove the data loading scheme.\n   *\n   * @param imageId - Image ID\n   * @returns cached image\n   */\n  public getCachedImageBasedOnImageURI(\n    imageId: string\n  ): ICachedImage | undefined {\n    const imageURIToUse = imageIdToURI(imageId);\n\n    const cachedImageIds = Array.from(this._imageCache.keys());\n    const foundImageId = cachedImageIds.find((imageId) => {\n      return imageIdToURI(imageId) === imageURIToUse;\n    });\n\n    if (!foundImageId) {\n      return;\n    }\n\n    return this._imageCache.get(foundImageId);\n  }\n  /**\n   * Puts a new image load object into the cache\n   *\n   * First, it creates a CachedVolume object and put it inside the volumeCache for\n   * the volumeId. After the volumeLoadObject promise resolves to a volume,\n   * it: 1) adds the volume into the correct CachedVolume object inside volumeCache\n   * 2) increments the cache size, 3) triggers VOLUME_CACHE_VOLUME_ADDED  4) Purge\n   * the cache if necessary -- if the cache size is greater than the maximum cache size, it\n   * iterates over the imageCache (not volumeCache) and decache them one by one\n   * until the cache size becomes less than the maximum allowed cache size\n   *\n   * @fires Events.VOLUME_CACHE_VOLUME_ADDED\n   *\n   * @param volumeId - volumeId of the volume\n   * @param volumeLoadObject - The object that is loading or loaded the volume\n   */\n  public putVolumeLoadObject(\n    volumeId: string,\n    volumeLoadObject: IVolumeLoadObject\n  ): Promise<any> {\n    if (volumeId === undefined) {\n      throw new Error('putVolumeLoadObject: volumeId must not be undefined');\n    }\n    if (volumeLoadObject.promise === undefined) {\n      throw new Error(\n        'putVolumeLoadObject: volumeLoadObject.promise must not be undefined'\n      );\n    }\n    if (this._volumeCache.has(volumeId)) {\n      throw new Error(\n        `putVolumeLoadObject: volumeId:${volumeId} already in cache`\n      );\n    }\n    if (\n      volumeLoadObject.cancelFn &&\n      typeof volumeLoadObject.cancelFn !== 'function'\n    ) {\n      throw new Error(\n        'putVolumeLoadObject: volumeLoadObject.cancel must be a function'\n      );\n    }\n\n    // todo: @Erik there are two loaded flags, one inside cachedVolume and the other\n    // inside the volume.loadStatus.loaded, the actual all pixelData loaded is the\n    // loadStatus one. This causes confusion\n    const cachedVolume: ICachedVolume = {\n      loaded: false,\n      volumeId,\n      volumeLoadObject,\n      timeStamp: Date.now(),\n      sizeInBytes: 0,\n    };\n\n    this._volumeCache.set(volumeId, cachedVolume);\n\n    return volumeLoadObject.promise\n      .then((volume: IImageVolume) => {\n        if (!this._volumeCache.get(volumeId)) {\n          // If the image has been purged before being loaded, we stop here.\n          console.warn(\n            'The image was purged from the cache before it completed loading.'\n          );\n          return;\n        }\n\n        if (Number.isNaN(volume.sizeInBytes)) {\n          throw new Error(\n            'putVolumeLoadObject: volume.sizeInBytes must not be undefined'\n          );\n        }\n        if (volume.sizeInBytes.toFixed === undefined) {\n          throw new Error(\n            'putVolumeLoadObject: volume.sizeInBytes is not a number'\n          );\n        }\n\n        // this.isCacheable is called at the volume loader, before requesting\n        // the images of the volume\n\n        this.decacheIfNecessaryUntilBytesAvailable(\n          volume.sizeInBytes,\n          // @ts-ignore: // todo ImageVolume does not have imageIds\n          volume.imageIds\n        );\n\n        // cachedVolume.loaded = true\n        cachedVolume.volume = volume;\n        cachedVolume.sizeInBytes = volume.sizeInBytes;\n        this.incrementVolumeCacheSize(cachedVolume.sizeInBytes);\n\n        const eventDetails: EventTypes.VolumeCacheVolumeAddedEventDetail = {\n          volume: cachedVolume,\n        };\n\n        triggerEvent(\n          eventTarget,\n          Events.VOLUME_CACHE_VOLUME_ADDED,\n          eventDetails\n        );\n      })\n      .catch((error) => {\n        this._volumeCache.delete(volumeId);\n        throw error;\n      });\n  }\n\n  /**\n   * Returns the object that is loading a given volumeId\n   *\n   * @param volumeId - Volume ID\n   * @returns IVolumeLoadObject\n   */\n  public getVolumeLoadObject = (\n    volumeId: string\n  ): IVolumeLoadObject | undefined => {\n    if (volumeId === undefined) {\n      throw new Error('getVolumeLoadObject: volumeId must not be undefined');\n    }\n\n    const cachedVolume = this._volumeCache.get(volumeId);\n\n    if (!cachedVolume) {\n      return;\n    }\n\n    // Bump time stamp for cached volume (not used for anything for now)\n    cachedVolume.timeStamp = Date.now();\n\n    return cachedVolume.volumeLoadObject;\n  };\n\n  public getGeometry = (geometryId: string): IGeometry | undefined => {\n    if (geometryId == null) {\n      throw new Error('getGeometry: geometryId must not be undefined');\n    }\n\n    const cachedGeometry = this._geometryCache.get(geometryId);\n\n    if (!cachedGeometry) {\n      return;\n    }\n\n    // Bump time stamp for cached geometry (not used for anything for now)\n    cachedGeometry.timeStamp = Date.now();\n\n    return cachedGeometry.geometry;\n  };\n\n  /**\n   * Returns the image associated with the imageId\n   *\n   * @param imageId - image ID\n   * @returns Image\n   */\n  public getImage = (imageId: string): IImage | undefined => {\n    if (imageId === undefined) {\n      throw new Error('getImage: imageId must not be undefined');\n    }\n\n    const cachedImage = this._imageCache.get(imageId);\n\n    if (!cachedImage) {\n      return;\n    }\n\n    // Bump time stamp for cached volume (not used for anything for now)\n    cachedImage.timeStamp = Date.now();\n\n    return cachedImage.image;\n  };\n\n  /**\n   * Returns the volume associated with the volumeId\n   *\n   * @param volumeId - Volume ID\n   * @returns Volume\n   */\n  public getVolume = (volumeId: string): IImageVolume | undefined => {\n    if (volumeId === undefined) {\n      throw new Error('getVolume: volumeId must not be undefined');\n    }\n\n    const cachedVolume = this._volumeCache.get(volumeId);\n\n    if (!cachedVolume) {\n      return;\n    }\n\n    // Bump time stamp for cached volume (not used for anything for now)\n    cachedVolume.timeStamp = Date.now();\n\n    return cachedVolume.volume;\n  };\n\n  /**\n   * Retrieves an array of image volumes from the cache.\n   * @returns An array of image volumes.\n   */\n  public getVolumes = (): Array<IImageVolume> => {\n    const cachedVolumes = Array.from(this._volumeCache.values());\n\n    return cachedVolumes.map((cachedVolume) => cachedVolume.volume);\n  };\n\n  /**\n   * Filters the cached volumes by the specified reference volume ID.\n   * @param volumeId - The ID of the reference volume.\n   * @returns An array of image volumes that have the specified reference volume ID.\n   */\n  public filterVolumesByReferenceId = (\n    volumeId: string\n  ): Array<IImageVolume> => {\n    const cachedVolumes = this.getVolumes();\n\n    return cachedVolumes.filter((volume) => {\n      return volume.referencedVolumeId === volumeId;\n    });\n  };\n\n  /**\n   * Removes the image loader associated with a given Id from the cache\n   *\n   * It increases the cache size after removing the image.\n   *\n   * @fires Events.IMAGE_CACHE_IMAGE_REMOVED\n   *\n   * @param imageId - Image ID\n   */\n  public removeImageLoadObject = (imageId: string): void => {\n    if (imageId === undefined) {\n      throw new Error('removeImageLoadObject: imageId must not be undefined');\n    }\n\n    const cachedImage = this._imageCache.get(imageId);\n\n    if (!cachedImage) {\n      throw new Error(\n        'removeImageLoadObject: imageId was not present in imageCache'\n      );\n    }\n\n    this.incrementImageCacheSize(-cachedImage.sizeInBytes);\n\n    const eventDetails = {\n      image: cachedImage,\n      imageId,\n    };\n\n    triggerEvent(eventTarget, Events.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);\n    this._decacheImage(imageId);\n  };\n\n  /**\n   * Removes the volume loader associated with a given Id from the cache\n   *\n   * It increases the cache size after removing the image.\n   *\n   * @fires Events.VOLUME_CACHE_VOLUME_REMOVED\n   *\n   * @param imageId - ImageId\n   */\n  public removeVolumeLoadObject = (volumeId: string): void => {\n    if (volumeId === undefined) {\n      throw new Error('removeVolumeLoadObject: volumeId must not be undefined');\n    }\n\n    const cachedVolume = this._volumeCache.get(volumeId);\n\n    if (!cachedVolume) {\n      throw new Error(\n        'removeVolumeLoadObject: volumeId was not present in volumeCache'\n      );\n    }\n\n    this.incrementVolumeCacheSize(-cachedVolume.sizeInBytes);\n\n    const eventDetails = {\n      volume: cachedVolume,\n      volumeId,\n    };\n\n    triggerEvent(eventTarget, Events.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);\n    this._decacheVolume(volumeId);\n  };\n\n  putGeometryLoadObject = (\n    geometryId: string,\n    geometryLoadObject: IGeometryLoadObject\n  ): Promise<void> => {\n    if (geometryId == undefined) {\n      throw new Error(\n        'putGeometryLoadObject: geometryId must not be undefined'\n      );\n    }\n\n    if (this._geometryCache.has(geometryId)) {\n      throw new Error(\n        'putGeometryLoadObject: geometryId already present in geometryCache'\n      );\n    }\n\n    const cachedGeometry: ICachedGeometry = {\n      geometryId,\n      geometryLoadObject,\n      loaded: false,\n      timeStamp: Date.now(),\n      sizeInBytes: 0,\n    };\n\n    this._geometryCache.set(geometryId, cachedGeometry);\n\n    return geometryLoadObject.promise\n      .then((geometry: IGeometry) => {\n        if (!this._geometryCache.has(geometryId)) {\n          console.warn(\n            'putGeometryLoadObject: geometryId was removed from geometryCache'\n          );\n          return;\n        }\n\n        if (Number.isNaN(geometry.sizeInBytes)) {\n          throw new Error(\n            'putGeometryLoadObject: geometry.sizeInBytes is not a number'\n          );\n        }\n\n        // Todo: fix is cacheable\n\n        cachedGeometry.loaded = true;\n        cachedGeometry.geometry = geometry;\n        cachedGeometry.sizeInBytes = geometry.sizeInBytes;\n\n        // this._incrementGeometryCacheSize(geometry.sizeInBytes);\n\n        const eventDetails = {\n          geometry,\n          geometryId,\n        };\n\n        triggerEvent(\n          eventTarget,\n          Events.GEOMETRY_CACHE_GEOMETRY_ADDED,\n          eventDetails\n        );\n\n        return;\n      })\n      .catch((error) => {\n        this._geometryCache.delete(geometryId);\n        throw error;\n      });\n  };\n\n  /**\n   * Increases the image cache size with the provided increment\n   *\n   * @param increment - bytes length\n   */\n  public incrementImageCacheSize = (increment: number) => {\n    this._imageCacheSize += increment;\n  };\n\n  /**\n   * Increases the cache size with the provided increment\n   *\n   * @param increment - bytes length\n   */\n  public incrementVolumeCacheSize = (increment: number) => {\n    this._volumeCacheSize += increment;\n  };\n\n  /**\n   * Decreases the image cache size with the provided decrement\n   *\n   * @param decrement - bytes length\n   */\n  public decrementImageCacheSize = (decrement: number) => {\n    this._imageCacheSize -= decrement;\n  };\n\n  /**\n   * Decreases the cache size with the provided decrement\n   *\n   * @param decrement - bytes length\n   */\n  public decrementVolumeCacheSize = (decrement: number) => {\n    this._volumeCacheSize -= decrement;\n  };\n\n  /**\n   * This function will restore the images' pixel data from the shared array buffer\n   * back to the individual images when the volume is purged from cache. It ensures\n   * that each image retrieves its correct portion of data from the buffer based on\n   * the previously stored offset and length information.\n   *\n   * @param volumeId - The volumeId whose images need to be restored.\n   */\n  private _restoreImagesFromBuffer(volume: IImageVolume) {\n    if (!(volume instanceof ImageVolume)) {\n      console.warn(\n        'Volume is not an ImageVolume. Cannot restore images from buffer.'\n      );\n      return;\n    }\n\n    // Retrieve the scalar data and the offset map from the volume\n    const scalarData = volume.getScalarData();\n    const imageCacheOffsetMap = volume.imageCacheOffsetMap;\n\n    if (imageCacheOffsetMap.size === 0) {\n      // This happens during testing and isn't an issue\n      // console.warn('No cached images to restore for this volume.');\n      return;\n    }\n\n    // Iterate over each image and restore its pixel data from the shared buffer\n    for (const [imageId, { offset }] of imageCacheOffsetMap) {\n      const image = this.getImage(imageId);\n\n      if (!image) {\n        console.warn(`Image with id ${imageId} not found in cache.`);\n        continue;\n      }\n\n      const viewPixelData = image.getPixelData();\n      const length = viewPixelData.length;\n\n      // Create a new view of the buffer for this specific image\n      // @ts-ignore\n      const pixelData = new viewPixelData.constructor(\n        scalarData.buffer,\n        offset,\n        length\n      );\n\n      // Restore the original getPixelData function and pixelData\n      image.getPixelData = () => pixelData;\n\n      if (image.imageFrame) {\n        image.imageFrame.pixelData = pixelData;\n      }\n\n      delete image.bufferView;\n\n      // Optionally, increment the image cache size again if needed\n      this.incrementImageCacheSize(image.sizeInBytes);\n    }\n\n    console.log(`Images restored from buffer for volume ${volume.volumeId}.`);\n  }\n}\n\n/**\n * This module deals with Caching of images and volumes\n * The cache has two main components: a volatile portion for images and a\n * non-volatile portion for volumes. Individual 2D images are volatile and\n * will be replaced by new images hitting the cache. When you allocate volumes,\n * these are non-volatile and reserve a block of memory from the cache.\n * Volumes must be released manually.\n * We will have a shared block of memory allocated for the entire cache, e.g. 1GB\n * which will be shared for images and volumes.\n *\n * **When a new image is added:**\n * We check if there is enough unallocated + volatile space for the single image\n *\n * if so\n * - We allocate the image in image cache, and if necessary oldest images\n * are decached to match the maximumCacheSize criteria\n * - If a volume contains that imageId, copy it over using TypedArray's set method.\n * If no volumes contain the imageId, the image is fetched by image loaders\n *\n * If not (cache is mostly/completely full with volumes)\n * - throw that the cache does not have enough working space to allocate the image\n *\n *\n * **When a new volume is added:**\n * Check if there is enough unallocated + volatile space to allocate the volume:\n *\n * If so:\n * - Decache oldest images which won't be included in this volume until\n * we have enough free space for the volume\n * - If not enough space from previous space, decache images that will be included\n * in the volume until we have enough free space (These will need to be re-fetched,\n * but we must do this not to straddle over the given memory limit, even for a\n * short time, as this may crash the app)\n * - At this point, if any of the frames (indexed by imageId) are present in the volatile\n * image cache, copy these over to the volume now\n *\n * If not (cache is mostly/completely full with volumes),\n * - throw that the cache does not have enough working space to allocate the volume.\n *\n */\nconst cache = new Cache();\nexport default cache;\nexport { Cache }; // for documentation\n","const RENDERING_DEFAULTS = {\n  MINIMUM_SLAB_THICKNESS: 5e-2,\n  MAXIMUM_RAY_DISTANCE: 1e6,\n};\n\nObject.freeze(RENDERING_DEFAULTS);\n\nexport default RENDERING_DEFAULTS;\n","const EPSILON = 1e-3;\n\nexport default EPSILON;\n","/**\n * Request types for requesting images from the imageLoadPoolManager\n */\nenum RequestType {\n  /** Highest priority for loading*/\n  Interaction = 'interaction',\n  /** Second highest priority for loading*/\n  Thumbnail = 'thumbnail',\n  /** Third highest priority for loading, usually used for image loading in the background*/\n  Prefetch = 'prefetch',\n  /** Lower priority, often used for background computations in the worker */\n  Compute = 'compute',\n}\n\nexport default RequestType;\n","enum ViewportStatus {\n  /** Initial state before any volumes or stacks are available*/\n  NO_DATA = 'noData',\n  /** Stack/volumes are available but are in progress */\n  LOADING = 'loading',\n  /** Ready to be rendered */\n  PRE_RENDER = 'preRender',\n  /** In the midst of a resize */\n  RESIZE = 'resize',\n  /** Rendered image data */\n  RENDERED = 'rendered',\n}\n\nexport default ViewportStatus;\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\n\nconst { BlendMode } = vtkConstants;\n\n/**\n * Enums for blendModes for viewport images based on vtk.js\n *\n * It should be noted that if crosshairs are enabled and can modify the slab thickness,\n * then it will not show any difference unless MAXIMUM_INTENSITY_BLEND is set on the viewport\n * as the blend.\n */\nenum BlendModes {\n  /** composite blending - suitable for compositing multiple images */\n  COMPOSITE = BlendMode.COMPOSITE_BLEND,\n  /** maximum intensity projection */\n  MAXIMUM_INTENSITY_BLEND = BlendMode.MAXIMUM_INTENSITY_BLEND,\n  /** minimum intensity projection */\n  MINIMUM_INTENSITY_BLEND = BlendMode.MINIMUM_INTENSITY_BLEND,\n  /** average intensity projection */\n  AVERAGE_INTENSITY_BLEND = BlendMode.AVERAGE_INTENSITY_BLEND,\n}\n\nexport default BlendModes;\n","enum GeometryType {\n  CONTOUR = 'contour',\n  SURFACE = 'Surface',\n}\n\nexport default GeometryType;\n","/**\n * DynamicOperatorType enum for cornerstone-render which defines the operator to use for generateImageFromTimeData.\n * It can be either SUM, AVERAGE or SUBTRACT.\n */\nenum DynamicOperatorType {\n  /** For summing the time frames. */\n  SUM = 'SUM',\n  /** For averaging the time frames. */\n  AVERAGE = 'AVERAGE',\n  /** For subtracting two time frames */\n  SUBTRACT = 'SUBTRACT',\n}\n\nexport default DynamicOperatorType;\n","/**\n * Defines the calibration types available.  These define how the units\n * for measurements are specified.\n */\nexport enum CalibrationTypes {\n  /**\n   * Not applicable means the units are directly defind by the underlying\n   * hardware, such as CT and MR volumetric displays, so no special handling\n   * or notification is required.\n   */\n  NOT_APPLICABLE = '',\n  /**\n   * ERMF is estimated radiographic magnification factor.  This defines how\n   * much the image is magnified at the detector as opposed to the location in\n   * the body of interest.  This occurs because the radiation beam is expanding\n   * and effectively magnifies the image on the detector compared to where the\n   * point of interest in the body is.\n   * This suggests that measurements can be partially trusted, but the user\n   * still needs to be aware that different depths within the body have differing\n   * ERMF values, so precise measurements would still need to be manually calibrated.\n   */\n  ERMF = 'ERMF',\n  /**\n   * User calibration means that the user has provided a custom calibration\n   * specifying how large the image data is.  This type can occur on\n   * volumetric images, eg for scout images that might have invalid spacing\n   * tags.\n   */\n  USER = 'User',\n  /**\n   * A projection calibration means the raw detector size, without any\n   * ERMF applied, meaning that the size in the body cannot be trusted and\n   * that a calibration should be applied.\n   * This is different from Error in that there is simply no magnification\n   * factor applied as opposed to having multiple, inconsistent magnification\n   * factors.\n   */\n  PROJECTION = 'Proj',\n  /**\n   * A region calibration is used for other types of images, typically\n   * ultrasouunds where the distance in the image may mean something other than\n   * physical distance, such as mV or Hz or some other measurement values.\n   */\n  REGION = 'Region',\n  /**\n   * Error is used to define mismatches between various units, such as when\n   * there are two different ERMF values specified.  This is an indication to\n   * NOT trust the measurement values but to manually calibrate.\n   */\n  ERROR = 'Error',\n  /** Uncalibrated image */\n  UNCALIBRATED = 'Uncalibrated',\n}\n\nexport default CalibrationTypes;\n","import getRenderingEngine, {\n  getRenderingEngines,\n} from './RenderingEngine/getRenderingEngine';\nimport { IEnabledElement, IStackViewport, IVolumeViewport } from './types';\n\n/**\n * A convenience method to find an EnabledElement given a reference to its\n * associated element. Commonly used in code that's handling a custom\n * event emitted by this library.\n *\n * @example\n * Using the renderingEngine to find the enabled element:\n * ```javascript\n * const element = getRenderingEngine(renderingEngineId)\n *    .getViewport(viewportId)\n *    .element\n *\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @example\n * Using a cornerstone event's \"element\"\n * ```javascript\n * // Our \"cornerstone events\" contain the source element, which is\n * // raised on the viewport's div element\n * const { element } = evt.detail\n * const enabledElement = getEnabledElement(element)\n * ```\n *\n * @param element - a reference to an EnabledElement/Viewport's div element\n * @returns the associated EnabledElement, or undefined if no matching EnabledElement\n * can be found\n */\nexport default function getEnabledElement(\n  element: HTMLDivElement | undefined\n): IEnabledElement | undefined {\n  if (!element) {\n    return;\n  }\n\n  const { viewportUid, renderingEngineUid } = element.dataset;\n\n  return getEnabledElementByIds(viewportUid, renderingEngineUid);\n}\n\n/**\n * Similar to {@link getEnabledElement}, but takes the IDs of the\n * renderingEngine and viewport as parameters to return the associated\n * EnabledElement.\n *\n * @param viewportId - The Id of the viewport\n * @param renderingEngineId - The Id of the rendering engine.\n * @returns The enabled element which is an object that contains the viewport, rendering\n * engine, viewport Id, rendering engine Id, and the Frame of Reference UID.\n */\nexport function getEnabledElementByIds(\n  viewportId: string,\n  renderingEngineId: string\n): IEnabledElement {\n  if (!renderingEngineId || !viewportId) {\n    return;\n  }\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n    return;\n  }\n\n  const viewport = renderingEngine.getViewport(viewportId) as\n    | IStackViewport\n    | IVolumeViewport;\n\n  if (!viewport) {\n    return;\n  }\n\n  const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n  return {\n    viewport,\n    renderingEngine,\n    viewportId,\n    renderingEngineId,\n    FrameOfReferenceUID,\n  };\n}\n\n/**\n * Retrieves the enabled element by the specified viewport ID. it searches\n * through all the rendering engines to find the viewport with the specified\n *\n * @param viewportId - The ID of the viewport.\n * @returns The enabled element associated with the specified viewport ID.\n */\nexport function getEnabledElementByViewportId(viewportId: string) {\n  const renderingEngines = getRenderingEngines();\n\n  for (let i = 0; i < renderingEngines.length; i++) {\n    const renderingEngine = renderingEngines[i];\n    const viewport = renderingEngine.getViewport(viewportId);\n\n    if (viewport) {\n      return getEnabledElementByIds(viewportId, renderingEngine.id);\n    }\n  }\n}\n\n/**\n * Get all the enabled elements from all the rendering engines\n * @returns An array of enabled elements.\n */\nexport function getEnabledElements(): IEnabledElement[] {\n  const enabledElements = [];\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach(({ element }) => {\n      enabledElements.push(getEnabledElement(element));\n    });\n  });\n\n  return enabledElements;\n}\n","/*\n * Constants\n */\n\nconst DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\n\n/**\n * Settings\n */\nexport default class Settings {\n  constructor(base?: Settings) {\n    const dictionary = Object.create(\n      (base instanceof Settings && DICTIONARY in base\n        ? base[DICTIONARY]\n        : null) as object\n    );\n    Object.seal(\n      Object.defineProperty(this, DICTIONARY, {\n        value: dictionary,\n      })\n    );\n  }\n\n  set(key: string, value: unknown): boolean {\n    return set(this[DICTIONARY], key, value, null);\n  }\n\n  get(key: string): unknown {\n    return get(this[DICTIONARY], key);\n  }\n\n  /**\n   * Unset a specific key or a set of keys within a namespace when the key ends with a dot (ASCII #46).\n   * If the key is \".\", all keys will be removed and this command works as a reset.\n   * @param key - name The key to be unset or a namespace.\n   * @returns boolean\n   */\n  unset(key: string): boolean {\n    return unset(this[DICTIONARY], key + '');\n  }\n\n  forEach(callback: (key: string, value: unknown) => void): void {\n    iterate(this[DICTIONARY], callback);\n  }\n\n  extend(): Settings {\n    return new Settings(this);\n  }\n\n  /**\n   * Recursively import all properties from the given plain JavaScript object.\n   * This method has the opposite effect of the `dump` method.\n   * @param root - The root object whose properties will\n   * be imported.\n   */\n  import(root: Record<string, unknown>): void {\n    if (isPlainObject(root)) {\n      Object.keys(root).forEach((key) => {\n        set(this[DICTIONARY], key, root[key], null);\n      });\n    }\n  }\n\n  /**\n   * Build a JSON representation of the current internal state of this settings\n   * object. The returned object can be safely passed to `JSON.stringify`\n   * function.\n   * @returns The JSON representation of the current\n   * state of this settings instance\n   */\n  dump(): Record<string, unknown> {\n    const context = {};\n    iterate(this[DICTIONARY], (key, value) => {\n      if (typeof value !== 'undefined') {\n        deepSet(context, key, value);\n      }\n    });\n    return context;\n  }\n\n  static assert(subject: Settings): Settings {\n    return subject instanceof Settings\n      ? subject\n      : Settings.getRuntimeSettings();\n  }\n\n  static getDefaultSettings(subfield = null): Settings | any {\n    let defaultSettings = Settings[DEFAULT_SETTINGS];\n    if (!(defaultSettings instanceof Settings)) {\n      defaultSettings = new Settings();\n      Settings[DEFAULT_SETTINGS] = defaultSettings;\n    }\n\n    // Given subfield of 'segmentation' it will return all settings\n    // that starts with segmentation.*\n    if (subfield) {\n      const settingObj = {};\n      defaultSettings.forEach((name: string) => {\n        if (name.startsWith(subfield)) {\n          const setting = name.split(`${subfield}.`)[1];\n          settingObj[setting] = defaultSettings.get(name);\n        }\n      });\n      return settingObj;\n    }\n\n    return defaultSettings;\n  }\n\n  static getRuntimeSettings(): Settings {\n    let runtimeSettings = Settings[RUNTIME_SETTINGS];\n    if (!(runtimeSettings instanceof Settings)) {\n      runtimeSettings = new Settings(Settings.getDefaultSettings());\n      Settings[RUNTIME_SETTINGS] = runtimeSettings;\n    }\n    return runtimeSettings;\n  }\n\n  static getObjectSettings(subject: unknown, from?: unknown): Settings {\n    let settings = null;\n    if (subject instanceof Settings) {\n      settings = subject;\n    } else if (typeof subject === 'object' && subject !== null) {\n      let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n      if (!(objectSettingsMap instanceof WeakMap)) {\n        objectSettingsMap = new WeakMap();\n        Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n      }\n      settings = objectSettingsMap.get(subject);\n      if (!(settings instanceof Settings)) {\n        settings = new Settings(\n          Settings.assert(Settings.getObjectSettings(from))\n        );\n        objectSettingsMap.set(subject, settings);\n      }\n    }\n    return settings;\n  }\n\n  static extendRuntimeSettings(): Settings {\n    return Settings.getRuntimeSettings().extend();\n  }\n}\n\n/*\n * Local Helpers\n */\n\nfunction unset(dictionary: Record<string, unknown>, name: string): boolean {\n  if (name.endsWith('.')) {\n    let deleteCount = 0;\n    const namespace = name;\n    const base = namespace.slice(0, -1);\n    const deleteAll = base.length === 0;\n    for (const key in dictionary) {\n      if (\n        Object.prototype.hasOwnProperty.call(dictionary, key) &&\n        (deleteAll || key.startsWith(namespace) || key === base)\n      ) {\n        delete dictionary[key];\n        ++deleteCount;\n      }\n    }\n    return deleteCount > 0;\n  }\n  return delete dictionary[name];\n}\n\nfunction iterate(\n  dictionary: Record<string, unknown>,\n  callback: (key: string, value: unknown) => void\n): void {\n  for (const key in dictionary) {\n    callback(key, dictionary[key]);\n  }\n}\n\nfunction setAll(\n  dictionary: Record<string, unknown>,\n  prefix: string,\n  record: Record<string, unknown>,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  let failCount: number;\n  if (references.has(record)) {\n    return set(dictionary, prefix, null, references);\n  }\n  references.add(record);\n  failCount = 0;\n  for (const field in record) {\n    if (Object.prototype.hasOwnProperty.call(record, field)) {\n      const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n      if (!set(dictionary, key, record[field], references)) {\n        ++failCount;\n      }\n    }\n  }\n  references.delete(record);\n  return failCount === 0;\n}\n\n/**\n * Set the key-value pair on a given dictionary. If the given value is a\n * plain javascript object, every property of that object will also be set.\n * @param dictionary {Record<string, unknown>} The target dictionary\n * @param key {string} The given key\n * @param value {unknown} The given value\n * @param references {WeakSet<Record<string, unknown>>} references is a WeakSet\n *  instance used to keep track of which objects have already been iterated\n *  through preventing thus possible stack overflows caused by cyclic references\n * @returns {boolean} Returns true if every given key-value pair has been\n * successfully set\n */\nfunction set(\n  dictionary: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  references: WeakSet<Record<string, unknown>>\n): boolean {\n  if (isValidKey(key)) {\n    if (isPlainObject(value)) {\n      return setAll(\n        dictionary,\n        key,\n        value as Record<string, unknown>,\n        references instanceof WeakSet ? references : new WeakSet()\n      );\n    }\n    dictionary[key] = value;\n    return true;\n  }\n  return false;\n}\n\nfunction get(dictionary: Record<string, unknown>, key: string): unknown {\n  return dictionary[key];\n}\n\n/**\n * Make sure the -provided key correctly formatted.\n * e.g.:\n *  \"my.cool.property\" (valid)\n *  \"my.cool.property.\" (invalid)\n *  \".my.cool.property\" (invalid)\n *  \"my.cool..property\" (invalid)\n * @param key {string} The property name to be used as key within the internal\n *  dictionary\n * @returns {boolean} True on success, false otherwise\n */\nfunction isValidKey(key: string): boolean {\n  let last: number, current: number, previous: number;\n  if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n    return false;\n  }\n  previous = -1;\n  while ((current = key.indexOf('.', previous + 1)) >= 0) {\n    if (current - previous < 2 || current === last) {\n      return false;\n    }\n    previous = current;\n  }\n  return true;\n}\n\nfunction isPlainObject(subject: unknown) {\n  if (typeof subject === 'object' && subject !== null) {\n    const prototype = Object.getPrototypeOf(subject);\n    if (prototype === Object.prototype || prototype === null) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction deepSet(context, key, value) {\n  const separator = key.indexOf('.');\n  if (separator >= 0) {\n    const subKey = key.slice(0, separator);\n    let subContext = context[subKey];\n    if (typeof subContext !== 'object' || subContext === null) {\n      const subContextValue = subContext;\n      subContext = {};\n      if (typeof subContextValue !== 'undefined') {\n        subContext[''] = subContextValue;\n      }\n      context[subKey] = subContext;\n    }\n    deepSet(subContext, key.slice(separator + 1, key.length), value);\n  } else {\n    context[key] = value;\n  }\n}\n\n/**\n * Initial Settings for the repository\n */\nSettings.getDefaultSettings().set('useCursors', true);\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport {\n  genericMetadataProvider,\n  getBufferConfiguration,\n  triggerEvent,\n  uuidv4,\n} from '../utilities';\nimport {\n  IImage,\n  ImageLoaderFn,\n  IImageLoadObject,\n  EventTypes,\n  Point2,\n  Point3,\n  Mat3,\n  PixelDataTypedArrayString,\n  PixelDataTypedArray,\n} from '../types';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport { metaData } from '../';\n\nexport interface ImageLoaderOptions {\n  priority: number;\n  requestType: string;\n  additionalDetails?: Record<string, unknown>;\n  ignoreCache?: boolean;\n}\n\ninterface DerivedImages {\n  imageIds: Array<string>;\n  promises: Array<Promise<IImage>>;\n}\n\ntype LocalImageOptions = {\n  scalarData?: PixelDataTypedArray;\n  targetBufferType?: PixelDataTypedArrayString;\n  dimensions?: Point2;\n  spacing?: Point3;\n  origin?: Point3;\n  direction?: Mat3;\n  /**\n   * Skip creation of the actual buffer object.\n   * In fact, this creates a very short buffer, as there are lots of places\n   * assuming a buffer exists.\n   * This can be used when there are alternative representations of the image data.\n   */\n  skipCreateBuffer?: boolean;\n  /**\n   * A method to call to update the image object when it gets added to the cache.\n   * This can be used to create alternative representations of the image data,\n   * such as a VoxelManager.\n   */\n  onCacheAdd?: (image: IImage) => void;\n};\n\ntype DerivedImageOptions = LocalImageOptions & {\n  imageId?: string;\n  targetBufferType?: PixelDataTypedArrayString;\n};\n\n/**\n * This module deals with ImageLoaders, loading images and caching images\n */\nconst imageLoaders = {};\nlet unknownImageLoader;\n\n/**\n * Loads an image using a registered Cornerstone Image Loader.\n *\n * The image loader that is used will be\n * determined by the image loader scheme matching against the imageId.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param Options - to be passed to the Image Loader\n *\n * @returns - An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromImageLoader(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  // Extract the image loader scheme: wadors:https://image1 => wadors\n  const colonIndex = imageId.indexOf(':');\n  const scheme = imageId.substring(0, colonIndex);\n  const loader = imageLoaders[scheme];\n  if (loader === undefined || loader === null) {\n    if (unknownImageLoader !== undefined) {\n      return unknownImageLoader(imageId);\n    }\n    throw new Error('loadImageFromImageLoader: no image loader for imageId');\n  }\n  // Load using the registered loader\n  const imageLoadObject = loader(imageId, options);\n  // Broadcast an image loaded event once the image is loaded\n  imageLoadObject.promise.then(\n    function (image) {\n      triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    },\n    function (error) {\n      const errorObject: EventTypes.ImageLoadedFailedEventDetail = {\n        imageId,\n        error,\n      };\n      triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorObject);\n    }\n  );\n  return imageLoadObject;\n}\n\n/**\n * Gets the imageLoadObject by 1) Looking in to the cache to see if the\n * imageLoadObject has already been cached, 2) Checks inside the volume cache\n * to see if there is a volume that contains the same imageURI for the requested\n * imageID 3) Checks inside the imageCache for similar imageURI that might have\n * been stored as a result of decaching a volume 4) Finally if none were found\n * it request it from the registered imageLoaders.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nfunction loadImageFromCacheOrVolume(\n  imageId: string,\n  options: ImageLoaderOptions\n): IImageLoadObject {\n  if (options.ignoreCache) {\n    return loadImageFromImageLoader(imageId, options);\n  }\n\n  // 1. Check inside the image cache for imageId\n  let imageLoadObject = cache.getImageLoadObject(imageId);\n  if (imageLoadObject !== undefined) {\n    return imageLoadObject;\n  }\n  // 2. Check if there exists a volume in the cache containing the imageId,\n  // we copy the pixelData over.\n  const cachedVolumeInfo = cache.getVolumeContainingImageId(imageId);\n  if (cachedVolumeInfo?.volume?.loadStatus?.loaded) {\n    // 2.1 Convert the volume at the specific slice to a cornerstoneImage object.\n    // this will copy the pixel data over.\n    const { volume, imageIdIndex } = cachedVolumeInfo;\n\n    if (volume instanceof ImageVolume) {\n      imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);\n    }\n    return imageLoadObject;\n  }\n  // 3. If no volume found, we search inside the imageCache for the imageId\n  // that has the same URI which had been cached if the volume was converted\n  // to an image\n  const cachedImage = cache.getCachedImageBasedOnImageURI(imageId);\n  if (cachedImage) {\n    imageLoadObject = cachedImage.imageLoadObject;\n    return imageLoadObject;\n  }\n  // 4. if not in image cache nor inside the volume cache, we request the\n  // image loaders to load it\n  imageLoadObject = loadImageFromImageLoader(imageId, options);\n\n  return imageLoadObject;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The loaded image is not stored in the cache.\n *\n *\n * @param imageId - A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error('loadImage: parameter imageId must not be undefined');\n  }\n\n  return loadImageFromCacheOrVolume(imageId, options).promise;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param imageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function loadAndCacheImage(\n  imageId: string,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage> {\n  if (imageId === undefined) {\n    throw new Error(\n      'loadAndCacheImage: parameter imageId must not be undefined'\n    );\n  }\n  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);\n\n  // if not inside cache, store it\n  if (!cache.getImageLoadObject(imageId)) {\n    cache.putImageLoadObject(imageId, imageLoadObject).catch((err) => {\n      console.warn(err);\n    });\n  }\n\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param imageIds - list of imageIds\n * @param options - options for loader\n *\n */\nexport function loadAndCacheImages(\n  imageIds: Array<string>,\n  options: ImageLoaderOptions = { priority: 0, requestType: 'prefetch' }\n): Promise<IImage>[] {\n  if (!imageIds || imageIds.length === 0) {\n    throw new Error(\n      'loadAndCacheImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const allPromises = imageIds.map((imageId) => {\n    return loadAndCacheImage(imageId, options);\n  });\n\n  return allPromises;\n}\n\n/**\n * Loads an image given an imageId and optional priority and returns a promise\n * which will resolve to the loaded image object or fail if an error occurred.\n * The image is stored in the cache.\n *\n * @param referencedImageId -  A Cornerstone Image Object's imageId\n * @param options - Options to be passed to the Image Loader\n *\n * @returns Image Loader Object\n */\nexport function createAndCacheDerivedImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {},\n  preventCache = false\n): Promise<IImage> {\n  if (referencedImageId === undefined) {\n    throw new Error(\n      'createAndCacheDerivedImage: parameter imageId must not be undefined'\n    );\n  }\n\n  if (options.imageId === undefined) {\n    options.imageId = `derived:${uuidv4()}`;\n  }\n\n  const { imageId, skipCreateBuffer, onCacheAdd } = options;\n\n  const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const { TypedArrayConstructor } = getBufferConfiguration(\n    options.targetBufferType,\n    length\n  );\n\n  // Use a buffer of size 1 for no data\n  const imageScalarData = new TypedArrayConstructor(\n    skipCreateBuffer ? 1 : length\n  );\n  const derivedImageId = imageId;\n\n  ['imagePlaneModule', 'generalSeriesModule'].forEach((type) => {\n    genericMetadataProvider.add(derivedImageId, {\n      type,\n      metadata: metaData.get(type, referencedImageId),\n    });\n  });\n\n  const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n  // TODO - add a general way to specify this\n  genericMetadataProvider.add(derivedImageId, {\n    type: 'imagePixelModule',\n    metadata: {\n      ...imagePixelModule,\n      bitsAllocated: 8,\n      bitsStored: 8,\n      highBit: 7,\n      samplesPerPixel: 1,\n      pixelRepresentation: 0,\n    },\n  });\n\n  const localImage = createAndCacheLocalImage(\n    { scalarData: imageScalarData, onCacheAdd, skipCreateBuffer },\n    imageId,\n    true\n  );\n\n  const imageLoadObject = {\n    promise: Promise.resolve(localImage),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(derivedImageId, imageLoadObject);\n  }\n  return imageLoadObject.promise;\n}\n\n/**\n * Load and cache a list of imageIds\n *\n * @param referencedImageIds - list of imageIds\n * @param options\n * @param options.getDerivedImageId - function to get the derived imageId\n * @param options.targetBufferType - target buffer type\n * @param options.skipBufferCreate - avoid creating the buffer\n */\nexport function createAndCacheDerivedImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions & {\n    getDerivedImageId?: (referencedImageId: string) => string;\n    targetBufferType?: PixelDataTypedArrayString;\n  } = {}\n): DerivedImages {\n  if (referencedImageIds?.length === 0) {\n    throw new Error(\n      'createAndCacheDerivedImages: parameter imageIds must be list of image Ids'\n    );\n  }\n\n  const derivedImageIds = [];\n  const allPromises = referencedImageIds.map((referencedImageId) => {\n    const newOptions: DerivedImageOptions = {\n      imageId:\n        options.getDerivedImageId?.(referencedImageId) || `derived:${uuidv4()}`,\n      ...options,\n    };\n    derivedImageIds.push(newOptions.imageId);\n    return createAndCacheDerivedImage(referencedImageId, newOptions);\n  });\n\n  return { imageIds: derivedImageIds, promises: allPromises };\n}\n\nexport function createAndCacheLocalImage(\n  options: LocalImageOptions,\n  imageId: string,\n  preventCache = false\n): IImage {\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n  const length = imagePlaneModule.rows * imagePlaneModule.columns;\n\n  const image = {\n    imageId: imageId,\n    intercept: 0,\n    windowCenter: 0,\n    windowWidth: 0,\n    color: false,\n    numComps: 1,\n    slope: 1,\n    minPixelValue: 0,\n    maxPixelValue: 255,\n    voiLUTFunction: undefined,\n    rows: imagePlaneModule.rows,\n    columns: imagePlaneModule.columns,\n    getCanvas: undefined, // todo: which canvas?\n    height: imagePlaneModule.rows,\n    width: imagePlaneModule.columns,\n    rgba: undefined, // todo: how\n    columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n    rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n    invert: false,\n  } as IImage;\n\n  if (options.scalarData) {\n    const imageScalarData = options.scalarData;\n\n    if (\n      !(\n        imageScalarData instanceof Uint8Array ||\n        imageScalarData instanceof Float32Array ||\n        imageScalarData instanceof Uint16Array ||\n        imageScalarData instanceof Int16Array\n      )\n    ) {\n      throw new Error(\n        'To use createLocalVolume you should pass scalarData of type Uint8Array, Uint16Array, Int16Array or Float32Array'\n      );\n    }\n\n    image.sizeInBytes = imageScalarData.byteLength;\n    image.getPixelData = () => imageScalarData;\n  } else if (options.skipCreateBuffer !== true) {\n    const { numBytes, TypedArrayConstructor } = getBufferConfiguration(\n      options.targetBufferType,\n      length\n    );\n\n    const imageScalarData = new TypedArrayConstructor(length);\n\n    image.sizeInBytes = numBytes;\n    image.getPixelData = () => imageScalarData;\n  }\n\n  // The onCacheAdd may modify the size in bytes for this image, which is ok,\n  // as this is used after resolution for cache storage.  It may also do\n  // thinks like adding alternative representations such as VoxelManager\n  options.onCacheAdd?.(image);\n\n  const imageLoadObject = {\n    promise: Promise.resolve(image),\n  };\n\n  if (!preventCache) {\n    cache.putImageLoadObject(image.imageId, imageLoadObject);\n  }\n\n  return image;\n}\n\n/**\n * Removes the imageId from the request pool manager and executes the `cancel`\n * function if it exists.\n *\n * @param imageId - A Cornerstone Image Object's imageId\n *\n */\nexport function cancelLoadImage(imageId: string): void {\n  const filterFunction = ({ additionalDetails }) => {\n    if (additionalDetails.imageId) {\n      return additionalDetails.imageId !== imageId;\n    }\n\n    // for volumes\n    return true;\n  };\n\n  // Instruct the request pool manager to filter queued\n  // requests to ensure requests we no longer need are\n  // no longer sent.\n  imageLoadPoolManager.filterRequests(filterFunction);\n\n  // TODO: Cancel decoding and retrieval as well (somehow?)\n\n  // cancel image loading if in progress\n  const imageLoadObject = cache.getImageLoadObject(imageId);\n\n  if (imageLoadObject) {\n    imageLoadObject.cancelFn();\n  }\n}\n\n/**\n * Removes the imageIds from the request pool manager and calls the `cancel`\n * function if it exists.\n *\n * @param imageIds - Array of Cornerstone Image Object's imageIds\n *\n */\nexport function cancelLoadImages(imageIds: Array<string>): void {\n  imageIds.forEach((imageId) => cancelLoadImage(imageId));\n}\n\n/**\n * Removes all the ongoing image loads by calling the `cancel` method on each\n * imageLoadObject. If no `cancel` method is available, it will be ignored.\n *\n */\nexport function cancelLoadAll(): void {\n  const requestPool = imageLoadPoolManager.getRequestPool();\n\n  Object.keys(requestPool).forEach((type: string) => {\n    const requests = requestPool[type];\n\n    Object.keys(requests).forEach((priority) => {\n      const requestDetails = requests[priority].pop();\n      const additionalDetails = requestDetails.additionalDetails as any;\n      const { imageId, volumeId } = additionalDetails;\n\n      let loadObject;\n\n      if (imageId) {\n        loadObject = cache.getImageLoadObject(imageId);\n      } else if (volumeId) {\n        loadObject = cache.getVolumeLoadObject(volumeId);\n      }\n      if (loadObject) {\n        loadObject.cancel();\n      }\n    });\n    // resetting the pool types to be empty\n    imageLoadPoolManager.clearRequestStack(type);\n\n    // TODO: Clear retrieval and decoding queues as well\n  });\n}\n\n/**\n * Registers an imageLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this image loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param imageLoader - A Cornerstone Image Loader function\n */\nexport function registerImageLoader(\n  scheme: string,\n  imageLoader: ImageLoaderFn\n): void {\n  imageLoaders[scheme] = imageLoader;\n}\n/**\n * Registers a new unknownImageLoader and returns the previous one\n *\n * @param imageLoader - A Cornerstone Image Loader\n *\n * @returns The previous Unknown Image Loader\n */\nexport function registerUnknownImageLoader(\n  imageLoader: ImageLoaderFn\n): ImageLoaderFn {\n  const oldImageLoader = unknownImageLoader;\n  unknownImageLoader = imageLoader;\n  return oldImageLoader;\n}\n/**\n * Removes all registered and unknown image loaders. This should be called\n * when the application is unmounted to prevent memory leaks.\n *\n */\nexport function unregisterAllImageLoaders(): void {\n  Object.keys(imageLoaders).forEach(\n    (imageLoader) => delete imageLoaders[imageLoader]\n  );\n  unknownImageLoader = undefined;\n}\n\n/**\n * Creates and caches derived segmentation images based on the referenced imageIds, this\n * is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageIds - An array of referenced image IDs.\n * @param options - The options for creating the derived images (default: { targetBufferType: 'Uint8Array' }).\n * @returns The derived images.\n */\nexport function createAndCacheDerivedSegmentationImages(\n  referencedImageIds: Array<string>,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): DerivedImages {\n  return createAndCacheDerivedImages(referencedImageIds, options);\n}\n\n/**\n * Creates and caches a derived segmentation image based on the referenced image ID.\n * this is a helper function, we don't have segmentation concept in the cornerstone core; however,\n * this helper would make it clear that the segmentation images SHOULD be Uint8Array type\n * always until we have a better solution.\n *\n * @param referencedImageId The ID of the referenced image.\n * @param options The options for creating the derived image (default: { targetBufferType: 'Uint8Array' }).\n * @returns A promise that resolves to the created derived segmentation image.\n */\nexport function createAndCacheDerivedSegmentationImage(\n  referencedImageId: string,\n  options: DerivedImageOptions = {\n    targetBufferType: 'Uint8Array',\n  }\n): Promise<IImage> {\n  return createAndCacheDerivedImage(referencedImageId, options);\n}\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\n\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport type { vtkImageData as vtkImageDataType } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\n\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport triggerEvent from '../utilities/triggerEvent';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport {\n  createUint16SharedArray,\n  createUint8SharedArray,\n  createFloat32SharedArray,\n  generateVolumePropsFromImageIds,\n  getBufferConfiguration,\n  uuidv4,\n} from '../utilities';\nimport {\n  Point3,\n  Metadata,\n  EventTypes,\n  Mat3,\n  IImageVolume,\n  VolumeLoaderFn,\n  IDynamicImageVolume,\n  PixelDataTypedArray,\n  IVolumeLoadObject,\n  PixelDataTypedArrayString,\n} from '../types';\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\nimport {\n  performCacheOptimizationForVolume,\n  setupCacheOptimizationEventListener,\n} from '../utilities/cacheUtils';\n\ninterface VolumeLoaderOptions {\n  imageIds: Array<string>;\n}\n\ninterface DerivedVolumeOptions {\n  volumeId: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\ninterface LocalVolumeOptions {\n  metadata: Metadata;\n  dimensions: Point3;\n  spacing: Point3;\n  origin: Point3;\n  direction: Mat3;\n  scalarData?: PixelDataTypedArray;\n  imageIds?: Array<string>;\n  referencedImageIds?: Array<string>;\n  referencedVolumeId?: string;\n  targetBuffer?: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  };\n}\n\n/**\n * Adds a single scalar data to a 3D volume\n */\nfunction addScalarDataToImageData(\n  imageData: vtkImageDataType,\n  scalarData: PixelDataTypedArray,\n  dataArrayAttrs\n) {\n  const scalarArray = vtkDataArray.newInstance({\n    name: `Pixels`,\n    values: scalarData,\n    ...dataArrayAttrs,\n  });\n\n  imageData.getPointData().setScalars(scalarArray);\n}\n\n/**\n * Adds multiple scalar data (time points) to a 4D volume\n */\nfunction addScalarDataArraysToImageData(\n  imageData: vtkImageDataType,\n  scalarDataArrays: PixelDataTypedArray[],\n  dataArrayAttrs\n) {\n  scalarDataArrays.forEach((scalarData, i) => {\n    const vtkScalarArray = vtkDataArray.newInstance({\n      name: `timePoint-${i}`,\n      values: scalarData,\n      ...dataArrayAttrs,\n    });\n\n    imageData.getPointData().addArray(vtkScalarArray);\n  });\n\n  // Set the first as active otherwise nothing is displayed on the screen\n  imageData.getPointData().setActiveScalars('timePoint-0');\n}\n\nfunction createInternalVTKRepresentation(\n  volume: IImageVolume\n): vtkImageDataType {\n  const { dimensions, metadata, spacing, direction, origin } = volume;\n  const { PhotometricInterpretation } = metadata;\n\n  let numComponents = 1;\n  if (PhotometricInterpretation === 'RGB') {\n    numComponents = 3;\n  }\n\n  const imageData = vtkImageData.newInstance();\n  const dataArrayAttrs = { numberOfComponents: numComponents };\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n\n  // Add scalar data to 3D or 4D volume\n  if (volume.isDynamicVolume()) {\n    const scalarDataArrays = (<IDynamicImageVolume>(\n      volume\n    )).getScalarDataArrays();\n\n    addScalarDataArraysToImageData(imageData, scalarDataArrays, dataArrayAttrs);\n  } else {\n    const scalarData = volume.getScalarData();\n\n    addScalarDataToImageData(imageData, scalarData, dataArrayAttrs);\n  }\n\n  return imageData;\n}\n\n/**\n * This module deals with VolumeLoaders and loading volumes\n */\n\nconst volumeLoaders = {};\n\nlet unknownVolumeLoader;\n\n/**\n * Load a volume using a registered Cornerstone Volume Loader.\n *\n * The volume loader that is used will be\n * determined by the volume loader scheme matching against the volumeId.\n *\n * @param volumeId - A Cornerstone Volume Object's volumeId\n * @param options - Options to be passed to the Volume Loader. Options\n * contain the ImageIds that is passed to the loader\n *\n * @returns An Object which can be used to act after a volume is loaded or loading fails\n *\n */\nfunction loadVolumeFromVolumeLoader(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): IVolumeLoadObject {\n  const colonIndex = volumeId.indexOf(':');\n  const scheme = volumeId.substring(0, colonIndex);\n  let loader = volumeLoaders[scheme];\n\n  if (loader === undefined || loader === null) {\n    if (\n      unknownVolumeLoader == null ||\n      typeof unknownVolumeLoader !== 'function'\n    ) {\n      throw new Error(\n        `No volume loader for scheme ${scheme} has been registered`\n      );\n    }\n\n    loader = unknownVolumeLoader;\n  }\n\n  const volumeLoadObject = loader(volumeId, options);\n\n  setupCacheOptimizationEventListener(volumeId);\n\n  // Broadcast a volume loaded event once the image is loaded\n  volumeLoadObject.promise.then(\n    function (volume) {\n      triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\n    },\n    function (error) {\n      const errorObject: EventTypes.VolumeLoadedFailedEventDetail = {\n        volumeId,\n        error,\n      };\n\n      triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\n    }\n  );\n\n  return volumeLoadObject;\n}\n\n/**\n * Loads a volume given a volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred.  The loaded image is not stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns An Object which can be used to act after an image is loaded or loading fails\n */\nexport function loadVolume(\n  volumeId: string,\n  options: VolumeLoaderOptions = { imageIds: [] }\n): Promise<IImageVolume> {\n  if (volumeId === undefined) {\n    throw new Error('loadVolume: parameter volumeId must not be undefined');\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  return volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n    return volume;\n  });\n}\n\n/**\n * Loads an image given an volumeId and optional priority and returns a promise which will resolve to\n * the loaded image object or fail if an error occurred. The image is stored in the cache.\n *\n * @param volumeId - A Cornerstone Image Object's volumeId\n * @param options - Options to be passed to the Volume Loader\n *\n * @returns Volume Loader Object\n */\nexport async function createAndCacheVolume(\n  volumeId: string,\n  options?: VolumeLoaderOptions\n): Promise<Record<string, any>> {\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolume: parameter volumeId must not be undefined'\n    );\n  }\n\n  let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n\n  if (volumeLoadObject !== undefined) {\n    return volumeLoadObject.promise;\n  }\n\n  volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n\n  volumeLoadObject.promise.then((volume: IImageVolume) => {\n    volume.imageData = createInternalVTKRepresentation(volume);\n  });\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject).catch((err) => {\n    throw err;\n  });\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Based on a referencedVolumeId, it will build and cache a new volume. If\n * no scalarData is specified in the options, an empty derived volume will be\n * created that matches the image metadata of the referenceVolume. If scalarData\n * is given, it will be used to generate the intensity values for the derivedVolume.\n * Finally, it will save the volume in the cache.\n * @param referencedVolumeId - the volumeId from which the new volume will get its metadata\n * @param options - DerivedVolumeOptions {uid: derivedVolumeUID, targetBuffer: { type: Float32Array | Uint8Array |\n * Uint16Array | Uint32Array  }, scalarData: if provided}\n *\n * @returns ImageVolume\n */\nexport async function createAndCacheDerivedVolume(\n  referencedVolumeId: string,\n  options: DerivedVolumeOptions\n): Promise<IImageVolume> {\n  const referencedVolume = cache.getVolume(referencedVolumeId);\n  if (!referencedVolume) {\n    throw new Error(\n      `Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`\n    );\n  }\n\n  let { volumeId } = options;\n  const { targetBuffer } = options;\n\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\n  const scalarData = referencedVolume.getScalarData();\n  const scalarLength = scalarData.length;\n\n  const { volumeScalarData, numBytes } = generateVolumeScalarData(\n    targetBuffer,\n    scalarLength\n  );\n\n  // Todo: handle more than one component for segmentation (RGB)\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: volumeScalarData,\n  });\n\n  const derivedImageData = vtkImageData.newInstance();\n\n  derivedImageData.setDimensions(dimensions);\n  derivedImageData.setSpacing(spacing);\n  derivedImageData.setDirection(direction);\n  derivedImageData.setOrigin(origin);\n  derivedImageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: derivedImageData,\n    scalarData: volumeScalarData,\n    sizeInBytes: numBytes,\n    imageIds: [],\n    referencedVolumeId,\n  });\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n\n  await cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\n/**\n * Creates and cache a volume based on a set of provided properties including\n * dimensions, spacing, origin, direction, metadata, scalarData. It should be noted that\n * scalarData should be provided for this function to work. If a volume with the same\n * Id exists in the cache it returns it immediately.\n * @param options -  { scalarData, metadata, dimensions, spacing, origin, direction }\n * @param volumeId - Id of the generated volume\n *\n * @returns ImageVolume\n */\nexport function createLocalVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): IImageVolume {\n  const { metadata, dimensions, spacing, origin, direction, targetBuffer } =\n    options;\n\n  let { scalarData } = options;\n\n  // Define the valid data types for scalarData\n  const validDataTypes = [\n    'Uint8Array',\n    'Float32Array',\n    'Uint16Array',\n    'Int16Array',\n  ];\n\n  const scalarLength = dimensions[0] * dimensions[1] * dimensions[2];\n\n  // Check if scalarData is provided and is of a valid type\n  if (!scalarData || !validDataTypes.includes(scalarData.constructor.name)) {\n    // Check if targetBuffer is provided and has a valid type\n    if (!targetBuffer?.type || !validDataTypes.includes(targetBuffer.type)) {\n      throw new Error(\n        'createLocalVolume: parameter scalarData must be provided and must be either Uint8Array, Float32Array, Uint16Array or Int16Array'\n      );\n    }\n\n    // Generate volume scalar data if scalarData is not provided or invalid\n    ({ volumeScalarData: scalarData } = generateVolumeScalarData(\n      targetBuffer,\n      scalarLength\n    ));\n  }\n\n  // Todo: handle default values for spacing, origin, direction if not provided\n  if (volumeId === undefined) {\n    volumeId = uuidv4();\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return cachedVolume as IImageVolume;\n  }\n\n  const numBytes = scalarData ? scalarData.buffer.byteLength : scalarLength * 4;\n\n  // check if there is enough space in unallocated + image Cache\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  const scalarArray = vtkDataArray.newInstance({\n    name: 'Pixels',\n    numberOfComponents: 1,\n    values: scalarData,\n  });\n\n  const imageData = vtkImageData.newInstance();\n\n  imageData.setDimensions(dimensions);\n  imageData.setSpacing(spacing);\n  imageData.setDirection(direction);\n  imageData.setOrigin(origin);\n  imageData.getPointData().setScalars(scalarArray);\n\n  const derivedVolume = new ImageVolume({\n    volumeId,\n    metadata: cloneDeep(metadata),\n    dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n    spacing,\n    origin,\n    direction,\n    imageData: imageData,\n    scalarData,\n    sizeInBytes: numBytes,\n    referencedImageIds: options.referencedImageIds || [],\n    referencedVolumeId: options.referencedVolumeId,\n    imageIds: options.imageIds || [],\n  });\n\n  if (preventCache) {\n    return derivedVolume;\n  }\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(derivedVolume),\n  };\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return derivedVolume;\n}\n\nexport async function createAndCacheVolumeFromImages(\n  volumeId: string,\n  imageIds: string[],\n  options: {\n    preventCache?: boolean;\n    additionalDetails?: Record<string, any>;\n  } = {}\n): Promise<IImageVolume> {\n  const { preventCache = false } = options;\n\n  if (imageIds === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter imageIds must not be undefined'\n    );\n  }\n\n  if (volumeId === undefined) {\n    throw new Error(\n      'createAndCacheVolumeFromImages: parameter volumeId must not be undefined'\n    );\n  }\n\n  const cachedVolume = cache.getVolume(volumeId);\n\n  if (cachedVolume) {\n    return Promise.resolve(cachedVolume);\n  }\n\n  const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\n\n  // volume is an empty volume, we need to load the data from the imageIds\n  // into the volume scalarData\n\n  // it is important to get the imageIds from the volumeProps\n  // since they are sorted\n  const imagePromises = volumeProps.imageIds.map((imageId, imageIdIndex) => {\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n\n    return imageLoadObject.promise.then((image) => {\n      const pixelData = image.getPixelData();\n      const offset = imageIdIndex * image.rows * image.columns;\n\n      (volumeProps.scalarData as PixelDataTypedArray).set(pixelData, offset);\n    });\n  });\n\n  await Promise.all(imagePromises);\n\n  const volume = new ImageVolume({\n    ...volumeProps,\n    referencedImageIds: imageIds,\n    ...options,\n  });\n\n  // since we generated the volume from images, we can optimize the cache\n  // by replacing the pixelData of the images with a view of the volume's\n  // scalarData\n  performCacheOptimizationForVolume(volume);\n\n  const volumeLoadObject = {\n    promise: Promise.resolve(volume),\n  };\n\n  if (preventCache) {\n    return volumeLoadObject.promise;\n  }\n\n  cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n\n  return volumeLoadObject.promise;\n}\n\n/**\n * Registers an volumeLoader plugin with cornerstone for the specified scheme\n *\n * @param scheme - The scheme to use for this volume loader (e.g. 'dicomweb', 'wadouri', 'http')\n * @param volumeLoader - A Cornerstone Volume Loader function\n */\nexport function registerVolumeLoader(\n  scheme: string,\n  volumeLoader: VolumeLoaderFn\n): void {\n  volumeLoaders[scheme] = volumeLoader;\n}\n\n/** Gets the array of volume loader schemes */\nexport function getVolumeLoaderSchemes(): string[] {\n  return Object.keys(volumeLoaders);\n}\n\n/**\n * Registers a new unknownVolumeLoader and returns the previous one\n *\n * @param volumeLoader - A Cornerstone Volume Loader\n *\n * @returns The previous Unknown Volume Loader\n */\nexport function registerUnknownVolumeLoader(\n  volumeLoader: VolumeLoaderFn\n): VolumeLoaderFn | undefined {\n  const oldVolumeLoader = unknownVolumeLoader;\n\n  unknownVolumeLoader = volumeLoader;\n\n  return oldVolumeLoader;\n}\n\nexport function getUnknownVolumeLoaderSchema(): string {\n  return unknownVolumeLoader.name;\n}\n\n/**\n * Creates and caches a derived segmentation volume based on a referenced volume.\n * This is basically a utility method since for the segmentations we have to specify\n * Uint8Array as the targetBuffer type for now until we support other types.\n *\n * @param referencedVolumeId - The ID of the referenced volume.\n * @param options - The options for creating the derived volume.\n * @returns A promise that resolves to the created derived segmentation volume.\n */\nexport async function createAndCacheDerivedSegmentationVolume(\n  referencedVolumeId: string,\n  options = {} as DerivedVolumeOptions\n): Promise<IImageVolume> {\n  return createAndCacheDerivedVolume(referencedVolumeId, {\n    ...options,\n    targetBuffer: {\n      type: 'Uint8Array',\n    },\n  });\n}\n\n/**\n * Creates a local segmentation volume.\n *\n * @param options - The options for creating the volume.\n * @param volumeId - The ID of the volume.\n * @param preventCache - Whether to prevent caching the volume.\n * @returns A promise that resolves to the created image volume.\n */\nexport async function createLocalSegmentationVolume(\n  options: LocalVolumeOptions,\n  volumeId: string,\n  preventCache = false\n): Promise<IImageVolume> {\n  if (!options.scalarData) {\n    options.scalarData = new Uint8Array(\n      options.dimensions[0] * options.dimensions[1] * options.dimensions[2]\n    );\n  }\n\n  return createLocalVolume(options, volumeId, preventCache);\n}\n\n/**\n * This function generates volume scalar data based on the provided target buffer and scalar length.\n * It checks if the cache can accommodate the data size and throws an error if it exceeds the cache size.\n * If a shared array buffer is available in the target buffer, it uses that to create the typed array.\n * Otherwise, it creates a typed array based on the scalar length.\n *\n * @param targetBuffer - The target buffer object which may contain a type and a shared array buffer.\n * @param scalarLength - The scalar length for creating the typed array.\n * @param useNorm16Texture - A flag to specify whether to use a 16-bit texture or not.\n * @returns The volume scalar data as a typed array.\n */\nfunction generateVolumeScalarData(\n  targetBuffer: {\n    type: PixelDataTypedArrayString;\n    sharedArrayBuffer?: boolean;\n  },\n  scalarLength: number\n) {\n  const { useNorm16Texture } = getConfiguration().rendering;\n\n  const { TypedArrayConstructor, numBytes } = getBufferConfiguration(\n    targetBuffer?.type,\n    scalarLength,\n    {\n      use16BitTexture: useNorm16Texture,\n      isVolumeBuffer: true,\n    }\n  );\n\n  const isCacheable = cache.isCacheable(numBytes);\n  if (!isCacheable) {\n    throw new Error(Events.CACHE_SIZE_EXCEEDED);\n  }\n\n  let volumeScalarData;\n  if (targetBuffer?.sharedArrayBuffer ?? getShouldUseSharedArrayBuffer()) {\n    switch (targetBuffer.type) {\n      case 'Float32Array':\n        volumeScalarData = createFloat32SharedArray(scalarLength);\n        break;\n      case 'Uint8Array':\n        volumeScalarData = createUint8SharedArray(scalarLength);\n        break;\n      case 'Uint16Array':\n        volumeScalarData = createUint16SharedArray(scalarLength);\n        break;\n      case 'Int16Array':\n        volumeScalarData = createUint16SharedArray(scalarLength);\n        break;\n      default:\n        throw new Error(\n          'generateVolumeScalarData: SharedArrayBuffer is not supported for the specified target buffer type'\n        );\n    }\n  } else {\n    volumeScalarData = new TypedArrayConstructor(scalarLength);\n  }\n\n  return { volumeScalarData, numBytes };\n}\n","// This module defines a way to access various metadata about an imageId.  This layer of abstraction exists\n// So metadata can be provided in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)\n\nconst providers = [];\n\n/**\n * Adds a metadata provider with the specified priority\n * @param provider - Metadata provider function\n * @param priority - 0 is default/normal, > 0 is high, < 0 is low\n *\n * @category MetaData\n */\nexport function addProvider(\n  provider: (type: string, ...query: string[]) => any,\n  priority = 0\n): void {\n  let i;\n\n  // Find the right spot to insert this provider based on priority\n  for (i = 0; i < providers.length; i++) {\n    if (providers[i].priority <= priority) {\n      break;\n    }\n  }\n\n  // Insert the decode task at position i\n  providers.splice(i, 0, {\n    priority,\n    provider,\n  });\n}\n\n/**\n * Removes the specified provider\n *\n * @param provider - Metadata provider function\n *\n * @category MetaData\n */\nexport function removeProvider(\n  provider: (type: string, query: any) => { any }\n): void {\n  for (let i = 0; i < providers.length; i++) {\n    if (providers[i].provider === provider) {\n      providers.splice(i, 1);\n\n      break;\n    }\n  }\n}\n\n/**\n * Removes all providers\n *\n * @category MetaData\n */\nexport function removeAllProviders(): void {\n  while (providers.length > 0) {\n    providers.pop();\n  }\n}\n\n/**\n * Gets metadata from the registered metadata providers.  Will call each one from highest priority to lowest\n * until one responds\n *\n * @param type -  The type of metadata requested from the metadata store\n * @param query - The query for the metadata store, often imageId\n *        Some metadata providers support multi-valued strings, which are interpretted\n *        as the provider chooses.\n *\n * @returns The metadata retrieved from the metadata store\n * @category MetaData\n */\nfunction getMetaData(type: string, ...queries): any {\n  // Invoke each provider in priority order until one returns something\n  for (let i = 0; i < providers.length; i++) {\n    const result = providers[i].provider(type, ...queries);\n\n    if (result !== undefined) {\n      return result;\n    }\n  }\n}\n\nexport { getMetaData as get };\n","import { RequestPoolManager } from './requestPoolManager';\nimport RequestType from '../enums/RequestType';\n\n/**\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *     enabled: true,\n *   },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n */\nconst imageLoadPoolManager = new RequestPoolManager('imageLoadPool');\n\nimageLoadPoolManager.grabDelay = 0;\n\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Interaction, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Thumbnail, 1000);\nimageLoadPoolManager.setMaxSimultaneousRequests(RequestType.Prefetch, 1000);\n\nexport default imageLoadPoolManager;\n","import RequestType from '../enums/RequestType';\nimport { IImage } from '../types';\nimport { uuidv4 } from '../utilities';\n\ntype AdditionalDetails = {\n  imageId?: string;\n  volumeId?: string;\n};\n\ntype RequestDetailsInterface = {\n  requestFn: () => Promise<IImage | void>;\n  type: RequestType;\n  additionalDetails: AdditionalDetails;\n};\n\ntype RequestPool = {\n  [name in RequestType]: { [key: number]: RequestDetailsInterface[] };\n};\n\n/**\n * RequestPool manager class is a base class that manages the request pools.\n * It is used imageRetrievalPoolManager, and imageLoadPoolManager to retrieve and load images.\n * Previously requestPoolManager was used to manage the retrieval and loading and decoding\n * of the images in a way that new requests were sent after the image was both loaded and decoded\n * which was not performant since it was waiting for the image to be loaded and decoded before\n * sending the next request which is a network request and can be done in parallel.\n * Now, we use separate imageRetrievalPoolManager and imageLoadPoolManager\n * to improve performance and both are extending the RequestPoolManager class which\n * is a basic queueing pool.\n *\n * A new requestPool can be created by instantiating a new RequestPoolManager class.\n *\n * ```javascript\n * const requestPoolManager = new RequestPoolManager()\n * ```\n *\n * ## ImageLoadPoolManager\n *\n * You can use the imageLoadPoolManager to load images, by providing a `requestFn`\n * that returns a promise for the image. You can provide a `type` to specify the type of\n * request (interaction, thumbnail, prefetch), and you can provide additional details\n * that will be passed to the requestFn. Below is an example of a requestFn that loads\n * an image from an imageId:\n *\n * ```javascript\n *\n * const priority = -5\n * const requestType = RequestType.Interaction\n * const additionalDetails = { imageId }\n * const options = {\n *   targetBuffer: {\n *     type: 'Float32Array',\n *     offset: null,\n *     length: null,\n *   },\n *   preScale: {\n *      enabled: true,\n *    },\n * }\n *\n * imageLoadPoolManager.addRequest(\n *   loadAndCacheImage(imageId, options).then(() => { // set on viewport}),\n *   requestType,\n *   additionalDetails,\n *   priority\n * )\n * ```\n * ### ImageRetrievalPoolManager\n * You don't need to directly use the imageRetrievalPoolManager to load images\n * since the imageLoadPoolManager will automatically use it for retrieval. However,\n * maximum number of concurrent requests can be set by calling `setMaxConcurrentRequests`.\n */\nclass RequestPoolManager {\n  private id: string;\n  private awake: boolean;\n  private requestPool: RequestPool;\n  private numRequests = {\n    interaction: 0,\n    thumbnail: 0,\n    prefetch: 0,\n    compute: 0,\n  };\n  /* maximum number of requests of each type. */\n  public maxNumRequests: {\n    interaction: number;\n    thumbnail: number;\n    prefetch: number;\n    compute: number;\n  };\n  /* A public property that is used to set the delay between requests. */\n  public grabDelay: number;\n  private timeoutHandle: number;\n\n  /**\n   * By default a request pool containing three priority groups, one for each\n   * of the request types, is created. Maximum number of requests of each type\n   * is set to 6.\n   */\n  constructor(id?: string) {\n    this.id = id ? id : uuidv4();\n\n    this.requestPool = {\n      interaction: { 0: [] },\n      thumbnail: { 0: [] },\n      prefetch: { 0: [] },\n      compute: { 0: [] },\n    };\n\n    this.grabDelay = 5;\n    this.awake = false;\n\n    this.numRequests = {\n      interaction: 0,\n      thumbnail: 0,\n      prefetch: 0,\n      compute: 0,\n    };\n\n    this.maxNumRequests = {\n      interaction: 6,\n      thumbnail: 6,\n      prefetch: 5,\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there. For this reason\n      // I'm setting the limit to 1000 for now.\n      compute: 1000,\n    };\n  }\n\n  /**\n   * This function sets the maximum number of requests for a given request type.\n   * @param type - The type of request you want to set the max number\n   * of requests for it can be either of interaction, prefetch, or thumbnail.\n   * @param maxNumRequests - The maximum number of requests that can be\n   * made at a time.\n   */\n  public setMaxSimultaneousRequests(\n    type: RequestType,\n    maxNumRequests: number\n  ): void {\n    this.maxNumRequests[type] = maxNumRequests;\n  }\n\n  /**\n   * It returns the maximum number of requests of a given type that can be made\n   * @param type - The type of request.\n   * @returns The maximum number of requests of a given type.\n   */\n  public getMaxSimultaneousRequests(type: RequestType): number {\n    return this.maxNumRequests[type];\n  }\n\n  /**\n   * Stops further fetching of the requests, all the ongoing requests will still\n   * be retrieved\n   */\n  public destroy(): void {\n    if (this.timeoutHandle) {\n      window.clearTimeout(this.timeoutHandle);\n    }\n  }\n\n  /**\n   * Adds the requests to the pool of requests.\n   *\n   * @param requestFn - A function that returns a promise which resolves in the image\n   * @param type - Priority category, it can be either of interaction, prefetch,\n   * or thumbnail.\n   * @param additionalDetails - Additional details that requests can contain.\n   * For instance the volumeId for the volume requests\n   * @param priority - Priority number for each category of requests. Its default\n   * value is priority 0. The lower the priority number, the higher the priority number\n   *\n   */\n  public addRequest(\n    requestFn: () => Promise<IImage | void>,\n    type: RequestType,\n    additionalDetails: Record<string, unknown>,\n    priority = 0\n  ): void {\n    // Describe the request\n    const requestDetails: RequestDetailsInterface = {\n      requestFn,\n      type,\n      additionalDetails,\n    };\n\n    // Check if the priority group exists on the request type\n    if (this.requestPool[type][priority] === undefined) {\n      this.requestPool[type][priority] = [];\n    }\n\n    // Adding the request to the correct priority group of the request type\n    this.requestPool[type][priority].push(requestDetails);\n\n    this.startGrabbing();\n  }\n\n  /**\n   * Filter the requestPoolManager's pool of request based on the result of\n   * provided filter function. The provided filter function needs to return false or true\n   *\n   * @param filterFunction - The filter function for filtering of the requests to keep\n   */\n  public filterRequests(\n    filterFunction: (requestDetails: RequestDetailsInterface) => boolean\n  ): void {\n    Object.keys(this.requestPool).forEach((type: string) => {\n      const requestType = this.requestPool[type];\n      Object.keys(requestType).forEach((priority) => {\n        requestType[priority] = requestType[priority].filter(\n          (requestDetails: RequestDetailsInterface) => {\n            return filterFunction(requestDetails);\n          }\n        );\n      });\n    });\n  }\n\n  /**\n   * Clears the requests specific to the provided type. For instance, the\n   * pool of requests of type 'interaction' can be cleared via this function.\n   *\n   *\n   * @param type - category of the request (either interaction, prefetch or thumbnail)\n   */\n  public clearRequestStack(type: string): void {\n    if (!this.requestPool[type]) {\n      throw new Error(`No category for the type ${type} found`);\n    }\n    this.requestPool[type] = { 0: [] };\n  }\n\n  private sendRequests(type) {\n    const requestsToSend = this.maxNumRequests[type] - this.numRequests[type];\n    let syncImageCount = 0;\n\n    for (let i = 0; i < requestsToSend; i++) {\n      const requestDetails = this.getNextRequest(type);\n      if (requestDetails === null) {\n        return false;\n      } else if (requestDetails) {\n        this.numRequests[type]++;\n        this.awake = true;\n\n        let requestResult;\n        try {\n          requestResult = requestDetails.requestFn();\n        } catch (e) {\n          // This is the only warning one will get, so need a warn message\n          console.warn('sendRequest failed', e);\n        }\n        if (requestResult?.finally) {\n          requestResult.finally(() => {\n            this.numRequests[type]--;\n            this.startAgain();\n          });\n        } else {\n          // Handle non-async request functions too - typically just short circuit ones\n          this.numRequests[type]--;\n          syncImageCount++;\n        }\n      }\n    }\n    if (syncImageCount) {\n      this.startAgain();\n    }\n\n    return true;\n  }\n\n  private getNextRequest(type): RequestDetailsInterface | null {\n    const interactionPriorities = this.getSortedPriorityGroups(type);\n    for (const priority of interactionPriorities) {\n      if (this.requestPool[type][priority].length) {\n        return this.requestPool[type][priority].shift();\n      }\n    }\n\n    return null;\n  }\n\n  protected startGrabbing(): void {\n    const hasRemainingInteractionRequests = this.sendRequests(\n      RequestType.Interaction\n    );\n    const hasRemainingThumbnailRequests = this.sendRequests(\n      RequestType.Thumbnail\n    );\n    const hasRemainingPrefetchRequests = this.sendRequests(\n      RequestType.Prefetch\n    );\n    const hasRemainingComputeRequests = this.sendRequests(RequestType.Compute);\n\n    if (\n      !hasRemainingInteractionRequests &&\n      !hasRemainingThumbnailRequests &&\n      !hasRemainingPrefetchRequests &&\n      !hasRemainingComputeRequests\n    ) {\n      this.awake = false;\n    }\n  }\n\n  protected startAgain(): void {\n    if (!this.awake) {\n      return;\n    }\n\n    if (this.grabDelay !== undefined) {\n      // Prevents calling setTimeout hundreds of times when hundreds of requests\n      // are added which make it slower and works in an unexpected way when\n      // destroy/clearTimeout is called because only the last handle is stored.\n      if (!this.timeoutHandle) {\n        this.timeoutHandle = window.setTimeout(() => {\n          this.timeoutHandle = null;\n          this.startGrabbing();\n        }, this.grabDelay);\n      }\n    } else {\n      this.startGrabbing();\n    }\n  }\n\n  protected getSortedPriorityGroups(type: string): Array<number> {\n    const priorities = Object.keys(this.requestPool[type])\n      .map(Number)\n      .filter((priority) => this.requestPool[type][priority].length)\n      .sort((a, b) => a - b);\n    return priorities;\n  }\n\n  /**\n   * Returns the request pool containing different categories, their priority and\n   * the added request details.\n   *\n   * @returns the request pool which contains different categories, their priority and\n   * the added request details\n   */\n  getRequestPool(): RequestPool {\n    return this.requestPool;\n  }\n}\n\nexport { RequestPoolManager };\n","import cache, { ImageVolume } from '../cache';\nimport { Events } from '../enums';\nimport eventTarget from '../eventTarget';\nimport { getConfiguration, getShouldUseSharedArrayBuffer } from '../init';\n\n/**\n * This function will check if the cache optimization is enabled and if it is\n * it will check if the created volume was derived from an already cached stack\n * of images, if so it will go back to the image cache and create a view at the\n * correct offset of the bigger volume array buffer, this will save memory.\n *\n * @param volumeId - The volumeId that will be checked for cache optimization\n */\nexport function setupCacheOptimizationEventListener(volumeId) {\n  const { enableCacheOptimization } = getConfiguration();\n  const shouldUseSAB = getShouldUseSharedArrayBuffer();\n\n  const performOptimization = enableCacheOptimization && shouldUseSAB;\n  if (!performOptimization) {\n    return;\n  }\n\n  eventTarget.addEventListenerOnce(\n    Events.IMAGE_VOLUME_LOADING_COMPLETED,\n    (evt) => {\n      if (evt.detail.volumeId !== volumeId) {\n        return;\n      }\n\n      const volume = cache.getVolume(volumeId);\n\n      performCacheOptimizationForVolume(volume);\n    }\n  );\n}\n\n/**\n * Performs cache optimization for a volume by replacing the pixel data of each image\n * in the image cache (if found) with a view of the volume's scalar data.\n * @param options - The options for cache optimization.\n * @param options.volumeId - The ID of the volume.\n */\nexport function performCacheOptimizationForVolume(volume) {\n  if (!(volume instanceof ImageVolume)) {\n    return;\n  }\n\n  const scalarData = volume.getScalarData();\n\n  volume.imageCacheOffsetMap.size > 0\n    ? _processImageCacheOffsetMap(volume, scalarData)\n    : _processVolumeImages(volume, scalarData);\n}\n\n/**\n * This function will process the volume images and replace the pixel data of each\n * image in the image cache (if found) with a view of the volume's scalar data.\n * This function is used when the volume is derived from an already cached stack\n * of images.\n *\n * @param volume - The volume to process.\n * @param scalarData - The scalar data to use for the volume.\n */\nfunction _processImageCacheOffsetMap(volume, scalarData) {\n  volume.imageCacheOffsetMap.forEach(({ offset }, imageId) => {\n    const image = cache.getImage(imageId);\n    if (!image) {\n      return;\n    }\n\n    _updateImageWithScalarDataView(image, scalarData, offset);\n    cache.decrementImageCacheSize(image.sizeInBytes);\n  });\n}\n\n/**\n * This function will process the volume images and replace the pixel data of each\n * image in the image cache (if found) with a view of the volume's scalar data.\n * This function is used when the volume is not derived from an already cached stack\n * of images.\n *\n * @param volume - The volume to process.\n * @param scalarData - The scalar data to use for the volume.\n */\nfunction _processVolumeImages(volume, scalarData) {\n  let compatibleScalarData = scalarData;\n\n  const sampleImageIdWithImage = volume.imageIds.find((imageId) => {\n    const image = cache.getImage(imageId);\n    return image;\n  });\n\n  if (!sampleImageIdWithImage) {\n    return;\n  }\n\n  const sampleImage = cache.getImage(sampleImageIdWithImage);\n  const samplePixelData =\n    sampleImage.imageFrame?.pixelData || sampleImage.getPixelData();\n\n  // Check if the types of scalarData and pixelData are different.\n  if (scalarData.constructor !== samplePixelData.constructor) {\n    // If so, create a new typed array of the same type as pixelData and copy the values from scalarData.\n    compatibleScalarData = new samplePixelData.constructor(scalarData.length);\n\n    // Copy values from scalarData to compatibleScalarData.\n    compatibleScalarData.set(scalarData);\n  }\n\n  volume.imageIds.forEach((imageId) => {\n    const image = cache.getImage(imageId);\n    if (!image) {\n      return;\n    }\n\n    const index = volume.getImageIdIndex(imageId);\n    const offset = index * image.getPixelData().byteLength;\n\n    _updateImageWithScalarDataView(image, compatibleScalarData, offset);\n    cache.decrementImageCacheSize(image.sizeInBytes);\n  });\n}\n\nfunction _updateImageWithScalarDataView(image, scalarData, offset) {\n  const pixelData = image.imageFrame\n    ? image.imageFrame.pixelData\n    : image.getPixelData();\n\n  const view = new pixelData.constructor(\n    scalarData.buffer,\n    offset,\n    pixelData.length\n  );\n\n  image.getPixelData = () => view;\n\n  if (image.imageFrame) {\n    image.imageFrame.pixelData = view;\n  }\n\n  image.bufferView = {\n    buffer: scalarData.buffer,\n    offset,\n  };\n}\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\n\nimport { ColormapPublic, ColormapRegistration } from '../types';\nimport isEqual from './isEqual';\nimport { actorIsA } from './actorCheck';\n\nconst _colormaps = new Map();\n\n/**\n * Register a colormap\n * @param name - name of the colormap\n * @param colormap - colormap object\n */\nfunction registerColormap(colormap: ColormapRegistration) {\n  _colormaps.set(colormap.Name, colormap);\n}\n\n/**\n * Get a colormap by name\n * @param name - name of the colormap\n * @returns colormap object\n */\nfunction getColormap(name) {\n  return _colormaps.get(name);\n}\n\n/**\n * Get all registered colormap names\n * @returns array of colormap names\n *\n */\nfunction getColormapNames() {\n  return Array.from(_colormaps.keys());\n}\n\n/**\n * Finds a colormap that matches the given RGB points.\n *\n * @param rgbPoints - The RGB points to match against the colormaps.\n * @returns  The matched colormap object or null if no match is found.\n */\nfunction findMatchingColormap(rgbPoints, actor): ColormapPublic | null {\n  const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) =>\n    vtkColorMaps.getPresetByName(presetName)\n  );\n\n  const colormapsCS3D = getColormapNames().map((colormapName) =>\n    getColormap(colormapName)\n  );\n\n  const colormaps = colormapsVTK.concat(colormapsCS3D);\n\n  // Find the colormap that matches the given RGB points\n  const matchedColormap = colormaps.find((colormap) => {\n    const { RGBPoints: presetRGBPoints } = colormap;\n\n    if (presetRGBPoints.length !== rgbPoints.length) {\n      return false;\n    }\n\n    for (let i = 0; i < presetRGBPoints.length; i += 4) {\n      if (\n        !isEqual(\n          presetRGBPoints.slice(i + 1, i + 4),\n          rgbPoints.slice(i + 1, i + 4)\n        )\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n\n  if (!matchedColormap) {\n    return null;\n  }\n\n  const opacity = [];\n  if (actorIsA(actor, 'vtkVolume')) {\n    const opacityPoints = actor\n      .getProperty()\n      .getScalarOpacity(0)\n      .getDataPointer();\n\n    if (!opacityPoints) {\n      return {\n        name: matchedColormap.Name,\n      };\n    }\n\n    for (let i = 0; i < opacityPoints.length; i += 2) {\n      opacity.push({\n        value: opacityPoints[i],\n        opacity: opacityPoints[i + 1],\n      });\n    }\n  }\n\n  return {\n    name: matchedColormap.Name,\n    opacity,\n  };\n}\n\nexport {\n  getColormap,\n  getColormapNames,\n  registerColormap,\n  findMatchingColormap,\n};\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport { VOIRange } from '../types';\n\nexport default function createLinearRGBTransferFunction(\n  voiRange: VOIRange\n): vtkColorTransferFunction {\n  const cfun = vtkColorTransferFunction.newInstance();\n  let lower = 0;\n  let upper = 1024;\n  if (\n    voiRange &&\n    voiRange.lower !== undefined &&\n    voiRange.upper !== undefined\n  ) {\n    lower = voiRange.lower;\n    upper = voiRange.upper;\n  }\n  cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\n  cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\n\n  return cfun;\n}\n","import { ImageSliceData, IVolumeViewport, VolumeActor } from '../types';\nimport getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\n\n/**\n * It calculates the number of slices and the current slice index for a given\n * Volume viewport\n * @param viewport - volume viewport\n * @returns An object with two properties: numberOfSlices and imageIndex.\n */\nfunction getImageSliceDataForVolumeViewport(\n  viewport: IVolumeViewport\n): ImageSliceData {\n  const camera = viewport.getCamera();\n\n  const { spacingInNormalDirection, imageVolume } =\n    getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n  if (!imageVolume) {\n    return;\n  }\n\n  const { viewPlaneNormal, focalPoint } = camera;\n\n  const actorEntry = viewport\n    .getActors()\n    .find(\n      (a) =>\n        a.referenceId === imageVolume.volumeId || a.uid === imageVolume.volumeId\n    );\n\n  if (!actorEntry) {\n    console.warn('No actor found for with actorUID of', imageVolume.volumeId);\n  }\n\n  const volumeActor = actorEntry.actor as VolumeActor;\n  const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n\n  const { min, max, current } = sliceRange;\n\n  // calculate number of steps from min to max with current normal spacing in direction\n  const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\n\n  // calculate the imageIndex based on min, max, current\n  let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\n  imageIndex = Math.floor(imageIndex);\n\n  // Clamp imageIndex\n  if (imageIndex > numberOfSlices - 1) {\n    imageIndex = numberOfSlices - 1;\n  } else if (imageIndex < 0) {\n    imageIndex = 0;\n  }\n\n  return {\n    numberOfSlices,\n    imageIndex,\n  };\n}\n\nexport default getImageSliceDataForVolumeViewport;\n","function getTransferFunctionNodes(transferFunction) {\n  const size = transferFunction.getSize();\n  const values = [];\n  for (let index = 0; index < size; index++) {\n    const nodeValue1 = [];\n\n    transferFunction.getNodeValue(index, nodeValue1);\n\n    values.push(nodeValue1);\n  }\n\n  return values;\n}\n\nfunction setTransferFunctionNodes(transferFunction, nodes) {\n  if (!nodes?.length) {\n    return;\n  }\n\n  transferFunction.removeAllPoints();\n\n  nodes.forEach((node) => {\n    transferFunction.addRGBPoint(...node);\n  });\n}\n\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\n","import type Point3 from '../types/Point3';\n\n/**\n * Given an imageData object and a point in physical space, return the index of the\n * voxel that contains the point. TODO: this should be pushed to vtk upstream.\n * @param imageData - The image data object.\n * @param physicalPoint - The point in physical space that you want to transform to\n * index space.\n * @returns An array of integers.\n */\nexport default function transformWorldToIndex(imageData, worldPos: Point3) {\n  const continuousIndex = imageData.worldToIndex(worldPos);\n  const index = continuousIndex.map(Math.round);\n\n  return index;\n}\n","import eventTarget from '../eventTarget';\n\n/**\n * Small utility to trigger a custom event for a given EventTarget.\n *\n * @example\n *\n * ```javascript\n * triggerEvent(element, Events.IMAGE_RENDERED, { element })\n * ```\n * or it can trigger event on the eventTarget itself\n *\n * ```javascript\n * triggerEvent(eventTarget, CSTOOLS_EVENTS.ANNOTATION_MODIFIED, { viewportId, annotationUID })\n * ```\n *\n * @param el - The element or EventTarget to trigger the event upon\n * @param type - The event type name\n * @param detail - The event detail to be sent\n * @returns false if event is cancelable and at least one of the event handlers\n * which received event called Event.preventDefault(). Otherwise it returns true.\n */\nexport default function triggerEvent(\n  el: EventTarget = eventTarget,\n  type: string,\n  detail: unknown = null\n): boolean {\n  if (!type) {\n    throw new Error('Event type was not defined');\n  }\n\n  const event = new CustomEvent(type, {\n    detail,\n    cancelable: true,\n  });\n\n  return el.dispatchEvent(event);\n}\n","import * as Comlink from 'comlink';\nimport { RequestType } from '../enums/';\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\n\nclass CentralizedWorkerManager {\n  constructor() {\n    this.workerRegistry = {};\n    this.workerPoolManager = new RequestPoolManager('webworker');\n  }\n\n  /**\n   * Registers a new worker, it doesn't mean that the function will get executed.\n   *\n   * @param workerName - The name of the worker.\n   * @param workerFn - The function that creates a new instance of the worker.\n   * @param options - Optional parameters.\n   * @param options.maxWorkerInstances - The maximum number of instances of this worker that can be created.\n   * For instance if you create a worker with maxWorkerInstances = 2, then only 2 instances of this worker will be created\n   * and in case there are 10 tasks that need to be executed, each will get assigned 5 tasks.\n   * @param options.overwrite - Whether to overwrite the worker if it's already registered.\n   * @param options.autoTerminateOnIdle - Whether to automatically terminate idle workers.\n   */\n  registerWorker(workerName, workerFn, options = {}) {\n    const {\n      maxWorkerInstances = 1,\n      overwrite = false,\n      autoTerminateOnIdle = {\n        enabled: false,\n        idleTimeThreshold: 3000, // 3 seconds\n      },\n    } = options;\n\n    if (this.workerRegistry[workerName] && !overwrite) {\n      console.warn(`Worker type '${workerName}' is already registered...`);\n      return;\n    }\n\n    if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\n      clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\n    }\n\n    const workerProperties = {\n      workerFn: null,\n      instances: [],\n      loadCounters: [],\n      lastActiveTime: [],\n      // used for termination\n      nativeWorkers: [],\n      // auto termination\n      autoTerminateOnIdle: autoTerminateOnIdle.enabled,\n      idleCheckIntervalId: null,\n      idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\n    };\n\n    workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\n    workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\n\n    for (let i = 0; i < maxWorkerInstances; i++) {\n      const worker = workerFn();\n      workerProperties.instances.push(Comlink.wrap(worker));\n      workerProperties.nativeWorkers.push(worker);\n      workerProperties.workerFn = workerFn;\n    }\n\n    this.workerRegistry[workerName] = workerProperties;\n  }\n\n  getNextWorkerAPI(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return null;\n    }\n\n    // Find the worker with the minimum load.\n    const workerInstances = workerProperties.instances.filter(\n      (instance) => instance !== null\n    );\n\n    let minLoadIndex = 0;\n    let minLoadValue = workerProperties.loadCounters[0] || 0;\n    for (let i = 1; i < workerInstances.length; i++) {\n      const currentLoadValue = workerProperties.loadCounters[i] || 0;\n      if (currentLoadValue < minLoadValue) {\n        minLoadIndex = i;\n        minLoadValue = currentLoadValue;\n      }\n    }\n\n    // Check and recreate the worker if it was terminated.\n    if (workerProperties.instances[minLoadIndex] === null) {\n      const worker = workerProperties.workerFn();\n      workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\n      workerProperties.nativeWorkers[minLoadIndex] = worker;\n    }\n\n    // Update the load counter.\n    workerProperties.loadCounters[minLoadIndex] += 1;\n\n    // return the worker that has the minimum load.\n    return {\n      api: workerProperties.instances[minLoadIndex],\n      index: minLoadIndex,\n    };\n  }\n\n  /**\n   * Executes a task on a worker.\n   *\n   * @param workerName - The name of the worker to execute the task on.\n   * @param methodName - The name of the method to execute on the worker.\n   * @param args - The arguments to pass to the method. Default is an array\n   * You should put your transferable objects in the first argument as object\n   * and from the second argument you can put your non-transferable objects such\n   * as functions, classes, etc.\n   * @param options - An object containing options for the request. Default is an empty object.\n   * @param options.requestType - The type of the request. Default is RequestType.Compute.\n   * @param options.priority - The priority of the request. Default is 0.\n   * @param options.options - Additional options for the request. Default is an empty object.\n   *\n   * @returns A promise that resolves with the result of the task.\n   */\n  executeTask(\n    workerName,\n    methodName,\n    args = {},\n    {\n      requestType = RequestType.Compute,\n      priority = 0,\n      options = {},\n      callbacks = [],\n    } = {}\n  ) {\n    return new Promise((resolve, reject) => {\n      const requestFn = async () => {\n        const { api, index } = this.getNextWorkerAPI(workerName);\n        if (!api) {\n          const error = new Error(\n            `No available worker instance for '${workerName}'`\n          );\n          console.error(error);\n          reject(error);\n          return;\n        }\n\n        try {\n          // fix if any of the args keys are a function then we need to proxy it\n          // for the worker to be able to call it\n          let finalCallbacks = [];\n          if (callbacks.length) {\n            finalCallbacks = callbacks.map((cb) => {\n              return Comlink.proxy(cb);\n            });\n          }\n          const workerProperties = this.workerRegistry[workerName];\n\n          workerProperties.processing = true;\n\n          const results = await api[methodName](args, ...finalCallbacks);\n\n          workerProperties.processing = false;\n          workerProperties.lastActiveTime[index] = Date.now();\n\n          // If auto termination is enabled and the interval is not set, set it.\n          if (\n            workerProperties.autoTerminateOnIdle &&\n            !workerProperties.idleCheckIntervalId &&\n            workerProperties.idleTimeThreshold\n          ) {\n            workerProperties.idleCheckIntervalId = setInterval(() => {\n              this.terminateIdleWorkers(\n                workerName,\n                workerProperties.idleTimeThreshold\n              );\n            }, workerProperties.idleTimeThreshold);\n          }\n\n          resolve(results);\n        } catch (err) {\n          console.error(\n            `Error executing method '${methodName}' on worker '${workerName}':`,\n            err\n          );\n          reject(err);\n        } finally {\n          this.workerRegistry[workerName].loadCounters[index]--;\n        }\n      };\n\n      // I believe there is a bug right now, where if there are two workers\n      // and one wants to run a compute job 6 times and the limit is just 5, then\n      // the other worker will never get a chance to run its compute job.\n      // we should probably have a separate limit for compute jobs per worker\n      // context as there is another layer of parallelism there.\n      this.workerPoolManager.addRequest(\n        requestFn,\n        requestType,\n        options,\n        priority\n      );\n    });\n  }\n\n  terminateIdleWorkers(workerName, idleTimeThreshold) {\n    const workerProperties = this.workerRegistry[workerName];\n\n    if (workerProperties.processing) {\n      return;\n    }\n\n    const now = Date.now();\n\n    workerProperties.instances.forEach((_, index) => {\n      const lastActiveTime = workerProperties.lastActiveTime[index];\n      const isWorkerActive =\n        lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\n      const idleTime = now - lastActiveTime;\n\n      if (!isWorkerActive && idleTime > idleTimeThreshold) {\n        this.terminateWorkerInstance(workerName, index);\n      }\n    });\n  }\n\n  terminate(workerName) {\n    const workerProperties = this.workerRegistry[workerName];\n    if (!workerProperties) {\n      console.error(`Worker type '${workerName}' is not registered.`);\n      return;\n    }\n\n    workerProperties.instances.forEach((_, index) => {\n      this.terminateWorkerInstance(workerName, index);\n    });\n  }\n\n  // New method to handle individual worker termination\n  terminateWorkerInstance(workerName, index) {\n    const workerProperties = this.workerRegistry[workerName];\n    const workerInstance = workerProperties.instances[index];\n\n    if (workerInstance !== null) {\n      workerInstance[Comlink.releaseProxy]();\n      workerProperties.nativeWorkers[index].terminate();\n\n      // Set the worker instance to null after termination\n      workerProperties.instances[index] = null;\n      workerProperties.lastActiveTime[index] = null;\n    }\n  }\n}\n\nexport default CentralizedWorkerManager;\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Height: extend(BASE, {\n    iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { MouseBindings, ToolModes } from '../../enums';\nimport get from 'lodash.get';\nimport cloneDeep from 'lodash.clonedeep';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  currentActivePrimaryToolName: string | null = null;\n  prevActivePrimaryToolName: string | null = null;\n  /**\n   * Options used for restoring a tool\n   */\n  restoreToolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n\n  /**\n   * Retrieves the tool instances associated with this tool group.\n   *\n   * @returns A record containing the tool instances, where the keys are the tool names and the values are the tool instances.\n   */\n  public getToolInstances(): Record<string, any> {\n    return this._toolInstances;\n  }\n\n  /**\n   * Check if a tool is already added to the tool group\n   * @param toolName - Tool name\n   * @returns True if the tool is already added or false otherwise\n   */\n  hasTool(toolName: string): boolean {\n    return !!this._toolInstances[toolName];\n  }\n\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    if (typeof viewportId !== 'string') {\n      throw new Error('viewportId must be defined and be a string');\n    }\n\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId: renderingEngineUIDToUse,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n\n    const eventDetail = {\n      toolGroupId: this.id,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(\n        toolName,\n        options || this.restoreToolOptions[toolName]\n      );\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    // if it is a primary tool binding, we should store it as the previous primary tool\n    // so that we can restore it when the tool is disabled if desired\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n      if (this.prevActivePrimaryToolName === null) {\n        this.prevActivePrimaryToolName = toolName;\n      } else {\n        this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n      }\n\n      this.currentActivePrimaryToolName = toolName;\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param options - Options used when setting the tool as passive\n   *  - removeAllBindings: only the primary button bindings are removed but\n   *  if this parameter is set to true all bindings are removed.\n   */\n  public setToolPassive(\n    toolName: string,\n    options?: { removeAllBindings?: boolean | IToolBinding[] }\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const matchBindings = Array.isArray(options?.removeAllBindings)\n      ? options.removeAllBindings\n      : this.getDefaultPrimaryBindings();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        options?.removeAllBindings !== true &&\n        !matchBindings.some((matchBinding) =>\n          hasSameBinding(binding, matchBinding)\n        )\n      //(binding.mouseButton !== defaultMousePrimary || binding.modifierKey)\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    const toolInstance = this._toolInstances[toolName];\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(toolInstance.configuration, configuration);\n    }\n\n    toolInstance.configuration = _configuration;\n\n    if (typeof toolInstance.onSetToolConfiguration === 'function') {\n      toolInstance.onSetToolConfiguration();\n    }\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Gets an array of bindings that is the full primary binding.\n   * Currently this is just the primary mouse button, but may be extended in the\n   * future to include touch or other binding types.\n   */\n  public getDefaultPrimaryBindings(): IToolBinding[] {\n    return PRIMARY_BINDINGS;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath?: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration =\n      get(this._toolInstances[toolName].configuration, configurationPath) ||\n      this._toolInstances[toolName].configuration;\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   * Gets the name of the previously active tool.\n   * @returns The name of the previously active tool.\n   */\n  public getPrevActivePrimaryToolName(): string {\n    return this.prevActivePrimaryToolName;\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const primaryBindings = this.getDefaultPrimaryBindings();\n    return toolOptions?.bindings?.some((binding) =>\n      primaryBindings.some((primary) => hasSameBinding(binding, primary))\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\n/**\n * Figure out if the two bindings are the same\n */\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n  if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { roundNumber } from '../../utilities';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        ...viewport.getViewReference({ points: [worldPos] }),\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const { renderingEngine } = getEnabledElement(element);\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const { renderingEngine } = getEnabledElement(element);\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        triggerAnnotationCompleted(annotation);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n      });\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { element } = enabledElement.viewport;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      const handles1 = [index1, index2];\n      const handles2 = [index3, index4];\n\n      const { scale: scale1, units: units1 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles1\n      );\n\n      const { scale: scale2, units: units2 } = getCalibratedLengthUnitsAndScale(\n        image,\n        handles2\n      );\n\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const lengthUnit = dist1 > dist2 ? units1 : units2;\n      const widthUnit = dist1 > dist2 ? units2 : units1;\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: units1,\n        lengthUnit,\n        widthUnit,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, element);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats, label } = data;\n  const { length, width, unit, lengthUnit, widthUnit } = cachedStats[targetId];\n\n  const textLines = [];\n  if (label) {\n    textLines.push(label);\n  }\n  if (length === undefined) {\n    return textLines;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  textLines.push(\n    `L: ${roundNumber(length)} ${lengthUnit || unit}`,\n    `W: ${roundNumber(width)} ${widthUnit || unit}`\n  );\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { math, roundNumber } from '../../utilities';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport type {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  AnnotationRenderContext,\n} from '../../types';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The smoothing process uses b-spline algorithm and consider 4 configurations properties:\n * - smoothing.smoothOnAdd: to tell whether it should be smoothed or not (for editing it is considered the property smoothOnEdit) (default: false)\n * - smoothing.smoothOnEdit: to tell whether it should be smoothed or not when editing (default: false)\n * - smoothing.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during smoothing (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - smoothing.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the smoothing might occur when:\n * - drawing is done (i.e mouse is released) and smoothing.smoothOnAdd is true. smoothing algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and smoothing.smoothOnEdit is true. smoothing algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * smoothing does not occur when:\n * - smoothing.smoothOnAdd is false and drawing is completed\n * - smoothing.smoothOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of smoothing will be removal of some of the outliers\n * Changing tool configuration (see below) you can fine-tune the smoothing process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive smoothing.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more aggressive smoothing.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set smoothing aggressiveness while adding new annotation (ps: this does not change if smoothing is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set smoothing to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   smoothing: { smoothOnAdd: false, smoothOnEdit: true  },\n * });\n * ```\n *\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  protected activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  private renderPointContourWithMarker: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        /**\n         * Specify which modifier key is used to add a hole to a contour. The\n         * modifier must be pressed when the first point of a new contour is added.\n         */\n        contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // For closed contours, make them clockwise\n        // This can be useful if contours are compared between slices, eg for\n        // interpolation, and does not cause problems otherwise so defaulting to true.\n        makeClockWise: true,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finesse to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        /**\n         * Smoothing is used to remove jagged irregularities in the polyline,\n         * as opposed to interpolation, which is used to create new polylines\n         * between existing polylines.\n         */\n        smoothing: {\n          smoothOnAdd: false,\n          smoothOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        /**\n         * Interpolation is the creation of new segmentations in between the\n         * existing segmentations/indices.  Note that this does not apply to\n         * ROI values, since those annotations are individual annotations, not\n         * connected in any way to each other, whereas segmentations are intended\n         * to be connected 2d + 1 dimension (time or space or other) volumes.\n         */\n        interpolation: {\n          enabled: false,\n          // Callback to update the annotation or perform other action when the\n          // interpolation is complete.\n          onInterpolationComplete: null,\n        },\n        /**\n         * The polyline may get processed in order to reduce the number of points\n         * for better performance and storage.\n         */\n        decimate: {\n          enabled: false,\n          /** A maximum given distance 'epsilon' to decide if a point should or\n           * shouldn't be added the resulting polyline which will have a lower\n           * number of points for higher `epsilon` values.\n           */\n          epsilon: 0.1,\n        },\n        displayOnePointAsCrosshairs: false,\n        calculateStats: true,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const annotation = this.createAnnotation(\n      evt\n    ) as PlanarFreehandROIAnnotation;\n\n    this.addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.contour.closed) {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    }\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { polyline: points } = annotation.data.contour;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n      const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (canProject) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (!annotation.data.contour.closed) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n  };\n\n  public cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  public filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    ) as PlanarFreehandROIAnnotation[];\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.contour.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  protected isContourSegmentationTool(): boolean {\n    // Disable contour segmentation behavior because it shall be activated only\n    // for PlanarFreehandContourSegmentationTool\n    return false;\n  }\n\n  protected createAnnotation(evt: EventTypes.InteractionEventType): Annotation {\n    const worldPos = evt.detail.currentPoints.world;\n    const contourAnnotation = super.createAnnotation(evt);\n\n    const onInterpolationComplete = (annotation) => {\n      // Clear out the handles because they aren't used for straight freeform\n      annotation.data.handles.points.length = 0;\n    };\n\n    const annotation = <PlanarFreehandROIAnnotation>csUtils.deepMerge(\n      contourAnnotation,\n      {\n        data: {\n          contour: {\n            polyline: [<Types.Point3>[...worldPos]],\n          },\n          label: '',\n          cachedStats: {},\n        },\n        onInterpolationComplete,\n      }\n    );\n\n    return annotation;\n  }\n\n  protected getAnnotationStyle(context) {\n    // This method exists only because `super` cannot be called from\n    // _getRenderingOptions() which is in an external file.\n    return super.getAnnotationStyle(context);\n  }\n\n  protected renderAnnotationInstance(\n    renderContext: AnnotationRenderContext\n  ): boolean {\n    const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n    const annotation = renderContext.annotation as PlanarFreehandROIAnnotation;\n\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      if (\n        this.configuration.displayOnePointAsCrosshairs &&\n        annotation.data.contour.polyline.length === 1\n      ) {\n        this.renderPointContourWithMarker(\n          enabledElement,\n          svgDrawingHelper,\n          annotation\n        );\n      } else {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      }\n    } else {\n      // The active annotation will need special rendering treatment. Render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      if (annotation.annotationUID === activeAnnotationUID) {\n        if (isDrawing) {\n          this.renderContourBeingDrawn(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingClosed) {\n          this.renderClosedContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else if (isEditingOpen) {\n          this.renderOpenContourBeingEdited(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          throw new Error(\n            `Unknown ${this.getToolName()} annotation rendering state`\n          );\n        }\n      } else {\n        if (\n          this.configuration.displayOnePointAsCrosshairs &&\n          annotation.data.contour.polyline.length === 1\n        ) {\n          this.renderPointContourWithMarker(\n            enabledElement,\n            svgDrawingHelper,\n            annotation\n          );\n        } else {\n          this.renderContour(enabledElement, svgDrawingHelper, annotation);\n        }\n      }\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    this._calculateStatsIfActive(\n      annotation,\n      targetId,\n      viewport,\n      renderingEngine,\n      enabledElement\n    );\n\n    this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n\n    return renderStatus;\n  }\n\n  _calculateStatsIfActive(\n    annotation: PlanarFreehandROIAnnotation,\n    targetId: string,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) {\n    const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n\n    if (\n      annotation.annotationUID === activeAnnotationUID &&\n      !this.commonData?.movingTextBox\n    ) {\n      return;\n    }\n\n    if (!this.commonData?.movingTextBox) {\n      const { data } = annotation;\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      }\n    }\n  }\n\n  private _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { cachedStats } = data;\n    const { polyline: points, closed } = data.contour;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n      const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n        const polyline = data.contour.polyline;\n        const numPoints = polyline.length;\n        const projectedPolyline = new Array(numPoints);\n\n        for (let i = 0; i < numPoints; i++) {\n          projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n        }\n\n        const {\n          maxX: canvasMaxX,\n          maxY: canvasMaxY,\n          minX: canvasMinX,\n          minY: canvasMinY,\n        } = math.polyline.getAABB(projectedPolyline);\n\n        const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n\n        const topLeftBBIndex = csUtils.transformWorldToIndex(\n          imageData,\n          topLeftBBWorld\n        );\n\n        const bottomRightBBWorld = viewport.canvasToWorld([\n          canvasMaxX,\n          canvasMaxY,\n        ]);\n\n        const bottomRightBBIndex = csUtils.transformWorldToIndex(\n          imageData,\n          bottomRightBBWorld\n        );\n\n        return [topLeftBBIndex, bottomRightBBIndex];\n      });\n\n      if (closed) {\n        this.updateClosedCachedStats({\n          targetId,\n          viewport,\n          canvasCoordinates,\n          points,\n          imageData,\n          metadata,\n          cachedStats,\n          modalityUnit,\n          calibratedScale,\n        });\n      } else {\n        this.updateOpenCachedStats({\n          metadata,\n          canvasCoordinates,\n          targetId,\n          cachedStats,\n          modalityUnit,\n          calibratedScale,\n        });\n      }\n    }\n\n    triggerAnnotationModified(\n      annotation,\n      enabledElement.viewport.element,\n      ChangeTypes.StatsUpdated\n    );\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  protected updateClosedCachedStats({\n    viewport,\n    points,\n    imageData,\n    metadata,\n    cachedStats,\n    targetId,\n    modalityUnit,\n    canvasCoordinates,\n    calibratedScale,\n  }) {\n    const { scale, areaUnits, units } = calibratedScale;\n\n    // Using an arbitrary start point (canvasPoint), calculate the\n    // mm spacing for the canvas in the X and Y directions.\n    const canvasPoint = canvasCoordinates[0];\n    const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n    const deltaXPoint = viewport.canvasToWorld([\n      canvasPoint[0] + 1,\n      canvasPoint[1],\n    ]);\n    const deltaYPoint = viewport.canvasToWorld([\n      canvasPoint[0],\n      canvasPoint[1] + 1,\n    ]);\n\n    const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n    const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n    const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n    worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n    worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n    worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n    let iMin = worldPosIndex[0];\n    let iMax = worldPosIndex[0];\n\n    let jMin = worldPosIndex[1];\n    let jMax = worldPosIndex[1];\n\n    let kMin = worldPosIndex[2];\n    let kMax = worldPosIndex[2];\n\n    for (let j = 1; j < points.length; j++) {\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n      iMin = Math.min(iMin, worldPosIndex[0]);\n      iMax = Math.max(iMax, worldPosIndex[0]);\n\n      jMin = Math.min(jMin, worldPosIndex[1]);\n      jMax = Math.max(jMax, worldPosIndex[1]);\n\n      kMin = Math.min(kMin, worldPosIndex[2]);\n      kMax = Math.max(kMax, worldPosIndex[2]);\n    }\n\n    const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n    worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n    worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n    worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n\n    let area = polyline.getArea(canvasCoordinates) / scale / scale;\n    // Convert from canvas_pixels ^2 to mm^2\n    area *= deltaInX * deltaInY;\n\n    // Expand bounding box\n    const iDelta = 0.01 * (iMax - iMin);\n    const jDelta = 0.01 * (jMax - jMin);\n    const kDelta = 0.01 * (kMax - kMin);\n\n    iMin = Math.floor(iMin - iDelta);\n    iMax = Math.ceil(iMax + iDelta);\n    jMin = Math.floor(jMin - jDelta);\n    jMax = Math.ceil(jMax + jDelta);\n    kMin = Math.floor(kMin - kDelta);\n    kMax = Math.ceil(kMax + kDelta);\n\n    const boundsIJK = [\n      [iMin, iMax],\n      [jMin, jMax],\n      [kMin, kMax],\n    ] as [Types.Point2, Types.Point2, Types.Point2];\n\n    const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n    const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n    let curRow = 0;\n    let intersections = [];\n    let intersectionCounter = 0;\n    const pointsInShape = pointInShapeCallback(\n      imageData,\n      (pointLPS, _pointIJK) => {\n        let result = true;\n        const point = viewport.worldToCanvas(pointLPS);\n        if (point[1] != curRow) {\n          intersectionCounter = 0;\n          curRow = point[1];\n          intersections = getLineSegmentIntersectionsCoordinates(\n            canvasCoordinates,\n            point,\n            [canvasPosEnd[0], point[1]]\n          );\n          intersections.sort(\n            (function (index) {\n              return function (a, b) {\n                return a[index] === b[index] ? 0 : a[index] < b[index] ? -1 : 1;\n              };\n            })(0)\n          );\n        }\n        if (intersections.length && point[0] > intersections[0][0]) {\n          intersections.shift();\n          intersectionCounter++;\n        }\n        if (intersectionCounter % 2 === 0) {\n          result = false;\n        }\n        return result;\n      },\n      this.configuration.statsCalculator.statsCallback,\n      boundsIJK\n    );\n    const stats = this.configuration.statsCalculator.getStatistics();\n\n    cachedStats[targetId] = {\n      Modality: metadata.Modality,\n      area,\n      perimeter: calculatePerimeter(canvasCoordinates, closed) / scale,\n      mean: stats.mean?.value,\n      max: stats.max?.value,\n      stdDev: stats.stdDev?.value,\n      statsArray: stats.array,\n      pointsInShape: pointsInShape,\n      /**\n       * areaUnits are sizing, eg mm^2 typically\n       * modality units are pixel value units, eg HU or other\n       * unit is linear measurement unit, eg mm\n       */\n      areaUnit: areaUnits,\n      modalityUnit,\n      unit: units,\n    };\n  }\n\n  protected updateOpenCachedStats({\n    targetId,\n    metadata,\n    canvasCoordinates,\n    cachedStats,\n    modalityUnit,\n    calibratedScale,\n  }) {\n    const { scale, units } = calibratedScale;\n\n    cachedStats[targetId] = {\n      Modality: metadata.Modality,\n      length: calculatePerimeter(canvasCoordinates, false) / scale,\n      modalityUnit,\n      unit: units,\n    };\n  }\n\n  private _renderStats = (\n    annotation,\n    viewport,\n    enabledElement,\n    svgDrawingHelper\n  ) => {\n    const { data } = <PlanarFreehandROIAnnotation>annotation;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.contour.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    area,\n    mean,\n    stdDev,\n    length,\n    perimeter,\n    max,\n    isEmptyArea,\n    areaUnit,\n    modalityUnit,\n    unit,\n  } = cachedVolumeStats || {};\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (Number.isFinite(max)) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  if (perimeter) {\n    textLines.push(`Perimeter: ${roundNumber(perimeter)} ${unit}`);\n  }\n\n  if (length) {\n    // No need to show length prefix as there is just the single value\n    textLines.push(`${roundNumber(length)} ${unit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { addTool, state } from '../../store';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\n\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        if (representation.type === SegmentationRepresentations.Contour) {\n          // if the representation is contour we need to make sure\n          // that the planarFreeHandTool is added to the toolGroup\n          this.addPlanarFreeHandToolIfAbsent(toolGroupId);\n        }\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  addPlanarFreeHandToolIfAbsent(toolGroupId) {\n    // if it is contour we should check if the toolGroup and more importantly\n    // the cornerstoneTools have the planarFreeHandTool added\n    if (!(planarContourToolName in state.tools)) {\n      addTool(PlanarFreehandContourSegmentationTool);\n    }\n\n    const toolGroup = getToolGroup(toolGroupId);\n\n    // check if toolGroup has this tool\n    if (!toolGroup.hasTool(planarContourToolName)) {\n      toolGroup.addTool(planarContourToolName);\n      toolGroup.setToolPassive(planarContourToolName);\n    }\n  }\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = csUtils.getVolumeId(targetId);\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      triggerAnnotationModified(annotation, element);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Types, utilities as coreUtils } from '@cornerstonejs/core';\n\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\n\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  triggerAnnotationCompleted,\n  triggerAnnotationModified,\n} from '../../stateManagement/annotation/helpers/state';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { pointInShapeCallback, roundNumber } from '../../utilities/';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n        computePointsInsideVolume: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n        showTextBox: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = csUtils.getVolumeId(targetId);\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endCoord = this._getEndCoordinate(\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startCoordinate: startCoord,\n        endCoordinate: endCoord,\n        cachedStats: {\n          pointsInVolume: [],\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n          statistics: [],\n        },\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    const targetId = this.getTargetId(enabledElement.viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    if (this.configuration.calculatePointsInsideVolume) {\n      this._computePointsInsideVolume(\n        annotation,\n        targetId,\n        imageVolume,\n        enabledElement\n      );\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      enabledElement.renderingEngine,\n      viewportIdsToRender\n    );\n\n    if (newAnnotation) {\n      triggerAnnotationCompleted(annotation);\n    }\n  };\n\n  //Now works for non-acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startCoordinate, endCoordinate } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n    const endIJK = transformWorldToIndex(imageData, points[0]);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // substitute the end slice index 2 with startIJK index 2\n\n    if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n      startWorld[2] = startCoordinate;\n      endWorld[2] = endCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0\n    ) {\n      startWorld[0] = startCoordinate;\n      endWorld[0] = endCoordinate;\n    } else if (\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1\n    ) {\n      startWorld[1] = startCoordinate;\n      endWorld[1] = endCoordinate;\n    }\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          //@ts-ignore\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n  }\n\n  //This function return all the points inside the ROI and calculate statistics for every slices between startCoordinate and endCoordinate\n  _computePointsInsideVolume(\n    annotation,\n    targetId,\n    imageVolume,\n    enabledElement\n  ) {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, viewUp } = metadata;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const projectionPoints = data.cachedStats.projectionPoints;\n\n    const pointsInsideVolume: Types.Point3[][] = [[]];\n    const image = this.getTargetIdImage(targetId, renderingEngine);\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n\n    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n      viewPlaneNormal,\n      viewUp,\n      worldPos1,\n      worldPos2\n    );\n    const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n\n    const area =\n      Math.abs(worldWidth * worldHeight) /\n      (measureInfo.scale * measureInfo.scale);\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    const modalityUnit = getModalityUnit(\n      metadata.Modality,\n      annotation.metadata.referencedImageId,\n      modalityUnitOptions\n    );\n\n    for (let i = 0; i < projectionPoints.length; i++) {\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!imageVolume) {\n        continue;\n      }\n\n      const projectionPoint = projectionPoints[i][0];\n\n      const { dimensions, imageData } = imageVolume;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n      //We only need to change the Z of our bounds so we are getting the Z from the current projection point\n      const worldProjectionPointIndex = transformWorldToIndex(\n        imageData,\n        projectionPoint\n      );\n\n      const indexOfProjection =\n        this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      worldPos1Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      worldPos2Index[indexOfProjection] =\n        worldProjectionPointIndex[indexOfProjection];\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        //@ts-ignore\n        pointsInsideVolume.push(pointsInShape);\n      }\n    }\n    const stats = this.configuration.statsCalculator.getStatistics();\n    data.cachedStats.pointsInVolume = pointsInsideVolume;\n    data.cachedStats.statistics = {\n      Modality: metadata.Modality,\n      area,\n      mean: stats.mean?.value,\n      stdDev: stats.stdDev?.value,\n      max: stats.max?.value,\n      statsArray: stats.array,\n      areaUnit: measureInfo.areaUnits,\n      modalityUnit,\n    };\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const targetId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    triggerAnnotationModified(annotation, viewport.element);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    let annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = filterAnnotationsWithinSamePlane(\n      annotations,\n      viewport.getCamera()\n    );\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startCoordinate, endCoordinate } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      const focalPoint = viewport.getCamera().focalPoint;\n      const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n\n      let startCoord: number | vec3 = startCoordinate;\n      let endCoord: number | vec3 = endCoordinate;\n      if (Array.isArray(startCoordinate)) {\n        startCoord = this._getCoordinateForViewplaneNormal(\n          startCoord,\n          viewplaneNormal\n        );\n      }\n\n      if (Array.isArray(endCoordinate)) {\n        endCoord = this._getCoordinateForViewplaneNormal(\n          endCoord,\n          viewplaneNormal\n        );\n      }\n\n      const roundedStartCoord = coreUtils.roundToPrecision(startCoord);\n      const roundedEndCoord = coreUtils.roundToPrecision(endCoord);\n\n      const coord = this._getCoordinateForViewplaneNormal(\n        focalPoint,\n        viewplaneNormal\n      );\n      const roundedCoord = coreUtils.roundToPrecision(coord);\n      // if the focalpoint is outside the start/end coordinates, we don't render\n      if (\n        roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n        roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (\n        roundedCoord === roundedStartCoord ||\n        roundedCoord === roundedEndCoord\n      ) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n\n      if (\n        this.configuration.showTextBox &&\n        this.configuration.calculatePointsInsideVolume\n      ) {\n        const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        if (!options.visibility) {\n          data.handles.textBox = {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          };\n          continue;\n        }\n\n        const textLines = this.configuration.getTextLines(data);\n        if (!textLines || textLines.length === 0) {\n          continue;\n        }\n\n        if (!data.handles.textBox.hasMoved) {\n          const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n          data.handles.textBox.worldPosition =\n            viewport.canvasToWorld(canvasTextBoxCoords);\n        }\n\n        const textBoxPosition = viewport.worldToCanvas(\n          data.handles.textBox.worldPosition\n        );\n\n        const textBoxUID = '1';\n        const boundingBox = drawLinkedTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textBoxUID,\n          textLines,\n          textBoxPosition,\n          canvasCoordinates,\n          {},\n          options\n        );\n\n        const { x: left, y: top, width, height } = boundingBox;\n\n        data.handles.textBox.worldBoundingBox = {\n          topLeft: viewport.canvasToWorld([left, top]),\n          topRight: viewport.canvasToWorld([left + width, top]),\n          bottomLeft: viewport.canvasToWorld([left, top + height]),\n          bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _getStartCoordinate(\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const startPos = worldPos;\n    const startCoord = this._getCoordinateForViewplaneNormal(\n      startPos,\n      viewPlaneNormal\n    );\n\n    return startCoord;\n  }\n\n  _getEndCoordinate(\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const endCoord = this._getCoordinateForViewplaneNormal(\n      endPos,\n      viewPlaneNormal\n    );\n\n    return endCoord;\n  }\n\n  _getIndexOfCoordinatesForViewplaneNormal(\n    viewPlaneNormal: Types.Point3\n  ): number {\n    const viewplaneNormalAbs = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n    const indexOfDirection = viewplaneNormalAbs.indexOf(\n      Math.max(...viewplaneNormalAbs)\n    );\n\n    return indexOfDirection;\n  }\n\n  _getCoordinateForViewplaneNormal(\n    pos: vec3 | number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const indexOfDirection =\n      this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n\n    return pos[indexOfDirection];\n  }\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data): string[] {\n  const cachedVolumeStats = data.cachedStats.statistics;\n\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { utilities } from '@cornerstonejs/core';\n\nimport {\n  getAnnotationNearPoint,\n  getAnnotationNearPointOnEnabledElement,\n} from './getAnnotationNearPoint';\n\n// Lodash/common JS functionality\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport {\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n} from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\n\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport scroll from './scroll';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport {\n  annotationHydration,\n  getClosestImageIdForStackViewport,\n} from './annotationHydration';\n// name spaces\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\n\nconst roundNumber = utilities.roundNumber;\n\n// Events\nimport { triggerEvent } from '@cornerstonejs/core';\n\nexport {\n  math,\n  planar,\n  viewportFilters,\n  drawing,\n  debounce,\n  dynamicVolume,\n  throttle,\n  orientation,\n  isObject,\n  touch,\n  triggerEvent,\n  calibrateImageSpacing,\n  getCalibratedLengthUnitsAndScale,\n  getCalibratedProbeUnitsAndValue,\n  getCalibratedAspect,\n  segmentation,\n  contours,\n  triggerAnnotationRenderForViewportIds,\n  triggerAnnotationRenderForToolGroupIds,\n  triggerAnnotationRender,\n  pointInShapeCallback,\n  getSphereBoundsInfo,\n  getAnnotationNearPoint,\n  getViewportForAnnotation,\n  getAnnotationNearPointOnEnabledElement,\n  jumpToSlice,\n  pointInSurroundingSphereCallback,\n  viewport,\n  cine,\n  clip,\n  boundingBox,\n  rectangleROITool,\n  planarFreehandROITool,\n  stackPrefetch,\n  stackContextPrefetch,\n  scroll,\n  roundNumber,\n  pointToString,\n  polyDataUtils,\n  voi,\n  annotationFrameRange,\n  contourSegmentation,\n  annotationHydration,\n  getClosestImageIdForStackViewport,\n};\n","import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n  publicAPI.getType = () => {\n    let value;\n    let prevValue = 0.0;\n    let functionType = 0;\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n    for (let i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y;\n\n      // Do not change the function type if equal\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n      prevValue = value;\n\n      // Exit loop if we find a Varied function\n      if (functionType === 3) {\n        break;\n      }\n    }\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n      case 1:\n        return 'NonDecreasing';\n      case 2:\n        return 'NonIncreasing';\n      case 3:\n      default:\n        return 'Varied';\n    }\n  };\n\n  // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n  publicAPI.getDataPointer = () => {\n    const size = model.nodes.length;\n    model.function = null;\n    if (size > 0) {\n      model.function = [];\n      for (let i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n    return model.function;\n  };\n\n  // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n  publicAPI.getFirstNonZeroValue = () => {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n    let allZero = 1;\n    let x = 0.0;\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    }\n\n    // If every specified point has a zero value then return\n    // a large value\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n    return x;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    const size = model.nodes.length;\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n  publicAPI.addPoint = (x, y) => publicAPI.addPointLong(x, y, 0.5, 0.0);\n\n  // Adds a point to the function and returns the array index of the point.\n  publicAPI.addPointLong = (x, y, midpoint, sharpness) => {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      y,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // Now find this node so we can return the index\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  };\n\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    model.nodes.sort((a, b) => a.x - b.x);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = model.range.slice();\n    const size = model.nodes.length;\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    }\n    // If the rage is the same, then no need to call Modified()\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  // Removes a point from the function. If no point is found then function\n  // remains the same.\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i;\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n    const retVal = i;\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  // Removes all points from the function.\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n  publicAPI.addSegment = (x1, y1, x2, y2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  };\n\n  // Return the value of the function at a position\n  publicAPI.getValue = x => {\n    const table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  };\n\n  // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n  publicAPI.adjustRange = range => {\n    if (range.length < 2) {\n      return 0;\n    }\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    const size = model.nodes.length;\n    if (size < 2) {\n      return -1.0;\n    }\n    let distance = model.nodes[1].x - model.nodes[0].x;\n    for (let i = 0; i < size - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n\n  // Returns a table of function values evaluated at regular intervals\n  /* eslint-disable prefer-destructuring */\n  /* eslint-disable no-continue */\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    let stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let i;\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastValue = 0.0;\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    let y1 = 0.0;\n    let y2 = 0.0;\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n\n    // For each table entry\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = stride * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at the end? If so, just use the last value\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = (x - x1) / (x2 - x1);\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2) ** (1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n\n        // Use one slope for both end points\n        const slope = y2 - y1;\n        const t = (1.0 - sharpness) * slope;\n\n        // Compute the value\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;\n\n        // Final error check to make sure we don't go outside\n        // the Y range\n        const min = y1 < y2 ? y1 : y2;\n        const max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n/* eslint-enable no-continue */\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n\n  // Internal objects initialization\n  model.nodes = [];\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['range']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkPiecewiseFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n","import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\n\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, J as floor, K as isInf, L as rgb2hsv, M as rgb2lab, N as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    return 16777216; // 2^24\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n","import { v as vtkColorMaps$1 } from './ColorMaps.json.js';\n\nconst presetMap = Object.create(null);\nvtkColorMaps$1.filter(p => p.RGBPoints).filter(p => p.ColorSpace !== 'CIELAB').forEach(p => {\n  presetMap[p.Name] = p;\n});\n\n// ----------------------------------------------------------------------------\n\nconst rgbPresetNames = Object.keys(presetMap);\nrgbPresetNames.sort();\n\n// ----------------------------------------------------------------------------\n\nfunction getPresetByName(name) {\n  return presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nfunction addPreset(preset) {\n  if (!preset.RGBPoints || preset.ColorSpace === 'CIELAB') {\n    return;\n  }\n  if (!presetMap[preset.Name]) {\n    rgbPresetNames.push(preset.Name);\n    rgbPresetNames.sort();\n  }\n  presetMap[preset.Name] = preset;\n}\n\n// ----------------------------------------------------------------------------\n\nfunction removePresetByName(name) {\n  const index = rgbPresetNames.indexOf(name);\n  if (index > -1) {\n    rgbPresetNames.splice(index, 1);\n  }\n  delete presetMap[name];\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorMaps = {\n  addPreset,\n  removePresetByName,\n  getPresetByName,\n  rgbPresetNames\n};\n\nexport { vtkColorMaps as default };\n","import Constants from './ImageMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractImageMapper from './AbstractImageMapper.js';\nimport { intersectWithLineForPointPicking, intersectWithLineForCellPicking } from './AbstractImageMapper/helper.js';\nimport { C as clampValue, R as multiply3x3_vect3, F as createUninitializedBounds, S as getSparseOrthogonalMatrix } from '../../Common/Core/Math/index.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\n\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  SlicingMode\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// vtkImageMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMapper');\n  publicAPI.getSliceAtPosition = pos => {\n    const image = publicAPI.getCurrentImage();\n    let pos3;\n    if (pos.length === 3) {\n      pos3 = pos;\n    } else if (Number.isFinite(pos)) {\n      const bds = image.getBounds();\n      switch (model.slicingMode) {\n        case SlicingMode.X:\n          pos3 = [pos, (bds[3] + bds[2]) / 2, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Y:\n          pos3 = [(bds[1] + bds[0]) / 2, pos, (bds[5] + bds[4]) / 2];\n          break;\n        case SlicingMode.Z:\n          pos3 = [(bds[1] + bds[0]) / 2, (bds[3] + bds[2]) / 2, pos];\n          break;\n      }\n    }\n    const ijk = [0, 0, 0];\n    image.worldToIndex(pos3, ijk);\n    const ex = image.getExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let slice = 0;\n    switch (ijkMode) {\n      case SlicingMode.I:\n        slice = clampValue(ijk[0], ex[0], ex[1]);\n        break;\n      case SlicingMode.J:\n        slice = clampValue(ijk[1], ex[2], ex[3]);\n        break;\n      case SlicingMode.K:\n        slice = clampValue(ijk[2], ex[4], ex[5]);\n        break;\n      default:\n        return 0;\n    }\n    return slice;\n  };\n  publicAPI.setSliceFromCamera = cam => {\n    const fp = cam.getFocalPoint();\n    switch (model.slicingMode) {\n      case SlicingMode.I:\n      case SlicingMode.J:\n      case SlicingMode.K:\n        {\n          const slice = publicAPI.getSliceAtPosition(fp);\n          publicAPI.setSlice(slice);\n        }\n        break;\n      case SlicingMode.X:\n        publicAPI.setSlice(fp[0]);\n        break;\n      case SlicingMode.Y:\n        publicAPI.setSlice(fp[1]);\n        break;\n      case SlicingMode.Z:\n        publicAPI.setSlice(fp[2]);\n        break;\n    }\n  };\n  publicAPI.setXSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.X);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setYSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Y);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setZSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.Z);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setISlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.I);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setJSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.J);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.setKSlice = id => {\n    publicAPI.setSlicingMode(SlicingMode.K);\n    publicAPI.setSlice(id);\n  };\n  publicAPI.getSlicingModeNormal = () => {\n    const out = [0, 0, 0];\n    const mat3 = publicAPI.getCurrentImage().getDirection();\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        out[0] = 1;\n        break;\n      case SlicingMode.Y:\n        out[1] = 1;\n        break;\n      case SlicingMode.Z:\n        out[2] = 1;\n        break;\n      case SlicingMode.I:\n        multiply3x3_vect3(mat3, [1, 0, 0], out);\n        break;\n      case SlicingMode.J:\n        multiply3x3_vect3(mat3, [0, 1, 0], out);\n        break;\n      case SlicingMode.K:\n        multiply3x3_vect3(mat3, [0, 0, 1], out);\n        break;\n    }\n    return out;\n  };\n  function computeClosestIJKAxis() {\n    let xyzMode;\n    switch (model.slicingMode) {\n      case SlicingMode.X:\n        xyzMode = 0;\n        break;\n      case SlicingMode.Y:\n        xyzMode = 1;\n        break;\n      case SlicingMode.Z:\n        xyzMode = 2;\n        break;\n      default:\n        model.closestIJKAxis = {\n          ijkMode: model.slicingMode,\n          flip: false\n        };\n        return;\n    }\n\n    // The direction matrix in vtkImageData is the indexToWorld rotation matrix\n    // with a column-major data layout since it is stored as a WebGL matrix.\n    const direction = publicAPI.getCurrentImage().getDirection();\n    const newMatrix = getSparseOrthogonalMatrix(direction);\n    // With {foo}Vector filled with 0s except at {foo}Mode position where it is 1\n    // We have xyzVector = (+/-) newMatrix * ijkVector\n    let ijkMode = 0;\n    for (; ijkMode < 3; ++ijkMode) {\n      if (newMatrix[xyzMode + 3 * ijkMode] !== 0) {\n        break;\n      }\n    }\n    const flip = newMatrix[xyzMode + 3 * ijkMode] < 0;\n    model.closestIJKAxis = {\n      ijkMode,\n      flip\n    };\n  }\n  publicAPI.setSlicingMode = mode => {\n    if (model.slicingMode === mode) {\n      return;\n    }\n    model.slicingMode = mode;\n    if (publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    publicAPI.modified();\n  };\n  publicAPI.getClosestIJKAxis = () => {\n    if ((model.closestIJKAxis === undefined || model.closestIJKAxis.ijkMode === SlicingMode.NONE) && publicAPI.getCurrentImage()) {\n      computeClosestIJKAxis();\n    }\n    return model.closestIJKAxis;\n  };\n  publicAPI.getBounds = () => {\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    if (!model.useCustomExtents) {\n      return image.getBounds();\n    }\n    const ex = model.customDisplayExtent.slice();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = model.slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(model.slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        ex[0] = nSlice;\n        ex[1] = nSlice;\n        break;\n      case SlicingMode.J:\n        ex[2] = nSlice;\n        ex[3] = nSlice;\n        break;\n      case SlicingMode.K:\n        ex[4] = nSlice;\n        ex[5] = nSlice;\n        break;\n    }\n    return image.extentToBounds(ex);\n  };\n  publicAPI.getBoundsForSlice = function () {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.slice;\n    let halfThickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const image = publicAPI.getCurrentImage();\n    if (!image) {\n      return createUninitializedBounds();\n    }\n    const extent = image.getSpatialExtent();\n    const {\n      ijkMode\n    } = publicAPI.getClosestIJKAxis();\n    let nSlice = slice;\n    if (ijkMode !== model.slicingMode) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      nSlice = publicAPI.getSliceAtPosition(slice);\n    }\n    switch (ijkMode) {\n      case SlicingMode.I:\n        extent[0] = nSlice - halfThickness;\n        extent[1] = nSlice + halfThickness;\n        break;\n      case SlicingMode.J:\n        extent[2] = nSlice - halfThickness;\n        extent[3] = nSlice + halfThickness;\n        break;\n      case SlicingMode.K:\n        extent[4] = nSlice - halfThickness;\n        extent[5] = nSlice + halfThickness;\n        break;\n    }\n    return image.extentToBounds(extent);\n  };\n  publicAPI.intersectWithLineForPointPicking = (p1, p2) => intersectWithLineForPointPicking(p1, p2, publicAPI);\n  publicAPI.intersectWithLineForCellPicking = (p1, p2) => intersectWithLineForCellPicking(p1, p2, publicAPI);\n  publicAPI.getCurrentImage = () => publicAPI.getInputData();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  slicingMode: SlicingMode.NONE,\n  closestIJKAxis: {\n    ijkMode: SlicingMode.NONE,\n    flip: false\n  },\n  renderToRectangle: false,\n  sliceAtFocalPoint: false,\n  preferSizeOverAccuracy: false // Whether to use halfFloat representation of float, when it is inaccurate\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkAbstractImageMapper.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['slicingMode']);\n  macro.setGet(publicAPI, model, ['closestIJKAxis', 'renderToRectangle', 'sliceAtFocalPoint', 'preferSizeOverAccuracy']);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkImageMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkImageMapper$1 as default, extend, newInstance };\n","import { mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkProp3D from './Prop3D.js';\nimport vtkImageProperty from './ImageProperty.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageSlice');\n  publicAPI.getActors = () => publicAPI;\n  publicAPI.getImages = () => publicAPI;\n  publicAPI.getIsOpaque = () => {\n    if (model.forceOpaque) {\n      return true;\n    }\n    if (model.forceTranslucent) {\n      return false;\n    }\n    // make sure we have a property\n    if (!model.property) {\n      // force creation of a property\n      publicAPI.getProperty();\n    }\n    let isOpaque = model.property.getOpacity() >= 1.0;\n\n    // are we using an opaque scalar array, if any?\n    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());\n    return isOpaque;\n  };\n\n  // Always render during opaque pass, to keep the behavior\n  // predictable and because depth-peeling kills alpha-blending.\n  // In the future, the Renderer should render images in layers,\n  // i.e. where each image will have a layer number assigned to it,\n  // and the Renderer will do the images in their own pass.\n  publicAPI.hasTranslucentPolygonalGeometry = () => false;\n  publicAPI.makeProperty = vtkImageProperty.newInstance;\n  publicAPI.getProperty = () => {\n    if (model.property === null) {\n      model.property = publicAPI.makeProperty();\n    }\n    return model.property;\n  };\n  publicAPI.getBounds = () => {\n    if (model.mapper === null) {\n      return model.bounds;\n    }\n\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBounds();\n    if (!bds || bds.length !== 6) {\n      return bds;\n    }\n\n    // Check for the special case when the actor is empty.\n    if (bds[0] > bds[1]) {\n      model.mapperBounds = bds.concat(); // copy the mapper's bounds\n      model.bounds = [1, -1, 1, -1, 1, -1];\n      model.boundsMTime.modified();\n      return bds;\n    }\n\n    // Check if we have cached values for these bounds - we cache the\n    // values returned by model.mapper.getBounds() and we store the time\n    // of caching. If the values returned this time are different, or\n    // the modified time of this class is newer than the cached time,\n    // then we need to rebuild.\n    const zip = rows => rows[0].map((_, c) => rows.map(row => row[c]));\n    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce((a, b) => a && b[0] === b[1], true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {\n      vtkDebugMacro('Recomputing bounds...');\n      model.mapperBounds = bds.map(x => x);\n      publicAPI.computeMatrix();\n      const tmp4 = new Float64Array(16);\n      mat4.transpose(tmp4, model.matrix);\n      vtkBoundingBox.transformBounds(bds, tmp4, model.bounds);\n      model.boundsMTime.modified();\n    }\n    return model.bounds;\n  };\n  publicAPI.getBoundsForSlice = (slice, thickness) => {\n    // Check for the special case when the mapper's bounds are unknown\n    const bds = model.mapper.getBoundsForSlice(slice, thickness);\n    // Check for the special case when the actor is empty.\n    if (!vtkBoundingBox.isValid(bds)) {\n      return bds;\n    }\n    publicAPI.computeMatrix();\n    const tmp4 = new Float64Array(16);\n    mat4.transpose(tmp4, model.matrix);\n    const newBounds = vtkBoundingBox.transformBounds(bds, tmp4);\n    return newBounds;\n  };\n\n  //----------------------------------------------------------------------------\n  // Get the minimum X bound\n  publicAPI.getMinXBound = () => publicAPI.getBounds()[0];\n\n  // Get the maximum X bound\n  publicAPI.getMaxXBound = () => publicAPI.getBounds()[1];\n\n  // Get the minimum Y bound\n  publicAPI.getMinYBound = () => publicAPI.getBounds()[2];\n\n  // Get the maximum Y bound\n  publicAPI.getMaxYBound = () => publicAPI.getBounds()[3];\n\n  // Get the minimum Z bound\n  publicAPI.getMinZBound = () => publicAPI.getBounds()[4];\n\n  // Get the maximum Z bound\n  publicAPI.getMaxZBound = () => publicAPI.getBounds()[5];\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.property !== null) {\n      const time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getRedrawMTime = () => {\n    let mt = model.mtime;\n    if (model.mapper !== null) {\n      let time = model.mapper.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.mapper.getInput() !== null) {\n        // FIXME !!! getInputAlgorithm / getInput\n        model.mapper.getInputAlgorithm().update();\n        time = model.mapper.getInput().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    if (model.property !== null) {\n      let time = model.property.getMTime();\n      mt = time > mt ? time : mt;\n      if (model.property.getRGBTransferFunction() !== null) {\n        time = model.property.getRGBTransferFunction().getMTime();\n        mt = time > mt ? time : mt;\n      }\n    }\n    return mt;\n  };\n  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  mapper: null,\n  property: null,\n  bounds: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkProp3D.extend(publicAPI, model, initialValues);\n\n  // vtkTimeStamp\n  model.boundsMTime = {};\n  macro.obj(model.boundsMTime);\n\n  // Build VTK API\n  macro.set(publicAPI, model, ['property']);\n  macro.setGet(publicAPI, model, ['mapper']);\n  macro.getArray(publicAPI, model, ['bounds'], 6);\n\n  // Object methods\n  vtkImageSlice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageSlice');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageSlice$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageSlice$1 as default, extend, newInstance };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously \\_()_/\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didnt happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n"],"names":["VideoViewport","constructor","props","super","canvas","element","videoWidth","videoHeight","loop","mute","isPlaying","scrollSpeed","playbackRate","frameRange","fps","videoCamera","panWorld","parallelScale","voiRange","lower","upper","getProperties","this","videoElement","muted","resetCamera","refreshRenderValues","canvasContext","fillRect","width","height","renderFrame","getNumberOfSlices","computedSlices","Math","round","duration","isNaN","numberOfFrames","getFrameOfReferenceUID","src","resize","clientWidth","clientHeight","canvasToWorld","canvasPos","destPos","pan","worldToCanvasRatio","getWorldToCanvasRatio","panOffsetCanvas","subCanvasPos","splice","worldToCanvas","worldPos","getRotation","canvasToIndex","transform","getTransform","invert","transformPoint","map","it","devicePixelRatio","indexToCanvas","indexPos","customRenderViewportToCanvas","transformationMatrix","getMatrix","ctx","resetTransform","drawImage","actor","getActors","render","triggerEvent","STACK_NEW_IMAGE","viewportId","id","viewport","renderingEngineId","time","currentTime","IMAGE_RENDERED","imageIndex","getCurrentImageIdIndex","numberOfSlices","initialRender","frame","getFrameNumber","setFrameNumber","pause","renderWhilstPlaying","requestAnimationFrame","getContext","setAttribute","document","createElement","autoplay","crossOrigin","addEventListeners","frameRangeExtractor","useCustomRenderingPipeline","addEventListener","ELEMENT_DISABLED","elementDisabledHandler","removeEventListeners","removeEventListener","remove","getImageDataMetadata","image","imageId","imagePlaneModule","MetadataModules","IMAGE_PLANE","rowCosines","columnCosines","rowCosineVec","colCosineVec","rows","columns","scanAxisNormal","origin","imagePositionPatient","xSpacing","columnPixelSpacing","ySpacing","rowPixelSpacing","xVoxels","yVoxels","hasPixelSpacing","bitsAllocated","numComps","direction","dimensions","spacing","numVoxels","setDataIds","imageIds","options","setVideo","viewReference","sliceIndex","frameNumber","Array","isArray","imageUrlModule","IMAGE_URL","rendered","Error","generalSeries","GENERAL_SERIES","modality","Modality","metadata","cineRate","CINE","setVideoURL","then","setFrameRange","Promise","resolve","window","setTimeout","videoURL","preload","loadedMetadataEventHandler","getImageIds","baseImageId","replace","i","togglePlayPause","play","e","scroll","delta","newTime","seekEventListener","evt","start","paused","end","setTime","timeInSeconds","length","getFrameRange","setProperties","undefined","setPlaybackRate","setScrollSpeed","setVOI","rate","unit","FRAME","SECOND","resetProperties","getScalarData","scalarData","context","getImageData","data","getRange","imageData","getDirection","getDimensions","getSpacing","worldToIndex","point","canvasPoint","pixelCoord","indexToWorld","destPoint","calibration","preScale","scaled","Object","defineProperty","get","enumerable","hasImageURI","imageURI","framesMatch","match","testURI","substring","index","indexOf","setColorTransform","setWindowLevel","windowWidth","windowCenter","setAverageWhite","averageWhite","feFilter","white","maxWhite","max","scaleWhite","c","wlScale","wlDelta","style","filter","setCamera","camera","focalPoint","focalPointCanvas","canvasCenter","panWorldDelta","fillStyle","getCurrentImageId","getReferenceId","specifier","isReferenceViewable","viewRef","referencedImageId","colonIndex","withNavigation","currentIndex","getSliceIndex","range","split","Number","setViewReference","getViewReference","viewRefSpecifier","getCamera","parallelProjection","position","viewUp","viewPlaneNormal","getFrameRate","getPan","offsetWidth","offsetHeight","drawWidth","floor","drawHeight","xOffsetWorld","yOffsetWorld","getCanvasToWorldRatio","canvasToWorldRatio","halfCanvas","halfCanvasWorldCoordinates","scale","translate","updateCameraClippingPlanesAndRange","addImages","stackInputs","actors","forEach","stackInput","getImage","imageActor","createActorMapper","push","uid","actorUID","callback","setActors","async","renderingEngine","viewportIds","getViewport","console","warn","addStackPromises","all","volumeInputs","immediateRender","suppressEvents","addVolumePromises","addVolumes","COLOR_TRANSPARENT","getRank","array","elem","left","right","mid","midElem","makeMappingArray","N","gamma","x","y0","y1","lut","xLinSpace","a","b","n","increment","vector","linspace","pow","xLinSpaceIndexes","inputArray","values","indexes","len","sort","searchSorted","colorPercent","colorDelta","getColormap","colormapData","colormap","name","colors","segmentedData","redLut","red","greenLut","green","blueLut","blue","rgba","createLinearSegmentedColormap","numColors","getId","getColorSchemeName","setColorSchemeName","getNumberOfColors","setNumberOfColors","getColor","isValidIndex","getColorRepeating","setColor","addColor","insertColor","removeColor","clearColors","buildLookupTable","setNumberOfTableValues","setTableValue","createLookupTable","performance","now","Date","voiLUT","shift","toString","minValue","maxValue","maxValueMapped","firstValueMapped","modalityLutValue","generateNonLinearVOILUT","value","min","generateLinearVOILUT","enabledElement","m","calculateTransform","setTransform","doesImageNeedToBeRendered","lastRenderedImageId","renderingTools","lastRenderedViewport","voi","rotation","hflip","vflip","modalityLUT","renderCanvas","renderCanvasData","renderCanvasContext","isColor","color","lastRenderedIsColor","getLut","cachedLut","maxPixelValue","minPixelValue","offset","lutArray","Uint8ClampedArray","vlutfn","storedValue","generateColorLUT","getRenderCanvas","invalidated","canvasWasColor","getCanvas","initializeRenderCanvas","colorLUT","stats","lastLutGenerateTime","canvasImageDataData","pixelData","getPixelData","lastGetPixelDataTime","canvasImageDataIndex","storedPixelDataIndex","numPixels","lastStoredPixelDataToCanvasImageDataTime","storedRGBAPixelDataToCanvasImageData","storedColorPixelDataToCanvasImageData","putImageData","lastPutImageDataTime","renderColorImage","imageSmoothingEnabled","pixelReplication","setToPixelCoordinateSystem","sx","displayedArea","tlhc","sy","y","brhc","saveLastRendered","computeAutoVoi","hasLut","hasVoi","maxVoi","slope","intercept","minVoi","ww","wc","lutMatches","mlutfn","storedPixelValue","generateNonLinearModalityLUT","generateLinearModalityLUT","getModalityLut","isPreScaled","generateLut","useAlphaChannel","minimum","collectedMultiplierTerms","petVOILutFunction","lutFunction","storedPixelDataToCanvasImageDataPET","Int16Array","Uint16Array","storedPixelDataToCanvasImageData","pixelValue","storedPixelDataToCanvasImageDataRGBA","renderGrayscaleImage","grayscaleLut","grayscale","clut","Table","renderPseudoColorImage","colormapId","clamp","lastRenderTime","renderTimeInMs","invalid","needsRedraw","angle","rotate","PI","widthScale","heightScale","presentationSizeMode","verticalScale","horizontalScale","translation","pt","viewportOrientation","cosA","cos","sinA","sin","newX","newY","state","initialDefaultViewport","labelmap","assign","createViewport","getImageFitScale","scaleFactor","imageSize","verticalRatio","horizontalRatio","isRotated","resetPan","resetZoom","forceFitToWindow","oldCanvasWidth","oldCanvasHeight","setCanvasSize","getImageSize","imageWidth","imageHeight","wasFitToWindow","fitToWindow","relWidthChange","relHeightChange","relChange","sqrt","relativeRescale","Transform","reset","clone","multiply","matrix","m11","m12","m21","m22","dx","dy","d","m0","m1","m2","m3","m4","m5","rad","s","validateParameterUndefinedOrNull","checkParam","errorMsg","vtkDebugMacro","DEFAULT_VALUES","mapper","property","bounds","extend","publicAPI","model","initialValues","arguments","boundsMTime","obj","set","setGet","getArray","classHierarchy","getVolumes","makeProperty","getProperty","getBounds","bds","mapperBounds","concat","modified","_","row","reduce","getMTime","bbox","computeMatrix","tmp4","Float64Array","MAX_VALUE","mt","mtime","getRedrawMTime","getInput","getInputAlgorithm","update","vtkVolume","vtkVolume$1","newInstance","useNativeDataType","volumeId","blendMode","imageVolume","loadVolume","vtkOpenGLTexture","volumeMapper","createVolumeMapper","setBlendMode","volumeActor","setMapper","getPointData","getScalars","getNumberOfComponents","setIndependentComponents","setDefaultVolumeVOI","getRGBTransferFunction","voiModifiedEventDetail","Events","VOI_MODIFIED","triggerVOIModified","PRIORITY","REQUEST_TYPE","RequestType","Prefetch","voiLutModule","voiLut","windowLevel","getVOIFromMetadata","imageIdIndex","generalSeriesModule","modalityLutModule","numImages","bytesPerImage","byteLength","voxelsPerImage","bytePerPixel","BYTES_PER_ELEMENT","scalingParameters","rescaleSlope","rescaleIntercept","scalingParametersToUse","suvFactor","suvbw","byteOffset","targetBuffer","type","priority","requestType","enabled","referencedImageIds","loadAndCacheImage","ignoreCache","imageScalarData","buffer","TypedArray","volumeBufferView","_getImageScalarDataFromImageVolume","getMinMax","getVOIFromMinMax","scaling","PT","_isCurrentImagePTPrescaled","handlePreScaledVolume","setMappingRange","scalarTexture","superDelete","delete","vtkSharedVolumeMapper","ONE_GB","_imageCache","Map","_volumeCache","_imageCacheSize","_volumeCacheSize","_maxCacheSize","_maxInstanceSize","setMaxCacheSize","newMaxCacheSize","errorMessage","isCacheable","getBytesAvailable","getMaxCacheSize","getMaxInstanceSize","getCacheSize","_decacheImage","cachedImage","imageLoadObject","cancelFn","decache","_decacheVolume","cachedVolume","volumeLoadObject","volume","cancelLoading","_restoreImagesFromBuffer","purgeCache","imageIterator","keys","done","next","removeImageLoadObject","IMAGE_CACHE_IMAGE_REMOVED","purgeVolumeCache","volumeIterator","removeVolumeLoadObject","VOLUME_CACHE_VOLUME_REMOVED","getVolumeLoadObject","timeStamp","getGeometry","geometryId","cachedGeometry","_geometryCache","geometry","getVolume","from","filterVolumesByReferenceId","referencedVolumeId","incrementImageCacheSize","sizeInBytes","eventDetails","incrementVolumeCacheSize","putGeometryLoadObject","geometryLoadObject","has","loaded","promise","GEOMETRY_CACHE_GEOMETRY_ADDED","catch","error","decrementImageCacheSize","decrement","decrementVolumeCacheSize","decacheIfNecessaryUntilBytesAvailable","numBytes","volumeImageIds","bytesAvailable","cachedImages","cachedImageIds","im","imageIdsToPurge","includes","putImageLoadObject","sharedCacheKey","toFixed","CACHE_SIZE_EXCEEDED","IMAGE_CACHE_IMAGE_ADDED","getImageLoadObject","isLoaded","getVolumeContainingImageId","volumeIds","imageIdToUse","imageIdToURI","getImageURIIndex","getCachedImageBasedOnImageURI","imageURIToUse","foundImageId","find","putVolumeLoadObject","VOLUME_CACHE_VOLUME_ADDED","imageCacheOffsetMap","size","viewPixelData","imageFrame","bufferView","log","RENDERING_DEFAULTS","MINIMUM_SLAB_THICKNESS","MAXIMUM_RAY_DISTANCE","freeze","ViewportStatus","BlendMode","BlendModes","GeometryType","DynamicOperatorType","CalibrationTypes","getEnabledElement","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","hasBeenDestroyed","FrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","getEnabledElements","enabledElements","getViewports","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","base","dictionary","create","seal","key","unset","endsWith","deleteCount","namespace","slice","deleteAll","prototype","hasOwnProperty","call","startsWith","iterate","import","root","isPlainObject","dump","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","runtimeSettings","getObjectSettings","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","isValidKey","prefix","record","failCount","add","field","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","imageLoaders","unknownImageLoader","loadImageFromImageLoader","scheme","loader","IMAGE_LOADED","errorObject","IMAGE_LOAD_FAILED","loadImageFromCacheOrVolume","cachedVolumeInfo","loadStatus","convertToCornerstoneImage","loadImage","err","loadAndCacheImages","createAndCacheDerivedImage","preventCache","uuidv4","skipCreateBuffer","onCacheAdd","metaData","TypedArrayConstructor","getBufferConfiguration","targetBufferType","derivedImageId","genericMetadataProvider","imagePixelModule","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","createAndCacheDerivedImages","derivedImageIds","allPromises","newOptions","getDerivedImageId","promises","voiLUTFunction","Uint8Array","Float32Array","cancelLoadImage","filterRequests","additionalDetails","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","loadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedSegmentationImages","createAndCacheDerivedSegmentationImage","createInternalVTKRepresentation","PhotometricInterpretation","numComponents","dataArrayAttrs","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","isDynamicVolume","scalarDataArrays","vtkScalarArray","addArray","setActiveScalars","addScalarDataArraysToImageData","getScalarDataArrays","scalarArray","setScalars","addScalarDataToImageData","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","setupCacheOptimizationEventListener","VOLUME_LOADED","VOLUME_LOADED_FAILED","createAndCacheVolume","createAndCacheDerivedVolume","referencedVolume","scalarLength","volumeScalarData","generateVolumeScalarData","derivedImageData","derivedVolume","createLocalVolume","validDataTypes","createAndCacheVolumeFromImages","volumeProps","generateVolumePropsFromImageIds","imagePromises","performCacheOptimizationForVolume","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedSegmentationVolume","createLocalSegmentationVolume","useNorm16Texture","rendering","use16BitTexture","isVolumeBuffer","sharedArrayBuffer","createFloat32SharedArray","createUint8SharedArray","createUint16SharedArray","providers","addProvider","provider","removeProvider","removeAllProviders","getMetaData","queries","result","imageLoadPoolManager","grabDelay","setMaxSimultaneousRequests","Interaction","Thumbnail","RequestPoolManager","numRequests","interaction","thumbnail","prefetch","compute","awake","maxNumRequests","getMaxSimultaneousRequests","destroy","timeoutHandle","clearTimeout","addRequest","requestFn","requestDetails","startGrabbing","filterFunction","sendRequests","requestsToSend","syncImageCount","getNextRequest","requestResult","finally","startAgain","interactionPriorities","getSortedPriorityGroups","hasRemainingInteractionRequests","hasRemainingThumbnailRequests","hasRemainingPrefetchRequests","hasRemainingComputeRequests","Compute","enableCacheOptimization","shouldUseSAB","addEventListenerOnce","IMAGE_VOLUME_LOADING_COMPLETED","detail","_updateImageWithScalarDataView","_processImageCacheOffsetMap","compatibleScalarData","sampleImageIdWithImage","sampleImage","samplePixelData","getImageIdIndex","_processVolumeImages","view","_colormaps","registerColormap","Name","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","RGBPoints","presetRGBPoints","opacity","opacityPoints","getScalarOpacity","getDataPointer","createLinearRGBTransferFunction","cfun","addRGBPoint","spacingInNormalDirection","actorEntry","referenceId","sliceRange","getTransferFunctionNodes","transferFunction","getSize","nodeValue1","getNodeValue","setTransferFunctionNodes","nodes","removeAllPoints","node","transformWorldToIndex","el","event","CustomEvent","cancelable","dispatchEvent","workerRegistry","workerPoolManager","registerWorker","workerName","workerFn","maxWorkerInstances","overwrite","autoTerminateOnIdle","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","fill","worker","getNextWorkerAPI","workerInstances","instance","minLoadIndex","minLoadValue","currentLoadValue","api","executeTask","methodName","args","callbacks","reject","finalCallbacks","cb","processing","results","setInterval","terminateIdleWorkers","terminateWorkerInstance","terminate","workerInstance","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Height","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","getDefinedSVGCursorDescriptor","svgCursorNames","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","viewportElement","internalDivElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","bind","fn","svgDrawingHelper","ToolModes","Active","Passive","Enabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","viewportsInfo","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","getViewportsInfo","getToolInstance","toolInstanceName","toolInstance","getToolInstances","hasTool","toolName","addTool","configuration","toolDefinition","tools","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","toolGroupId","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","getRenderingEngines","renderingEngineUIDToUse","some","vpId","getActivePrimaryMouseButtonTool","setViewportsCursorByToolName","eventDetail","eventTarget","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","setToolMode","mode","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","bindings","unique","binding","TouchBinding","numTouchPoints","MouseBinding","hasSameBinding","useCursor","_hasMousePrimaryButtonBinding","cursor","MouseCursor","getDefinedCursor","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","matchBindings","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","cursorName","SVGMouseCursor","initElementCursor","setToolConfiguration","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","newToolGroupId","fnToolFilter","toolGroup","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","getRenderingEngine","renderViewport","TOOL_MODE_CHANGED","binding1","binding2","modifierKey","toolGroups","tg","toolGroupIndex","findIndex","removeToolGroup","removeSegmentationsFromToolGroup","MODES","toolGroupToolNames","BidirectionalTool","toolProps","defaultToolProps","supportedInteractionTypes","preventHandleOutsideImage","getTextLines","defaultGetTextLines","isPointNearTool","annotation","canvasCoords","proximity","points","handles","canvasPoint1","canvasPoint2","line","distanceToPoint","toolSelectedCallback","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","p","_endCallback","newAnnotation","hasMoved","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","isDrawing","_dragDrawCallback","currentPoints","world","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","_activateDraw","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","renderAnnotation","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","targetId","getTargetId","styleSpecifier","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","visibility","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","top","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetIdImage","index1","index2","index3","index4","handles1","handles2","scale1","units","units1","scale2","units2","dist1","_calculateLength","dist2","lengthUnit","widthUnit","_isInsideVolume","vector1","vector2","atan2","trailing","addNewAnnotation","getReferencedImageId","label","addAnnotation","pos1","pos2","dz","roundNumber","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","radius","allowOpenContours","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","calculateStats","statsCalculator","BasicStatsCalculator","isEditingClosed","isEditingOpen","createAnnotation","activateDraw","activateOpenContourEndEdit","contour","closed","activateClosedContourEdit","activateOpenContourEdit","previousPoint","p1","p2","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","modalityUnitOptions","isSuvScaled","modalityUnit","calibratedScale","numPoints","projectedPolyline","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","math","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","updateClosedCachedStats","updateOpenCachedStats","ChangeTypes","StatsUpdated","_renderStats","annotationsToDisplay","VolumeViewport","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","isParallel","abs","halfSpacingInNormalDirection","annotationsWithinSlice","isVisible","dir","dot","isContourSegmentationTool","contourAnnotation","renderAnnotationInstance","renderContext","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","areaUnit","area","mean","stdDev","areaUnits","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","iMin","iMax","jMin","jMax","kMin","kMax","j","worldPosIndex2","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","canvasPosEnd","curRow","intersections","intersectionCounter","pointsInShape","pointLPS","_pointIJK","getLineSegmentIntersectionsCoordinates","statsCallback","getStatistics","perimeter","statsArray","cachedVolumeStats","isEmptyArea","areaLine","isFinite","planarContourToolName","SegmentationDisplayTool","renderSegmentation","getToolGroup","toolGroupSegmentationRepresentations","getSegmentationRepresentations","toolGroupViewports","segmentationRenderList","representation","config","_getMergedRepresentationsConfig","viewportsRenderList","renderers","Labelmap","Contour","Surface","addPlanarFreeHandToolIfAbsent","display","renderedViewport","allSettled","segmentationRepresentation","setSegmentationVisibility","segmentationRepresentationUID","toolGroupConfig","globalConfig","RectangleROIThresholdTool","RectangleROITool","StackViewport","cache","segmentationId","triggerAnnotationRenderForViewportIds","getStyle","rectangleUID","drawRect","RectangleROIStartEndThresholdTool","numSlicesToPropagate","computePointsInsideVolume","showTextBox","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","projectionPointsImageIds","statistics","labelmapUID","_computeProjectionPoints","calculatePointsInsideVolume","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","viewplaneNormal","_getCoordinateForViewplaneNormal","roundedStartCoord","roundedEndCoord","coord","roundedCoord","firstOrLastSlice","lineDashToUse","throttle","_calculateCachedStatsTool","startIJK","endIJK","startWorld","indexToWorldVec3","endWorld","_getIndexOfCoordinatesForViewplaneNormal","distance","newProjectionPoints","dist","newPoint","pointsInsideVolume","worldWidth","worldHeight","getWorldWidthAndHeightFromCorners","measureInfo","habdles","isViewportPreScaled","getModalityUnit","projectionPoint","worldPos1Index","worldProjectionPointIndex","indexOfProjection","worldPos2Index","pointInShapeCallback","startPos","endPos","viewplaneNormalAbs","pos","utilities","vtkErrorMacro","clamping","allowDuplicateScalars","setArray","getType","prevValue","functionType","function","getFirstNonZeroValue","allZero","val","midpoint","sharpness","setNodeValue","oldX","sortAndUpdateRange","addPoint","addPointLong","removePoint","setNodes","updateRange","oldRange","retVal","modifiedInvoked","addSegment","x1","x2","y2","getValue","table","getTable","adjustRange","functionRange","estimateMinNumberOfSamples","findMinimumXDistance","currentDist","xStart","xEnd","stride","idx","numNodes","lastValue","tidx","ss","sss","h1","h2","h3","h4","t","vtkPiecewiseFunction","vtkPiecewiseFunction$1","directionOfProjection","useHorizontalViewAngle","viewAngle","clippingRange","useOffAxisProjection","screenBottomLeft","screenBottomRight","screenTopRight","freezeFocalPoint","projectionMatrix","viewMatrix","cameraLightTransform","physicalTranslation","physicalScale","physicalViewUp","physicalViewNorth","setGetArray","dopbasis","upbasis","tmpMatrix","tmpMatrix2","tmpvec1","tmpvec2","tmpvec3","rotateMatrix","trans","newPosition","newFocalPoint","computeViewPlaneNormal","orthogonalizeViewUp","vt","getViewMatrix","setPosition","z","computeDistance","setFocalPoint","setDistance","vec","dolly","amount","roll","eye","at","up","viewUpVec4","viewDir","r","azimuth","fp","yaw","elevation","axis","pitch","zoom","factor","applyTransform","transformMat4","vuOld","posNew","fpNew","vuNew","setViewUp","getThickness","setThickness","thickness","setClippingRange","setThicknessFromFocalPoint","setRoll","getRoll","setObliqueAngles","alpha","beta","getOrientation","getOrientationWXYZ","getFrustumPlanes","aspect","getCameraLightTransformMatrix","computeCameraLightTransform","deepCopy","sourceCamera","physicalOrientationToWorldDirection","ori","oriq","coriq","qdir","getPhysicalToWorldMatrix","getWorldToPhysicalMatrix","physVRight","computeViewParametersFromViewMatrix","vmat","oldDist","setDirectionOfProjection","computeViewParametersFromPhysicalMatrix","mat","setViewMatrix","setProjectionMatrix","getProjectionMatrix","nearz","farz","cWidth","cRange","xmin","xmax","ymin","ymax","tmp","tan","znear","zfar","getCompositeProjectionMatrix","vMat","pMat","setDeviceAngles","screen","rotmat","dop","vup","setOrientationWXYZ","degrees","quatMat","q","newdop","newvup","computeClippingRange","vn","k","vtkCamera","vtkCamera$1","ColorSpace","Scale","ScalarMappingTarget","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","M","acos","h","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","lab1","lab2","msh1","msh2","localS","a1","a2","adiff","vtkColorTransferFunctionAngleDiff","Mmid","mshTmp","labTmp","vtkColorTransferFunctionMshToLab","colorSpace","RGB","hSVWrap","LINEAR","nanColor","belowRangeColor","aboveRangeColor","useAboveRangeColor","useBelowRangeColor","tableSize","buildTime","discretize","numberOfValues","g","addRGBPointLong","addHSVPoint","v","addHSVPointLong","rgb","hsv","before","JSON","stringify","after","mappingRange","movePoint","addRGBSegment","r1","g1","b1","r2","g2","b2","addHSVSegment","s1","v1","s2","v2","hsv1","hsv2","mapValue","indexedLookup","getAnnotatedValueIndexInternal","getNanColorByReference","nodeVal","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","lastR","lastG","lastB","tmpVec","usingLogScale","LOG10","logStart","logEnd","logX","log10","deltaRange","xn","discretizeIndex","getUseAboveRangeColor","getUseBelowRangeColor","HSV","hsvTmp","LAB","DIVERGING","getUint8Table","withAlpha","tableWithAlpha","nbChannels","tmpTable","buildFunctionFromArray","getNumberOfTuples","getComponent","buildFunctionFromTable","inc","getNumberOfAvailableColors","getIndexedColor","nodeValue","fillFromDataPointer","nb","ptr","originalRange","mapScalarsThroughTable","input","output","outFormat","inputOffset","mapDataIndexed","mapData","getAlpha","inIncr","outputV","getData","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","applyColorMap","colorMap","oldColorSpace","toUpperCase","isModified","oldNanColor","NanColor","oldNodes","callModified","vtkColorTransferFunction","vtkColorTransferFunction$1","presetMap","vtkColorMaps","addPreset","preset","removePresetByName","staticOffsetAPI","otherStaticMethods","SlicingMode","slicingMode","NONE","closestIJKAxis","ijkMode","flip","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy","implementCoincidentTopologyMethods","computeClosestIJKAxis","xyzMode","X","Y","Z","getCurrentImage","newMatrix","getSliceAtPosition","pos3","ijk","ex","getExtent","getClosestIJKAxis","I","J","K","setSliceFromCamera","cam","getFocalPoint","setSlice","setXSlice","setSlicingMode","setYSlice","setZSlice","setISlice","setJSlice","setKSlice","getSlicingModeNormal","out","mat3","useCustomExtents","customDisplayExtent","nSlice","extentToBounds","getBoundsForSlice","halfThickness","extent","getSpatialExtent","intersectWithLineForPointPicking","intersectWithLineForCellPicking","getInputData","vtkImageMapper","vtkImageMapper$1","INIT_BOUNDS","getImages","getIsOpaque","forceOpaque","forceTranslucent","isOpaque","getOpacity","hasTranslucentPolygonalGeometry","getMinXBound","getMaxXBound","getMinYBound","getMaxYBound","getMinZBound","getMaxZBound","getSupportsSelection","vtkImageSlice","vtkImageSlice$1","HASH_UNDEFINED","INFINITY","funcTag","genTag","symbolTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","freeSelf","self","Function","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","getNative","nativeCreate","symbolProto","symbolToString","Hash","entries","clear","entry","ListCache","MapCache","assocIndexOf","other","baseGet","object","path","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","isHostObject","toSource","getMapData","__data__","memoize","string","baseToString","number","quote","resolver","TypeError","memoized","apply","Cache","isObjectLike","module","exports","defaultValue","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","message","stack","ep","globalThis","allowedOrigins","ev","allowedOrigin","isAllowedOrigin","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","_thisArg","rawArgumentList","processArguments","construct","register","registerProxy","processed","arr","handler","serializedValue","msg","random","MAX_SAFE_INTEGER","join","l","bisector","f","compare1","compare2","lo","hi","zero","center"],"sourceRoot":""}